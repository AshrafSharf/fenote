console.log('//0002//////////////////////////////');

function f1 () {
    var n = 999;
    function f2 () {
        console.log(n);
    }
    return f2;
}
var result = f1();
result(); // 999

console.log('////////////////////////////////////');

/*

 执行上下文详细图解
 详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。

 单线程
 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
 全局上下文只有唯一的一个，它在浏览器关闭时出栈
 函数的执行上下文的个数没有限制
 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。
 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。

 JavaScript拥有自动的垃圾回收机制，那就是当一个值，在内存中失去引用时，
 垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。

 */



