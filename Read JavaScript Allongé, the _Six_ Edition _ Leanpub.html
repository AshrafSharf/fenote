<!DOCTYPE html>
<!-- saved from url=(0066)https://leanpub.com/javascriptallongesix/read#generating-iterables -->
<html class="wf-notosans-n4-active wf-notosans-n7-active wf-notosans-i4-active wf-notosans-i7-active wf-notoserif-n4-active wf-notoserif-n7-active wf-notoserif-i4-active wf-notoserif-i7-active wf-active js no-touch multiplebgs svg inlinesvg svgclippaths no-ie8compat fa-events-icons-ready" lang="en" style=""><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible">

<script type="text/javascript" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/316786248d"></script><script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/nr-1026.min.js"></script><script async="" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/uwt.js"></script><script async="" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/fbevents.js"></script><script async="" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/analytics.js"></script><script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","errorBeacon":"bam.nr-data.net","licenseKey":"316786248d","applicationID":"8006771","transactionName":"e14PEEIKDlsARx1BUllVEktDDQ1A","queueTime":0,"applicationTime":3469,"agent":""}</script>
<script type="text/javascript">(window.NREUM||(NREUM={})).loader_config={xpid:"VQYCWFVQDBAIVFFUAAYG"};window.NREUM||(NREUM={}),__nr_require=function(t,n,e){function r(e){if(!n[e]){var o=n[e]={exports:{}};t[e][0].call(o.exports,function(n){var o=t[e][1][n];return r(o||n)},o,o.exports)}return n[e].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<e.length;o++)r(e[o]);return r}({1:[function(t,n,e){function r(t){try{s.console&&console.log(t)}catch(n){}}var o,i=t("ee"),a=t(15),s={};try{o=localStorage.getItem("__nr_flags").split(","),console&&"function"==typeof console.log&&(s.console=!0,o.indexOf("dev")!==-1&&(s.dev=!0),o.indexOf("nr_dev")!==-1&&(s.nrDev=!0))}catch(c){}s.nrDev&&i.on("internal-error",function(t){r(t.stack)}),s.dev&&i.on("fn-err",function(t,n,e){r(e.stack)}),s.dev&&(r("NR AGENT IN DEVELOPMENT MODE"),r("flags: "+a(s,function(t,n){return t}).join(", ")))},{}],2:[function(t,n,e){function r(t,n,e,r,o){try{d?d-=1:i("err",[o||new UncaughtException(t,n,e)])}catch(s){try{i("ierr",[s,c.now(),!0])}catch(u){}}return"function"==typeof f&&f.apply(this,a(arguments))}function UncaughtException(t,n,e){this.message=t||"Uncaught error with no additional information",this.sourceURL=n,this.line=e}function o(t){i("err",[t,c.now()])}var i=t("handle"),a=t(16),s=t("ee"),c=t("loader"),f=window.onerror,u=!1,d=0;c.features.err=!0,t(1),window.onerror=r;try{throw new Error}catch(l){"stack"in l&&(t(8),t(7),"addEventListener"in window&&t(5),c.xhrWrappable&&t(9),u=!0)}s.on("fn-start",function(t,n,e){u&&(d+=1)}),s.on("fn-err",function(t,n,e){u&&(this.thrown=!0,o(e))}),s.on("fn-end",function(){u&&!this.thrown&&d>0&&(d-=1)}),s.on("internal-error",function(t){i("ierr",[t,c.now(),!0])})},{}],3:[function(t,n,e){t("loader").features.ins=!0},{}],4:[function(t,n,e){function r(t){}if(window.performance&&window.performance.timing&&window.performance.getEntriesByType){var o=t("ee"),i=t("handle"),a=t(8),s=t(7),c="learResourceTimings",f="addEventListener",u="resourcetimingbufferfull",d="bstResource",l="resource",p="-start",h="-end",m="fn"+p,w="fn"+h,v="bstTimer",y="pushState",g=t("loader");g.features.stn=!0,t(6);var b=NREUM.o.EV;o.on(m,function(t,n){var e=t[0];e instanceof b&&(this.bstStart=g.now())}),o.on(w,function(t,n){var e=t[0];e instanceof b&&i("bst",[e,n,this.bstStart,g.now()])}),a.on(m,function(t,n,e){this.bstStart=g.now(),this.bstType=e}),a.on(w,function(t,n){i(v,[n,this.bstStart,g.now(),this.bstType])}),s.on(m,function(){this.bstStart=g.now()}),s.on(w,function(t,n){i(v,[n,this.bstStart,g.now(),"requestAnimationFrame"])}),o.on(y+p,function(t){this.time=g.now(),this.startPath=location.pathname+location.hash}),o.on(y+h,function(t){i("bstHist",[location.pathname+location.hash,this.startPath,this.time])}),f in window.performance&&(window.performance["c"+c]?window.performance[f](u,function(t){i(d,[window.performance.getEntriesByType(l)]),window.performance["c"+c]()},!1):window.performance[f]("webkit"+u,function(t){i(d,[window.performance.getEntriesByType(l)]),window.performance["webkitC"+c]()},!1)),document[f]("scroll",r,{passive:!0}),document[f]("keypress",r,!1),document[f]("click",r,!1)}},{}],5:[function(t,n,e){function r(t){for(var n=t;n&&!n.hasOwnProperty(u);)n=Object.getPrototypeOf(n);n&&o(n)}function o(t){s.inPlace(t,[u,d],"-",i)}function i(t,n){return t[1]}var a=t("ee").get("events"),s=t(18)(a,!0),c=t("gos"),f=XMLHttpRequest,u="addEventListener",d="removeEventListener";n.exports=a,"getPrototypeOf"in Object?(r(document),r(window),r(f.prototype)):f.prototype.hasOwnProperty(u)&&(o(window),o(f.prototype)),a.on(u+"-start",function(t,n){var e=t[1],r=c(e,"nr@wrapped",function(){function t(){if("function"==typeof e.handleEvent)return e.handleEvent.apply(e,arguments)}var n={object:t,"function":e}[typeof e];return n?s(n,"fn-",null,n.name||"anonymous"):e});this.wrapped=t[1]=r}),a.on(d+"-start",function(t){t[1]=this.wrapped||t[1]})},{}],6:[function(t,n,e){var r=t("ee").get("history"),o=t(18)(r);n.exports=r,o.inPlace(window.history,["pushState","replaceState"],"-")},{}],7:[function(t,n,e){var r=t("ee").get("raf"),o=t(18)(r),i="equestAnimationFrame";n.exports=r,o.inPlace(window,["r"+i,"mozR"+i,"webkitR"+i,"msR"+i],"raf-"),r.on("raf-start",function(t){t[0]=o(t[0],"fn-")})},{}],8:[function(t,n,e){function r(t,n,e){t[0]=a(t[0],"fn-",null,e)}function o(t,n,e){this.method=e,this.timerDuration="number"==typeof t[1]?t[1]:0,t[0]=a(t[0],"fn-",this,e)}var i=t("ee").get("timer"),a=t(18)(i),s="setTimeout",c="setInterval",f="clearTimeout",u="-start",d="-";n.exports=i,a.inPlace(window,[s,"setImmediate"],s+d),a.inPlace(window,[c],c+d),a.inPlace(window,[f,"clearImmediate"],f+d),i.on(c+u,r),i.on(s+u,o)},{}],9:[function(t,n,e){function r(t,n){d.inPlace(n,["onreadystatechange"],"fn-",s)}function o(){var t=this,n=u.context(t);t.readyState>3&&!n.resolved&&(n.resolved=!0,u.emit("xhr-resolved",[],t)),d.inPlace(t,w,"fn-",s)}function i(t){v.push(t),h&&(g=-g,b.data=g)}function a(){for(var t=0;t<v.length;t++)r([],v[t]);v.length&&(v=[])}function s(t,n){return n}function c(t,n){for(var e in t)n[e]=t[e];return n}t(5);var f=t("ee"),u=f.get("xhr"),d=t(18)(u),l=NREUM.o,p=l.XHR,h=l.MO,m="readystatechange",w=["onload","onerror","onabort","onloadstart","onloadend","onprogress","ontimeout"],v=[];n.exports=u;var y=window.XMLHttpRequest=function(t){var n=new p(t);try{u.emit("new-xhr",[n],n),n.addEventListener(m,o,!1)}catch(e){try{u.emit("internal-error",[e])}catch(r){}}return n};if(c(p,y),y.prototype=p.prototype,d.inPlace(y.prototype,["open","send"],"-xhr-",s),u.on("send-xhr-start",function(t,n){r(t,n),i(n)}),u.on("open-xhr-start",r),h){var g=1,b=document.createTextNode(g);new h(a).observe(b,{characterData:!0})}else f.on("fn-end",function(t){t[0]&&t[0].type===m||a()})},{}],10:[function(t,n,e){function r(t){var n=this.params,e=this.metrics;if(!this.ended){this.ended=!0;for(var r=0;r<d;r++)t.removeEventListener(u[r],this.listener,!1);if(!n.aborted){if(e.duration=a.now()-this.startTime,4===t.readyState){n.status=t.status;var i=o(t,this.lastSize);if(i&&(e.rxSize=i),this.sameOrigin){var c=t.getResponseHeader("X-NewRelic-App-Data");c&&(n.cat=c.split(", ").pop())}}else n.status=0;e.cbTime=this.cbTime,f.emit("xhr-done",[t],t),s("xhr",[n,e,this.startTime])}}}function o(t,n){var e=t.responseType;if("json"===e&&null!==n)return n;var r="arraybuffer"===e||"blob"===e||"json"===e?t.response:t.responseText;return h(r)}function i(t,n){var e=c(n),r=t.params;r.host=e.hostname+":"+e.port,r.pathname=e.pathname,t.sameOrigin=e.sameOrigin}var a=t("loader");if(a.xhrWrappable){var s=t("handle"),c=t(11),f=t("ee"),u=["load","error","abort","timeout"],d=u.length,l=t("id"),p=t(14),h=t(13),m=window.XMLHttpRequest;a.features.xhr=!0,t(9),f.on("new-xhr",function(t){var n=this;n.totalCbs=0,n.called=0,n.cbTime=0,n.end=r,n.ended=!1,n.xhrGuids={},n.lastSize=null,p&&(p>34||p<10)||window.opera||t.addEventListener("progress",function(t){n.lastSize=t.loaded},!1)}),f.on("open-xhr-start",function(t){this.params={method:t[0]},i(this,t[1]),this.metrics={}}),f.on("open-xhr-end",function(t,n){"loader_config"in NREUM&&"xpid"in NREUM.loader_config&&this.sameOrigin&&n.setRequestHeader("X-NewRelic-ID",NREUM.loader_config.xpid)}),f.on("send-xhr-start",function(t,n){var e=this.metrics,r=t[0],o=this;if(e&&r){var i=h(r);i&&(e.txSize=i)}this.startTime=a.now(),this.listener=function(t){try{"abort"===t.type&&(o.params.aborted=!0),("load"!==t.type||o.called===o.totalCbs&&(o.onloadCalled||"function"!=typeof n.onload))&&o.end(n)}catch(e){try{f.emit("internal-error",[e])}catch(r){}}};for(var s=0;s<d;s++)n.addEventListener(u[s],this.listener,!1)}),f.on("xhr-cb-time",function(t,n,e){this.cbTime+=t,n?this.onloadCalled=!0:this.called+=1,this.called!==this.totalCbs||!this.onloadCalled&&"function"==typeof e.onload||this.end(e)}),f.on("xhr-load-added",function(t,n){var e=""+l(t)+!!n;this.xhrGuids&&!this.xhrGuids[e]&&(this.xhrGuids[e]=!0,this.totalCbs+=1)}),f.on("xhr-load-removed",function(t,n){var e=""+l(t)+!!n;this.xhrGuids&&this.xhrGuids[e]&&(delete this.xhrGuids[e],this.totalCbs-=1)}),f.on("addEventListener-end",function(t,n){n instanceof m&&"load"===t[0]&&f.emit("xhr-load-added",[t[1],t[2]],n)}),f.on("removeEventListener-end",function(t,n){n instanceof m&&"load"===t[0]&&f.emit("xhr-load-removed",[t[1],t[2]],n)}),f.on("fn-start",function(t,n,e){n instanceof m&&("onload"===e&&(this.onload=!0),("load"===(t[0]&&t[0].type)||this.onload)&&(this.xhrCbStart=a.now()))}),f.on("fn-end",function(t,n){this.xhrCbStart&&f.emit("xhr-cb-time",[a.now()-this.xhrCbStart,this.onload,n],n)})}},{}],11:[function(t,n,e){n.exports=function(t){var n=document.createElement("a"),e=window.location,r={};n.href=t,r.port=n.port;var o=n.href.split("://");!r.port&&o[1]&&(r.port=o[1].split("/")[0].split("@").pop().split(":")[1]),r.port&&"0"!==r.port||(r.port="https"===o[0]?"443":"80"),r.hostname=n.hostname||e.hostname,r.pathname=n.pathname,r.protocol=o[0],"/"!==r.pathname.charAt(0)&&(r.pathname="/"+r.pathname);var i=!n.protocol||":"===n.protocol||n.protocol===e.protocol,a=n.hostname===document.domain&&n.port===e.port;return r.sameOrigin=i&&(!n.hostname||a),r}},{}],12:[function(t,n,e){function r(){}function o(t,n,e){return function(){return i(t,[f.now()].concat(s(arguments)),n?null:this,e),n?void 0:this}}var i=t("handle"),a=t(15),s=t(16),c=t("ee").get("tracer"),f=t("loader"),u=NREUM;"undefined"==typeof window.newrelic&&(newrelic=u);var d=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],l="api-",p=l+"ixn-";a(d,function(t,n){u[n]=o(l+n,!0,"api")}),u.addPageAction=o(l+"addPageAction",!0),u.setCurrentRouteName=o(l+"routeName",!0),n.exports=newrelic,u.interaction=function(){return(new r).get()};var h=r.prototype={createTracer:function(t,n){var e={},r=this,o="function"==typeof n;return i(p+"tracer",[f.now(),t,e],r),function(){if(c.emit((o?"":"no-")+"fn-start",[f.now(),r,o],e),o)try{return n.apply(this,arguments)}finally{c.emit("fn-end",[f.now()],e)}}}};a("setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(t,n){h[n]=o(p+n)}),newrelic.noticeError=function(t){"string"==typeof t&&(t=new Error(t)),i("err",[t,f.now()])}},{}],13:[function(t,n,e){n.exports=function(t){if("string"==typeof t&&t.length)return t.length;if("object"==typeof t){if("undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer&&t.byteLength)return t.byteLength;if("undefined"!=typeof Blob&&t instanceof Blob&&t.size)return t.size;if(!("undefined"!=typeof FormData&&t instanceof FormData))try{return JSON.stringify(t).length}catch(n){return}}}},{}],14:[function(t,n,e){var r=0,o=navigator.userAgent.match(/Firefox[\/\s](\d+\.\d+)/);o&&(r=+o[1]),n.exports=r},{}],15:[function(t,n,e){function r(t,n){var e=[],r="",i=0;for(r in t)o.call(t,r)&&(e[i]=n(r,t[r]),i+=1);return e}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],16:[function(t,n,e){function r(t,n,e){n||(n=0),"undefined"==typeof e&&(e=t?t.length:0);for(var r=-1,o=e-n||0,i=Array(o<0?0:o);++r<o;)i[r]=t[n+r];return i}n.exports=r},{}],17:[function(t,n,e){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],18:[function(t,n,e){function r(t){return!(t&&t instanceof Function&&t.apply&&!t[a])}var o=t("ee"),i=t(16),a="nr@original",s=Object.prototype.hasOwnProperty,c=!1;n.exports=function(t,n){function e(t,n,e,o){function nrWrapper(){var r,a,s,c;try{a=this,r=i(arguments),s="function"==typeof e?e(r,a):e||{}}catch(f){l([f,"",[r,a,o],s])}u(n+"start",[r,a,o],s);try{return c=t.apply(a,r)}catch(d){throw u(n+"err",[r,a,d],s),d}finally{u(n+"end",[r,a,c],s)}}return r(t)?t:(n||(n=""),nrWrapper[a]=t,d(t,nrWrapper),nrWrapper)}function f(t,n,o,i){o||(o="");var a,s,c,f="-"===o.charAt(0);for(c=0;c<n.length;c++)s=n[c],a=t[s],r(a)||(t[s]=e(a,f?s+o:o,i,s))}function u(e,r,o){if(!c||n){var i=c;c=!0;try{t.emit(e,r,o,n)}catch(a){l([a,e,r,o])}c=i}}function d(t,n){if(Object.defineProperty&&Object.keys)try{var e=Object.keys(t);return e.forEach(function(e){Object.defineProperty(n,e,{get:function(){return t[e]},set:function(n){return t[e]=n,n}})}),n}catch(r){l([r])}for(var o in t)s.call(t,o)&&(n[o]=t[o]);return n}function l(n){try{t.emit("internal-error",n)}catch(e){}}return t||(t=o),e.inPlace=f,e.flag=a,e}},{}],ee:[function(t,n,e){function r(){}function o(t){function n(t){return t&&t instanceof r?t:t?c(t,s,i):i()}function e(e,r,o,i){if(!l.aborted||i){t&&t(e,r,o);for(var a=n(o),s=h(e),c=s.length,f=0;f<c;f++)s[f].apply(a,r);var d=u[y[e]];return d&&d.push([g,e,r,a]),a}}function p(t,n){v[t]=h(t).concat(n)}function h(t){return v[t]||[]}function m(t){return d[t]=d[t]||o(e)}function w(t,n){f(t,function(t,e){n=n||"feature",y[e]=n,n in u||(u[n]=[])})}var v={},y={},g={on:p,emit:e,get:m,listeners:h,context:n,buffer:w,abort:a,aborted:!1};return g}function i(){return new r}function a(){(u.api||u.feature)&&(l.aborted=!0,u=l.backlog={})}var s="nr@context",c=t("gos"),f=t(15),u={},d={},l=n.exports=o();l.backlog=u},{}],gos:[function(t,n,e){function r(t,n,e){if(o.call(t,n))return t[n];var r=e();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(t,n,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return t[n]=r,r}var o=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(t,n,e){function r(t,n,e,r){o.buffer([t],r),o.emit(t,n,e)}var o=t("ee").get("handle");n.exports=r,r.ee=o},{}],id:[function(t,n,e){function r(t){var n=typeof t;return!t||"object"!==n&&"function"!==n?-1:t===window?0:a(t,i,function(){return o++})}var o=1,i="nr@id",a=t("gos");n.exports=r},{}],loader:[function(t,n,e){function r(){if(!x++){var t=b.info=NREUM.info,n=l.getElementsByTagName("script")[0];if(setTimeout(u.abort,3e4),!(t&&t.licenseKey&&t.applicationID&&n))return u.abort();f(y,function(n,e){t[n]||(t[n]=e)}),c("mark",["onload",a()+b.offset],null,"api");var e=l.createElement("script");e.src="https://"+t.agent,n.parentNode.insertBefore(e,n)}}function o(){"complete"===l.readyState&&i()}function i(){c("mark",["domContent",a()+b.offset],null,"api")}function a(){return E.exists&&performance.now?Math.round(performance.now()):(s=Math.max((new Date).getTime(),s))-b.offset}var s=(new Date).getTime(),c=t("handle"),f=t(15),u=t("ee"),d=window,l=d.document,p="addEventListener",h="attachEvent",m=d.XMLHttpRequest,w=m&&m.prototype;NREUM.o={ST:setTimeout,CT:clearTimeout,XHR:m,REQ:d.Request,EV:d.Event,PR:d.Promise,MO:d.MutationObserver};var v=""+location,y={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1026.min.js"},g=m&&w&&w[p]&&!/CriOS/.test(navigator.userAgent),b=n.exports={offset:s,now:a,origin:v,features:{},xhrWrappable:g};t(12),l[p]?(l[p]("DOMContentLoaded",i,!1),d[p]("load",r,!1)):(l[h]("onreadystatechange",o),d[h]("onload",r)),c("mark",["firstbyte",s],null,"api");var x=0,E=t(17)},{}]},{},["loader",2,10,4,3]);</script>
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<meta content="en" name="Content-Language">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-57x57-54e70e6f82df9577817a780b29ecda35.png" sizes="57x57">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-60x60-8f5ad55401b40beee4e5b2016bb63488.png" sizes="60x60">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-72x72-bb004576b18d715f0bd5530797d34dc9.png" sizes="72x72">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-76x76-5942e60fbe5e079c53e84c562eca25d0.png" sizes="76x76">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-114x114-c6e42dbd40e626f342e59d3243f91c6e.png" sizes="114x114">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-120x120-fd7f057745561ad60ae84af57089e95a.png" sizes="120x120">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-144x144-797b56b87c3d9081a7ae917d92c8c04c.png" sizes="144x144">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://leanpub.com/assets/favicons/apple-touch-icon-152x152-8f1e2e8883a11b5ff20d9f0c05806178.png" sizes="152x152">
<link rel="icon" type="image/png" href="https://leanpub.com/assets/favicons/favicon-16x16-ded2bd99e406de33cbbc8ce1cdee589d.png" sizes="16x16">
<link rel="icon" type="image/png" href="https://leanpub.com/assets/favicons/favicon-32x32-092b00041f106e3ea1fcd813cc580be2.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://leanpub.com/assets/favicons/favicon-96x96-dbe8af7287bfae633eecb6431987707b.png" sizes="96x96">
<link rel="icon" type="image/png" href="https://leanpub.com/assets/favicons/favicon-128x128-ad240b25d25c4c469a99d2b2b0660b01.png" sizes="128x128">
<link rel="icon" type="image/png" href="https://leanpub.com/assets/favicons/favicon-196x196-7d3a43fbe85f899fa7648b0844251883.png" sizes="196x196">
<meta content="Leanpub" name="application-name">
<meta content="#ffffff" name="msapplication-TileColor">
<meta content="favicons/mstile-144x144.png" name="msapplication-TileImage">
<meta content="favicons/mstile-150x150.png" name="msapplication-square150x150logo">
<meta content="favicons/mstile-310x150.png" name="msapplication-wide310x150logo">
<meta content="favicons/mstile-310x310.png" name="msapplication-square310x310logo">
<meta content="favicons/mstile-70x70.png" name="msapplication-square70x70logo">

<title>Read JavaScript Allongé, the "Six" Edition | Leanpub</title>
<link href="https://fonts.googleapis.com/" rel="dns-prefetch">
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/7d43d23755.js"></script><link rel="stylesheet" href="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/7d43d23755.css" media="all">
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/webfont.js"></script>
<link rel="stylesheet" href="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/css" media="all"><script>
  WebFont.load({
    google: {
      families: [
        'Noto Sans:400,700,400i,700i',
        'Noto Serif:400,700,400i,700i',
      ]
    }
  });
</script>

<link rel="stylesheet" media="all" href="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/application-3228bff34e42f459d95c4b31ae904ffd.css">

<script>
  var _rollbarConfig = {
      accessToken: "3d279f41d3804636adbbba833c2c0d2d",
      captureUncaught: true,
      payload: {
        environment: "production"
      }
  };
  !function(r){function o(e){if(t[e])return t[e].exports;var n=t[e]={exports:{},id:e,loaded:!1};return r[e].call(n.exports,n,n.exports,o),n.loaded=!0,n.exports}var t={};return o.m=r,o.c=t,o.p="",o(0)}([function(r,o,t){"use strict";var e=t(1).Rollbar,n=t(2);_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||"https://d37gvrvc0wt4s1.cloudfront.net/js/v1.8/rollbar.min.js";var a=e.init(window,_rollbarConfig),i=n(a,_rollbarConfig);a.loadFull(window,document,!_rollbarConfig.async,_rollbarConfig,i)},function(r,o){"use strict";function t(r){return function(){try{return r.apply(this,arguments)}catch(o){try{console.error("[Rollbar]: Internal error",o)}catch(t){}}}}function e(r,o,t){window._rollbarWrappedError&&(t[4]||(t[4]=window._rollbarWrappedError),t[5]||(t[5]=window._rollbarWrappedError._rollbarContext),window._rollbarWrappedError=null),r.uncaughtError.apply(r,t),o&&o.apply(window,t)}function n(r){var o=function(){var o=Array.prototype.slice.call(arguments,0);e(r,r._rollbarOldOnError,o)};return o.belongsToShim=!0,o}function a(r){this.shimId=++s,this.notifier=null,this.parentShim=r,this._rollbarOldOnError=null}function i(r){var o=a;return t(function(){if(this.notifier)return this.notifier[r].apply(this.notifier,arguments);var t=this,e="scope"===r;e&&(t=new o(this));var n=Array.prototype.slice.call(arguments,0),a={shim:t,method:r,args:n,ts:new Date};return window._rollbarShimQueue.push(a),e?t:void 0})}function l(r,o){if(o.hasOwnProperty&&o.hasOwnProperty("addEventListener")){var t=o.addEventListener;o.addEventListener=function(o,e,n){t.call(this,o,r.wrap(e),n)};var e=o.removeEventListener;o.removeEventListener=function(r,o,t){e.call(this,r,o&&o._wrapped?o._wrapped:o,t)}}}var s=0;a.init=function(r,o){var e=o.globalAlias||"Rollbar";if("object"==typeof r[e])return r[e];r._rollbarShimQueue=[],r._rollbarWrappedError=null,o=o||{};var i=new a;return t(function(){if(i.configure(o),o.captureUncaught){i._rollbarOldOnError=r.onerror,r.onerror=n(i);var t,a,s="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(t=0;t<s.length;++t)a=s[t],r[a]&&r[a].prototype&&l(i,r[a].prototype)}return r[e]=i,i})()},a.prototype.loadFull=function(r,o,e,n,a){var i=function(){var o;if(void 0===r._rollbarPayloadQueue){var t,e,n,i;for(o=new Error("rollbar.js did not load");t=r._rollbarShimQueue.shift();)for(n=t.args,i=0;i<n.length;++i)if(e=n[i],"function"==typeof e){e(o);break}}"function"==typeof a&&a(o)},l=!1,s=o.createElement("script"),u=o.getElementsByTagName("script")[0],p=u.parentNode;s.crossOrigin="",s.src=n.rollbarJsUrl,s.async=!e,s.onload=s.onreadystatechange=t(function(){if(!(l||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)){s.onload=s.onreadystatechange=null;try{p.removeChild(s)}catch(r){}l=!0,i()}}),p.insertBefore(s,u)},a.prototype.wrap=function(r,o){try{var t;if(t="function"==typeof o?o:function(){return o||{}},"function"!=typeof r)return r;if(r._isWrap)return r;if(!r._wrapped){r._wrapped=function(){try{return r.apply(this,arguments)}catch(o){throw o._rollbarContext=t()||{},o._rollbarContext._wrappedSource=r.toString(),window._rollbarWrappedError=o,o}},r._wrapped._isWrap=!0;for(var e in r)r.hasOwnProperty(e)&&(r._wrapped[e]=r[e])}return r._wrapped}catch(n){return r}};for(var u="log,debug,info,warn,warning,error,critical,global,configure,scope,uncaughtError".split(","),p=0;p<u.length;++p)a.prototype[u[p]]=i(u[p]);r.exports={Rollbar:a,_rollbarWindowOnError:e}},function(r,o){"use strict";r.exports=function(r,o){return function(t){if(!t&&!window._rollbarInitialized){var e=window.RollbarNotifier,n=o||{},a=n.globalAlias||"Rollbar",i=window.Rollbar.init(n,r);i._processShimQueue(window._rollbarShimQueue||[]),window[a]=i,window._rollbarInitialized=!0,e.processPayloads()}}}}]);
</script>
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/modernizr-475cd16be463e65bd308a1d6bc41b7a9.js"></script>
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/jsapi"></script>
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/chartkick-4ed46cbe2a0c6f2912796965f156256d.js"></script>
<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/MathJax.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-911230-9', 'auto');  // Replace with your property ID.
  
  // Visitor type parameters (only settable from non cached)
  
  
  
  
  ga('send', 'pageview');
</script>

<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style></style><meta name="csrf-param" content="authenticity_token"><meta name="csrf-token" content="at+SanLube5HDjWtrrQfm6wK6I1UxOD1AOFQyV2JQxGfiQeDqqvmV8XAZ0useSWaorYk4i/saeFMQrnqZmMIWQ=="><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Blank; src: url('about:blank')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body id="reads-show"><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

<div class="flash" id="js-flash-prototype">
<div class="flash__progress-bar"></div>
<div class="container--large">
<div class="flash__message"></div>
<div class="flash__close-icon">

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="25px" id="Layer_1" style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="25px" xml:space="preserve"><path d="M437.5,386.6L306.9,256l130.6-130.6c14.1-14.1,14.1-36.8,0-50.9c-14.1-14.1-36.8-14.1-50.9,0L256,205.1L125.4,74.5  c-14.1-14.1-36.8-14.1-50.9,0c-14.1,14.1-14.1,36.8,0,50.9L205.1,256L74.5,386.6c-14.1,14.1-14.1,36.8,0,50.9  c14.1,14.1,36.8,14.1,50.9,0L256,306.9l130.6,130.6c14.1,14.1,36.8,14.1,50.9,0C451.5,423.4,451.5,400.6,437.5,386.6z"></path></svg>

</div>
</div>
</div>


<header class="header">
<div class="container--large">
<div class="header__section--left">
<a class="header__mobile-menu-icon">
<i class="fa fa-bars" aria-hidden="true"></i>
</a>
<div class="mobile-menu">
<header class="mobile-menu__header">
<div class="btn--close">

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" height="25px" id="Layer_1" style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="25px" xml:space="preserve"><path d="M437.5,386.6L306.9,256l130.6-130.6c14.1-14.1,14.1-36.8,0-50.9c-14.1-14.1-36.8-14.1-50.9,0L256,205.1L125.4,74.5  c-14.1-14.1-36.8-14.1-50.9,0c-14.1,14.1-14.1,36.8,0,50.9L205.1,256L74.5,386.6c-14.1,14.1-14.1,36.8,0,50.9  c14.1,14.1,36.8,14.1,50.9,0L256,306.9l130.6,130.6c14.1,14.1,36.8,14.1,50.9,0C451.5,423.4,451.5,400.6,437.5,386.6z"></path></svg>

</div>
<div class="mobile-menu__header__logo">
<a href="https://leanpub.com/"><!-- Generator: Adobe Illustrator 19.2.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="128px" height="87.407px" viewBox="0 0 128 87.407" style="enable-background:new 0 0 128 87.407;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#231F20;}
	.st1{fill:#FFFFFF;}
</style>
<path class="st0" d="M118.343,7.884C114.047,5.467,102.725,0,88.202,0C75.161,0,67.739,4.009,64,6.583  C60.261,4.009,52.839,0,39.798,0C25.275,0,13.953,5.467,9.657,7.884L0,87.407h0.288c5.46,0,10.834-1.259,15.772-3.589  c5.504-2.597,14.182-5.652,24.545-5.652c12.606,0,19.781,5.627,23.395,9.241c3.614-3.614,10.789-9.241,23.395-9.241  c10.363,0,19.041,3.055,24.545,5.652c4.938,2.33,10.313,3.589,15.772,3.589H128L118.343,7.884z"></path>
<path class="st1" d="M111.652,74.536c-5.112-2.103-10.271-3.541-15.332-4.274c-2.974-0.431-5.977-0.649-8.925-0.649  c-8.383,0-15.957,2.09-22.512,6.213L64,76.374l-0.878-0.546c-6.56-4.125-14.134-6.215-22.517-6.215  c-2.948,0-5.951,0.219-8.925,0.649c-5.062,0.733-10.221,2.171-15.333,4.274L9.85,77.209l7.752-63.796l0.574-0.254  c6.535-2.888,14.92-4.612,22.429-4.612c9.302,0,17.167,2.962,23.395,8.808c6.228-5.846,14.092-8.808,23.395-8.808  c7.51,0,15.895,1.724,22.43,4.612l0.574,0.254l7.752,63.796L111.652,74.536z"></path>
<path class="st0" d="M88.824,66.095c-0.797-0.031-1.591-0.047-2.382-0.047c-8.366,0-15.95,2.028-22.542,6.025  c-6.595-3.998-14.177-6.025-22.542-6.025c-2.942,0-5.938,0.214-8.904,0.636c-5.05,0.718-10.191,2.124-15.278,4.179l-2.902,1.172  l6.885-55.627c5.955-2.479,13.455-3.95,20.199-3.95c8.757,0,16.088,2.838,21.789,8.436l0.752,0.739l0.752-0.739  c5.493-5.393,12.502-8.217,20.838-8.417L88.824,66.095z"></path>
</svg>

</a></div>
<div class="mobile-menu__cart">
<a class="shopping-cart__icon" href="https://leanpub.com/shopping_cart?stage=review" title="Shopping Cart">
<div class="icon-link--cart empty"><span class="shopping-cart__count">0</span></div>
</a>
</div>
</header>
<div class="mobile-menu__search">
<div class="search" role="search">
<form action="https://leanpub.com/bookstore" class="search__form" method="get">
<label class="search__label" for="search-query">Search Query</label>
<input class="search__input" id="search-query" name="search" placeholder="Search Leanpub" type="text">
<button class="search__button" type="submit">
<i class="fa fa-search" aria-hidden="true"></i>
</button>
</form>
</div>

</div>
<nav class="mobile-menu__nav">
<ul><li><a href="https://leanpub.com/">Home</a></li><li><a href="https://leanpub.com/bookstore">Store</a></li><li><a href="https://leanpub.com/user_dashboard/library">Read</a></li><li><a href="https://leanpub.com/author_dashboard/books">Write</a></li><li><a href="https://leanpub.com/help">Support</a></li></ul>
</nav>
<div class="mobile-menu__session-links hidden" style="display: flex;">
<a href="https://leanpub.com/sign_in">Sign In</a>
<a href="https://leanpub.com/sign_up">Sign Up</a>
</div>
</div>

</div>
<div class="header__section--center">
<div class="header__logo--black">
<a href="https://leanpub.com/"><!-- Generator: Adobe Illustrator 19.2.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="128px" height="87.407px" viewBox="0 0 128 87.407" style="enable-background:new 0 0 128 87.407;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#231F20;}
	.st1{fill:#FFFFFF;}
</style>
<path class="st0" d="M118.343,7.884C114.047,5.467,102.725,0,88.202,0C75.161,0,67.739,4.009,64,6.583  C60.261,4.009,52.839,0,39.798,0C25.275,0,13.953,5.467,9.657,7.884L0,87.407h0.288c5.46,0,10.834-1.259,15.772-3.589  c5.504-2.597,14.182-5.652,24.545-5.652c12.606,0,19.781,5.627,23.395,9.241c3.614-3.614,10.789-9.241,23.395-9.241  c10.363,0,19.041,3.055,24.545,5.652c4.938,2.33,10.313,3.589,15.772,3.589H128L118.343,7.884z"></path>
<path class="st1" d="M111.652,74.536c-5.112-2.103-10.271-3.541-15.332-4.274c-2.974-0.431-5.977-0.649-8.925-0.649  c-8.383,0-15.957,2.09-22.512,6.213L64,76.374l-0.878-0.546c-6.56-4.125-14.134-6.215-22.517-6.215  c-2.948,0-5.951,0.219-8.925,0.649c-5.062,0.733-10.221,2.171-15.333,4.274L9.85,77.209l7.752-63.796l0.574-0.254  c6.535-2.888,14.92-4.612,22.429-4.612c9.302,0,17.167,2.962,23.395,8.808c6.228-5.846,14.092-8.808,23.395-8.808  c7.51,0,15.895,1.724,22.43,4.612l0.574,0.254l7.752,63.796L111.652,74.536z"></path>
<path class="st0" d="M88.824,66.095c-0.797-0.031-1.591-0.047-2.382-0.047c-8.366,0-15.95,2.028-22.542,6.025  c-6.595-3.998-14.177-6.025-22.542-6.025c-2.942,0-5.938,0.214-8.904,0.636c-5.05,0.718-10.191,2.124-15.278,4.179l-2.902,1.172  l6.885-55.627c5.955-2.479,13.455-3.95,20.199-3.95c8.757,0,16.088,2.838,21.789,8.436l0.752,0.739l0.752-0.739  c5.493-5.393,12.502-8.217,20.838-8.417L88.824,66.095z"></path>
</svg>

</a></div>
<nav class="header__nav">
<ul class="header__nav-list">
<li class="header__nav-item">
<a href="https://leanpub.com/bookstore">Store</a>
</li>
<li class="header__nav-item">
<a href="https://leanpub.com/user_dashboard/library">Read</a>
</li>
<li class="header__nav-item">
<a href="https://leanpub.com/author_dashboard/books">Write</a>
</li>
<li class="header__nav-item">
<a href="https://leanpub.com/help">Support</a>
</li>
<li class="header__nav-item">
<a href="https://leanpub.com/blog">Blog</a>
</li>
</ul>
</nav>
</div>
<div class="header__section--right">
<div class="header__search">
<div class="search" role="search">
<form action="https://leanpub.com/bookstore" class="search__form" method="get">
<label class="search__label" for="search-query">Search Query</label>
<input class="search__input" id="search-query" name="search" placeholder="Search Leanpub" type="text">
<button class="search__button" type="submit">
<i class="fa fa-search" aria-hidden="true"></i>
</button>
</form>
</div>

</div>
<div class="header__cart">
<a class="shopping-cart__icon" href="https://leanpub.com/shopping_cart?stage=review" title="Shopping Cart">
<div class="icon-link--cart empty"><span class="shopping-cart__count">0</span></div>
</a>
</div>
<div class="header__session-buttons">
<a href="https://leanpub.com/sign_in"><button class="btn--plain--shark" type="button">Sign In</button>
</a><a href="https://leanpub.com/sign_up"><button class="btn--solid--shark" type="button">Sign Up</button>
</a></div>
<div class="header__account-container">
<div class="account-menu" id="js-account-dropdown">
<ul class="account-menu__list-wrapper">
<li class="account-menu__nav--user">
<div class="user" style="display: none;">
<h5>Account</h5>
<a class="user" href="https://leanpub.com/user_dashboard/library" style="display: none;">Library</a>
<hr>
</div>
<a class="guest" href="https://leanpub.com/sign_in" style="display: block;">Sign In</a>
<a class="guest" href="https://leanpub.com/sign_up" style="display: block;">Sign Up</a>
<a class="user" href="https://leanpub.com/user_dashboard/settings" style="display: none;">Settings</a>
<a class="user" href="https://leanpub.com/user_dashboard/purchases" style="display: none;">Purchases</a>
<a class="user" href="https://leanpub.com/user_dashboard/gifts" style="display: none;">Gifts</a>
<a class="user" href="https://leanpub.com/user_dashboard/refunds" style="display: none;">Refunds</a>
<a class="author" href="https://leanpub.com/user_dashboard/invitations" style="display: none;">Invitations</a>
<a class="user" href="https://leanpub.com/user_dashboard/kindle" style="display: none;">Kindle</a>
<a class="user" href="https://leanpub.com/user_dashboard/email" style="display: none;">Email</a>
</li>
<li class="author-and-publisher">
<div class="account-menu__nav--author" style="display: none;">
<h5>Author</h5>
<a class="reader" href="https://leanpub.com/books/new" style="display: none;">Create a book</a>
<a class="author" href="https://leanpub.com/author_dashboard/books" style="display: none;">Books</a>
<a class="author" href="https://leanpub.com/author_dashboard/bundles" style="display: none;">Bundles</a>
<a class="author course" href="https://leanpub.com/author_dashboard/courses" style="display: none;">Courses</a>
<a class="author" href="https://leanpub.com/author_dashboard/profile" style="display: none;">Profile</a>
<a class="author" href="https://leanpub.com/author_dashboard/royalties" style="display: none;">Royalties</a>
<a class="author" href="https://leanpub.com/author_dashboard/settings" style="display: none;">API</a>
</div>
<div class="account-menu__nav--publisher" style="display: none;">
<h5>Publisher</h5>
<a class="publisher" href="https://leanpub.com/publisher_dashboard/publishers" style="display: none;">Dashboard</a>
</div>
</li>
<li class="author account-menu__nav--books" style="display: none;">
<h5>Edit Books</h5>
</li>
</ul>
<div class="account-menu__actions">
<div class="account-menu__action">
<a href="https://leanpub.com/help">Help</a>
</div>
<div class="account-menu__action">
<span class="account-menu__email"></span>
<a href="https://leanpub.com/sign_out" style="display: none;">Sign Out</a>
</div>
</div>
</div>

<div class="header__account-button"><img class="header__account-avatar" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/missing_avatar.jpg" alt="Avatar">

</div>
</div>
</div>
</div>
</header>


<div class="main">


<div class="container--large" id="read-online" lang="en">
<header>
<h1>JavaScript Allongé, the "Six" Edition</h1>
<div class="read-upsell">
<a href="https://leanpub.com/javascriptallongesix"><img alt="JavaScript Allongé, the &quot;Six&quot; Edition" src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/small"></a>
<div>
<div class="book-title">JavaScript Allongé, the "Six" Edition</div>
<a class="btn--solid" href="https://leanpub.com/javascriptallongesix">Buy on Leanpub</a>
</div>
</div>
</header>
<section class="read">
<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-a-pull-of-the-lever-prefaces">A Pull of the Lever: Prefaces</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong">About JavaScript Allongé</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-what-javascript-allong-is-and-isnt">What JavaScript Allongé is. And isn’t.</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-foreword-to-the-six-edition">Foreword to the “Six” edition</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-forewords-to-the-first-edition">Forewords to the First Edition</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-prelude-values-and-expressions-over-coffee">Prelude: Values and Expressions over Coffee</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-values-are-expressions">values are expressions</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-values-and-identity">values and identity</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-a-rich-aroma-basic-numbers">A Rich Aroma: Basic Numbers</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#functions">The first sip: Basic Functions</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-as-little-as-possible-about-functions-but-no-less">As Little As Possible About Functions, But No Less</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#fargs">Ah. I’d Like to Have an Argument, Please.</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#closures">Closures and Scope</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#const">That Constant Coffee Craving</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#named-function-expressions">Naming Functions</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#combinators">Combinators and Function Decorators</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#buildingblocks">Building Blocks</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#magic-names">Magic Names</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-summary">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-recipes-with-basic-functions">Recipes with Basic Functions</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#simple-partial">Partial Application</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-unary">Unary</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#tap">Tap</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#maybe">Maybe</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-once">Once</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-left-variadic-functions">Left-Variadic Functions</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-compose-and-pipeline">Compose and Pipeline</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-picking-the-bean-choice-and-truthiness">Picking the Bean: Choice and Truthiness</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#composing-data">Composing and Decomposing Data</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#arraysanddestructuring">Arrays and Destructuring Arguments</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#linear-recursion">Self-Similarity</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#tail">Tail Calls (and Default Arguments)</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#garbage">Garbage, Garbage Everywhere</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#pojos">Plain Old JavaScript Objects</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#mutation">Mutation</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#reassignment">Reassignment</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#cow">Copy on Write</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#tortoises">Tortoises, Hares, and Teleporting Turtles</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#functional-iterators">Functional Iterators</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-making-data-out-of-functions">Making Data Out Of Functions</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-recipes-with-data">Recipes with Data</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#mapWith">mapWith</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#flip">Flip</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-objectassign">Object.assign</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#y">Why?</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-a-warm-cup-basic-strings-and-quasi-literals">A Warm Cup: Basic Strings and Quasi-Literals</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#mutable">Stir the Allongé: Objects and State</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#encapsulation">Encapsulating State with Closures</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#composition">Composition and Extension</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#this">This and That</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#context">What Context Applies When We Call a Function?</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#method-decorators">Method Decorators</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-summary-4">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-recipes-with-objects-mutations-and-state">Recipes with Objects, Mutations, and State</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#memoize">Memoize</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#getWith">getWith</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#pluck">pluckWith</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#deepMapWith">Deep Mapping</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-the-coffee-factory-object-oriented-programming">The Coffee Factory: “Object-Oriented Programming”</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#collections">Served by the Pot: Collections</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#iterables">Iteration and Iterables</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#generating-iterables">Generating Iterables</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-lazy-and-eager-collections">Lazy and Eager Collections</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#drunken">Interlude: The Carpenter Interviews for a Job</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#interactive-generators">Interactive Generators</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-basic-operations-on-iterables">Basic Operations on Iterables</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#symbols">A Coffeehouse: Symbols</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#metaobjects">Life on the Plantation: Metaobjects</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-why-metaobjects">Why Metaobjects?</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#mixins">Mixins, Forwarding, and Delegation</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#later-binding">Later Binding</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#prototypes">Delegation via Prototypes</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-shared-prototypes">Shared Prototypes</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-decaffeinated-impostors">Decaffeinated: Impostors</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#classes">Finish the Cup: Constructors and Classes</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#new">Constructors and <code>new</code></a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-why-classes-in-javascript">Why Classes in JavaScript?</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-classes-with-class">Classes with <code>class</code></a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#object-methods">Object Methods</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-why-not-classes">Why Not Classes?</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-summary-8">Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-recipes-with-constructors-and-classes">Recipes with Constructors and Classes</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#bound">Bound</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#send">Send</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#invoke">Invoke</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#fluent">Fluent</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#symmetry">Colourful Mugs: Symmetry, Colour, and Charm</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#class-mixins">Con Panna: Composing Class Behaviour</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#classes-and-mixins">Extending Classes with Mixins</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#functional-mixins">Functional Mixins</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#mi">Emulating Multiple Inheritance</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-preventing-property-conflicts">Preventing Property Conflicts</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-reducing-coupling">Reducing Coupling</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#redecorating">More Decorators</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#stateful-method-decorators">Stateful Method Decorators</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#es-later-class-decorators">Class Decorators beyond ES6/ECMAScript 2015</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-method-decorators-beyond-es6ecmascript-2015">Method Decorators beyond ES6/ECMAScript 2015</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#traits">Lightweight Traits</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-more-decorator-recipes">More Decorator Recipes</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#after">After Method Advice</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#before">Before Method Advice</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#provided">Provided and Unless</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#method-advice">Method Advice</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-closing-time-at-the-coffeeshop-final-remarks">Closing Time at the Coffeeshop: Final Remarks</a>
  </li>
  <li>
    <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-the-golden-crema-appendices-and-afterwords">The Golden Crema: Appendices and Afterwords</a>
    <ul>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#online">How to run the examples</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-thanks">Thanks!</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-reading-javascript-allong-on-kindle">Reading JavaScript Allongé on Kindle</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-copyright-notice">Copyright Notice</a>
      </li>
      <li>
        <a href="https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-the-author">About The Author</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main">
<h2 id="leanpub-auto-a-pull-of-the-lever-prefaces">A Pull of the Lever: Prefaces</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/caffemolinari.jpg" alt="Caffe Molinari">
  <figcaption>Caffe Molinari</figcaption>
</figure>


<blockquote>
  <p>“Café Allongé, also called Espresso Lungo, is a drink midway between an Espresso and Americano in strength. There are two different ways to make it. The first, and the one I prefer, is to add a small amount of hot water to a double or quadruple Espresso Ristretto. Like adding a splash of water to whiskey, the small dilution releases more of the complex flavours in the mouth.</p>

  <p>“The second way is to pull an extra long double shot of Espresso. This achieves approximately the same ratio of oils to water as the dilution method, but also releases a different mix of flavours due to the longer extraction. Some complain that the long pull is more bitter and detracts from the best character of the coffee, others feel it releases even more complexity.</p>

  <p>“The important thing is that neither method of preparation should use so much water as to result in a sickly, pale ghost of Espresso. Moderation in all things.” </p>
</blockquote>

<h3 id="leanpub-auto-about-javascript-allong">About JavaScript Allongé</h3>

<p>JavaScript Allongé is a first and foremost, a book about <em>programming with functions</em>. It’s written in JavaScript, because JavaScript hits the perfect sweet spot of being both widely used, and of having proper first-class functions with lexical scope. If those terms seem unfamiliar, don’t worry: JavaScript Allongé takes great delight in explaining what they mean and why they matter.</p>

<p><em>JavaScript Allongé</em> begins at the beginning, with values and expressions, and builds from there to discuss types, identity, functions, closures, scopes, collections, iterators, and many more subjects up to working with classes and instances.</p>

<p>It also provides recipes for using functions to write software that is simpler, cleaner, and less complicated than alternative approaches that are object-centric or code-centric. JavaScript idioms like function combinators and decorators leverage JavaScript’s power to make code easier to read, modify, debug and refactor.</p>

<p><em>JavaScript Allongé</em> teaches you how to handle complex code, and it also teaches you how to simplify code without dumbing it down. As a result, <em>JavaScript Allongé</em> is a rich read releasing many of JavaScript’s subtleties, much like the Café Allongé beloved by coffee enthusiasts everywhere.</p>

<h4 id="leanpub-auto-why-the-six-edition">why the “six” edition?</h4>

<p>ECMAScript 2015 (formerly called ECMAScript 6 or “ES6”), is ushering in a very large number of improvements to the way programmers can write small, powerful components and combine them into larger, fully featured programs. Features like destructuring, block-structured variables, iterables, generators, and the class keyword are poised to make JavaScript programming more expressive.</p>

<p>Prior to ECMAScript 2015, JavaScript did not include many features that programmers have discovered are vital to writing great software. For example, JavaScript did not include block-structured variables. Over time, programmers discovered ways to roll their own versions of important features.</p>

<p>For example, block-structured languages allow us to write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">int</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And the variable <code>i</code> is scoped locally to the code within the braces. Prior to ECMAScript 2015, JavaScript did not support block-structuring, so programmers borrowed a trick from the Scheme programming language, and would write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">i</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">})(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To create the same scoping with an Immediately Invoked Function Expression, or “IIFE.”</p>

<p>Likewise, many programming languages permit functions to have a variable number of arguments, and to collect the arguments into a single variable as an array. In Ruby, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">def</code> <code class="nx">foo</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="o">*</code><code class="nx">rest</code><code class="p">)</code>
  <code class="err">#</code> <code class="p">...</code>
<code class="nx">end</code>
</pre></div>

</figure>

<p>Prior to ECMAScript 2015, JavaScript did not support collecting a variable number of arguments into a parameter, so programmers would take advantage of an awkward work-around and write things like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code>
      <code class="nx">rest</code>  <code class="o">=</code> <code class="p">[].</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">arguments</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>

  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The first edition of JavaScript Allongé explained these and many other patterns for writing flexible and composable programs in JavaScript, but the intention wasn’t to explain how to work around JavaScript’s missing features: The intention was to explain why the style of programming exemplified by the missing features is important.</p>

<p>Working around the missing features was a necessary evil.</p>

<p>But now, JavaScript is gaining many important features, in part because the governing body behind JavaScript has observed that programmers are constantly working around the same set of limitations. With ECMASCript 2015, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And <code>i</code> is scoped to the for loop. We can also write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">foo</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And presto, <code>rest</code> collects the rest of the arguments without a lot of malarky involving slicing <code>arguments</code>. Not having to work around these kinds of missing features makes JavaScript Allongé a <em>better book</em>, because it can focus on the <em>why</em> to do something and <em>when</em> to do it, instead of on the how to make it work</p>

<p>JavaScript Allongé, The “Six” Edition packs all the goodness of JavaScript Allongé into a new, updated package that is relevant for programmers working with (or planning to work with) the latest version of JavaScript.</p>

<h4 id="leanpub-auto-thats-nice-is-that-the-only-reason">that’s nice. is that the only reason?</h4>

<p>Actually, no.</p>

<p>If it were just a matter of updating the syntax, the original version of JavaScript Allongé could have simply iterated, slowly replacing old syntax with new. It would have continued to say much the same things, only with new syntax.</p>

<p><em>But there’s more to it than that</em>. The original JavaScript Allongé was not just written to teach JavaScript: It was written to describe certain ideas in programming: Working with small, independent entities that compose together to make bigger programs. Thus, the focus on things like writing decorators.</p>

<p>As noted above, JavaScript was chosen as the language for Allongé because it hit a sweet spot of having a large audience of programmers and having certain language features that happen to work well with this style of programming.</p>

<p>ECMAScript 2015 does more than simply update the language with some simpler syntax for a few things and help us avoid warts. It makes a number of interesting programming techniques easy to explain and easy to use. And these techniques dovetail nicely with Allongé’s focus on composing entities and working with functions.</p>

<p>Thus, the “six” edition introduces <a href="https://leanpub.com/javascriptallongesix/read#classes">classes</a> and <a href="https://leanpub.com/javascriptallongesix/read#mixins">mixins</a>. It introduces the notion of implementing private properties with <a href="https://leanpub.com/javascriptallongesix/read#symbols">symbols</a>. It introduces <a href="https://leanpub.com/javascriptallongesix/read#collections">iterators and generators</a>. But the common thread that runs through all these things is that since they are all simple objects and simple functions, we can use the same set of “programming with functions” techniques to build programs by composing small, flexible, and decoupled entities.</p>

<p>We just call some of those functions <a href="https://leanpub.com/javascriptallongesix/read#new">constructors</a>, others <a href="https://leanpub.com/javascriptallongesix/read#decorators">decorators</a>, others <a href="https://leanpub.com/javascriptallongesix/read#functional-mixins">functional mixins</a>, and yet others, <a href="https://leanpub.com/javascriptallongesix/read#policies">policies</a>.</p>

<p>Introducing so many new ideas did require a major rethink of the way the book was organized. And introducing these new ideas did add substantially to its bulk. But even so, in a way it is still explaining the exact same original idea that programs are built out of small, flexible functions composed together.</p>

<h3 id="leanpub-auto-what-javascript-allong-is-and-isnt">What JavaScript Allongé is. And isn’t.</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/thinking.jpg" alt="JavaScript Allongé is a book about thinking about programs">
  <figcaption>JavaScript Allongé is a book about thinking about programs</figcaption>
</figure>


<p>JavaScript Allongé is a book about programming with functions. From functions flow many ideas, from decorators to methods to delegation to mixins, and onwards in so many fruitful directions.</p>

<p>The focus in this book on the underlying ideas, what we might call the fundamentals, and how they combine to form new ideas. The intention is to improve the way we think about programs. That’s a good thing.</p>

<p>But while JavaScript Allongé attempts to be provocative, it is not <em>prescriptive</em>. There is absolutely no suggestion that any of the techniques shown here are the only way to do something, the best way, or even an acceptable way to write programs that are intended to be used, read, and maintained by others.</p>

<p>Software development is a complex field. Choices in development are often driven by social considerations. People often say that software should be written for people to read. Doesn’t that depend upon the people in question? Should code written by a small team of specialists use the same techniques and patterns as code maintained by a continuously changing cast of inexperienced interns?</p>

<p>Choices in software development are also often driven by requirements specific to the type of software being developed. For example, business software written in-house has a very different set of requirements than a library written to be publicly distributed as open-source.</p>

<p>Choices in software development must also consider the question of consistency. If a particular codebase is written with lots of helper functions that place the subject first, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>Then it can be jarring to add new helpers written that place the verb first, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">filterWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>There are reasons why the second form is more flexible, especially when used in combination with partial application, but does that outweigh the benefit of having an entire codebase do everything consistently the first way or the second way?</p>

<p>Finally, choices in software development cannot ignore the tooling that is used to create and maintain software. The use of source-code control systems with integrated diffing rewards making certain types of focused changes. The use of <a href="https://en.wikipedia.org/wiki/Lint_" title="software">linters</a> makes checking for certain types of undesirable code very cheap. Debuggers encourage the use of functions with explicit or implicit names. Continuous integration encourages the creation of software in tandem with and factored to facilitate the creation of automated test suites.</p>

<p>JavaScript Allongé does not attempt to address the question of JavaScript best practices in the wider context of software development, because JavaScript Allongé isn’t a book about practicing, it’s a book about thinking.</p>

<h4 id="leanpub-auto-how-this-book-is-organized">how this book is organized</h4>

<p><em>JavaScript Allongé</em> introduces new aspects of programming with functions in each chapter, explaining exactly how JavaScript works. Code examples within each chapter are small and emphasize exposition rather than serving as patterns for everyday use.</p>

<p>Following some of the chapters are a series of recipes designed to show the application of the chapter’s ideas in practical form. While the content of each chapter builds naturally on what was discussed in the previous chapter, the recipes may draw upon any aspect of the JavaScript programming language.</p>

<h3 id="leanpub-auto-foreword-to-the-six-edition">Foreword to the “Six” edition</h3>

<p>ECMAScript 6 (short name: ES6; official name: ECMAScript 2015) was ratified as a standard on June 17. Getting there took a while – in a way, the origins of ES6 date back to the year 2000: After ECMAScript 3 was finished, TC39 (the committee evolving JavaScript) started to work on ECMAScript 4. That version was planned to have numerous new features (interfaces, namespaces, packages, multimethods, etc.), which would have turned JavaScript into a completely new language. After internal conflict, a settlement was reached in July 2008 and a new plan was made – to abandon ECMAScript 4 and to replace it with two upgrades:</p>

<ul>
  <li>A smaller upgrade would bring a few minor enhancements to ECMAScript 3. This upgrade became ECMAScript 5.</li>
  <li>A larger upgrade would substantially improve JavaScript, but without being as radical as ECMAScript 4. This upgrade became ECMAScript 6 (some features that were initially discussed will show up later, in upcoming ECMAScript versions).</li>
</ul>

<p>ECMAScript 6 has three major groups of features:</p>

<ul>
  <li>Better syntax for features that already exist (e.g. via libraries). For example: classes and modules.</li>
  <li>New functionality in the standard library. For example:
    <ul>
      <li>New methods for strings and arrays</li>
      <li>Promises (for asynchronous programming)</li>
      <li>Maps and sets</li>
    </ul>
  </li>
  <li>Completely new features. For example: Generators, proxies and WeakMaps.</li>
</ul>

<p>With ECMAScript 6, JavaScript has become much larger as a language. <em>JavaScript Allongé, the “Six” Edition</em> is both a comprehensive tour of its features and a rich collection of techniques for making better use of them. You will learn much about functional programming and object-oriented programming. And you’ll do so via ES6 code, handed to you in small, easily digestible pieces.</p>

<p>– Axel Rauschmayer
<a href="http://www.2ality.com/">Blogger</a>, <a href="http://ecmanauten.de/">trainer</a> and author of “<a href="http://exploringjs.com/">Exploring ES6</a>”</p>

<h3 id="leanpub-auto-forewords-to-the-first-edition">Forewords to the First Edition</h3>

<h4 id="leanpub-auto-michael-fogus">michael fogus</h4>

<p>As a life-long bibliophile and long-time follower of Reg’s online work, I was excited when he started writing books. However, I’m very conservative about books – let’s just say that if there was an aftershave scented to the essence of “Used Book Store” then I would be first in line to buy. So as you might imagine I was “skeptical” about the decision to release JavaScript Allongé as an ongoing ebook, with a pay-what-you-want model. However, Reg sent me a copy of his book and I was humbled. Not only was this a great book, but it was also a great way to write and distribute books. Having written books myself, I know the pain of soliciting and receiving feedback.</p>

<p>The act of writing is an iterative process with (very often) tight revision loops. However, the process of soliciting feedback, gathering responses, sending out copies, waiting for people to actually read it (if they ever do), receiving feedback and then ultimately making sense out of how to use it takes weeks and sometimes months. On more than one occasion I’ve found myself attempting to reify feedback with content that either no longer existed or was changed beyond recognition. However, with the Leanpub model the read-feedback-change process is extremely efficient, leaving in its wake a quality book that continues to get better as others likewise read and comment into infinitude.</p>

<p>In the case of JavaScript Allongé, you’ll find the Leanpub model a shining example of effectiveness. Reg has crafted (and continues to craft) not only an interesting book from the perspective of a connoisseur, but also an entertaining exploration into some of the most interesting aspects of his art. No matter how much of an expert you think you are, JavaScript Allongé has something to teach you… about coffee. I kid.</p>

<p>As a staunch advocate of functional programming, much of what Reg has written rings true to me. While not exclusively a book about functional programming, JavaScript Allongé will provide a solid foundation for functional techniques. However, you’ll not be beaten about the head and neck with dogma. Instead, every section is motivated by relevant dialog and fortified with compelling source examples. As an author of programming books I admire what Reg has managed to accomplish and I envy the fine reader who finds JavaScript Allongé via some darkened channel in the Internet sprawl and reads it for the first time.</p>

<p>Enjoy.</p>

<p>– Fogus, <a href="http://www.fogus.me/">fogus.me</a></p>

<h4 id="leanpub-auto-matthew-knox">matthew knox</h4>

<p>A different kind of language requires a different kind of book.</p>

<p>JavaScript holds surprising depths–its scoping rules are neither strictly lexical nor strictly dynamic, and it supports procedural, object-oriented (in several flavors!), and functional programming.  Many books try to hide most of those capabilities away, giving you recipes for writing JavaScript in a way that approximates class-centric programming in other languages.  Not JavaScript Allongé.  It starts with the fundamentals of values, functions, and objects, and then guides you through JavaScript from the inside with exploratory bits of code that illustrate scoping, combinators, context, state, prototypes, and constructors.</p>

<p>Like JavaScript itself, this book gives you a gentle start before showing you its full depth, and like a Cafe Allongé, it’s over too soon.  Enjoy!</p>

<p>–Matthew Knox, <a href="http://mattknox.com/">mattknox.com</a></p>

<h2 id="leanpub-auto-prelude-values-and-expressions-over-coffee">Prelude: Values and Expressions over Coffee</h2>

<p><em>The following material is extremely basic, however like most stories, the best way to begin is to start at the very beginning.</em></p>

<p>Imagine we are visiting our favourite coffee shop. They will make for you just about any drink you desire, from a short, intense espresso ristretto through a dry cappuccino, up to those coffee-flavoured desert concoctions featuring various concentrated syrups and milks. (You tolerate the existence of sugary drinks because they provide a sufficient profit margin to the establishment to finance your hanging out there all day using their WiFi and ordering a $3 drink every few hours.)</p>

<p>You express your order at one end of their counter, the folks behind the counter perform their magic, and deliver the coffee you value at the other end. This is exactly how the JavaScript environment works for the purpose of this book. We are going to dispense with web servers, browsers and other complexities and deal with this simple model: You give the computer an <a href="https://en.wikipedia.org/wiki/Expression_" title="computer_science">expression</a>, and it returns a <a href="https://en.wikipedia.org/wiki/Value_" title="computer_science">value</a>, just as you express your wishes to a barista and receive a coffee in return.</p>

<h3 id="leanpub-auto-values-are-expressions">values are expressions</h3>

<p>All values are expressions. Say you hand the barista a café Cubano. Yup, you hand over a cup with some coffee infused through partially caramelized sugar. You say, “I want one of these.” The barista is no fool, she gives it straight back to you, and you get exactly what you want. Thus, a café Cubano is an expression (you can use it to place an order) and a value (you get it back from the barista).</p>

<p>Let’s try this with something the computer understands easily:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">42</code>
</pre></div>

</figure>

<p>Is this an expression? A value? Neither? Or both?</p>

<p>The answer is, this is both an expression <em>and</em> a value.<sup id="fnref-representation"><a href="https://leanpub.com/javascriptallongesix/read#fn-representation" rel="footnote">1</a></sup> The way you can tell that it’s both is very easy: When you type it into JavaScript, you get the same thing back, just like our café Cubano:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">42</code>
  <code class="c1">//=&gt; 42</code>
</pre></div>

</figure>

<p>All values are expressions. That’s easy! Are there any other kinds of expressions? Sure! let’s go back to the coffee shop. Instead of handing over the finished coffee, we can hand over the ingredients. Let’s hand over some ground coffee plus some boiling water.</p>

<aside>
  <p>Astute readers will realize we’re omitting something. Congratulations! Take a sip of espresso. We’ll get to that in a moment.</p>

</aside>

<p>Now the barista gives us back an espresso. And if we hand over the espresso, we get the espresso right back. So, boiling water plus ground coffee is an expression, but it isn’t a value.<sup id="fnref-homoiconicity"><a href="https://leanpub.com/javascriptallongesix/read#fn-homoiconicity" rel="footnote">2</a></sup> Boiling water is a value. Ground coffee is a value. Espresso is a value. Boiling water plus ground coffee is an expression.</p>

<p>Let’s try this as well with something else the computer understands easily:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s2">"JavaScript"</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="s2">"Allonge"</code>
  <code class="c1">//=&gt; "JavaScript Allonge"</code>
</pre></div>

</figure>

<p>Now we see that “strings” are values, and you can make an expression out of strings and an operator <code>+</code>. Since strings are values, they are also expressions by themselves. But strings with operators are not values, they are expressions. Now we know what was missing with our “coffee grounds plus hot water” example. The coffee grounds were a value, the boiling hot water was a value, and the “plus” operator between them made the whole thing an expression that was not a value.</p>

<h3 id="leanpub-auto-values-and-identity">values and identity</h3>

<p>In JavaScript, we test whether two values are identical with the <code>===</code> operator, and whether they are not identical with the <code>!==</code> operator:</p>

<figure class="code">
<div class="highlight"><pre><code></code>	<code class="mi">2</code> <code class="o">===</code> <code class="mi">2</code>
		<code class="c1">//=&gt; true</code>
		
	<code class="s1">'hello'</code> <code class="o">!==</code> <code class="s1">'goodbye'</code>
		<code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>How does <code>===</code> work, exactly? Imagine that you’re shown a cup of coffee. And then you’re shown another cup of coffee. Are the two cups “identical?” In JavaScript, there are four possibilities:</p>

<p>First, sometimes, the cups are of different kinds. One is a demitasse, the other a mug. This corresponds to comparing two things in JavaScript that have different <em>types</em>. For example, the string <code>"2"</code> is not the same thing as the number <code>2</code>. Strings and numbers are different types, so strings and numbers are never identical:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">2</code> <code class="o">===</code> <code class="s1">'2'</code>
  <code class="c1">//=&gt; false</code>
  
<code class="kc">true</code> <code class="o">!==</code> <code class="s1">'true'</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Second, sometimes, the cups are of the same type–perhaps two espresso cups–but they have different contents. One holds a single, one a double. This corresponds to comparing two JavaScript values that have the same type but different “content.” For example, the number <code>5</code> is not the same thing as the number <code>2</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">true</code> <code class="o">===</code> <code class="kc">false</code>
  <code class="c1">//=&gt; false</code>
  
<code class="mi">2</code> <code class="o">!==</code> <code class="mi">5</code>
  <code class="c1">//=&gt; true</code>
  
<code class="s1">'two'</code> <code class="o">===</code> <code class="s1">'five'</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>What if the cups are of the same type <em>and</em> the contents are the same? Well, JavaScript’s third and fourth possibilities cover that.</p>

<h4 id="leanpub-auto-value-types">value types</h4>

<p>Third, some types of cups have no distinguishing marks on them. If they are the same kind of cup, and they hold the same contents, we have no way to tell the difference between them. This is the case with the strings, numbers, and booleans we have seen so far.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">4</code>
  <code class="c1">//=&gt; true</code>
  
<code class="p">(</code><code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">4</code><code class="p">)</code> <code class="o">===</code> <code class="p">(</code><code class="mi">2</code> <code class="o">!==</code> <code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Note well what is happening with these examples: Even when we obtain a string, number, or boolean as the result of evaluating an expression, it is identical to another value of the same type with the same “content.” Strings, numbers, and booleans are examples of what JavaScript calls “value” or “primitive” types. We’ll use both terms interchangeably.</p>

<p>We haven’t encountered the fourth possibility yet. Stretching the metaphor somewhat, some types of cups have a serial number on the bottom. So even if you have two cups of the same type, and their contents are the same, you can still distinguish between them.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/macchiato_1200.jpg" alt="Cafe Macchiato is also a fine drink, especially when following up on the fortunes of the Azzurri or the standings in the Giro d&#39;Italia">
  <figcaption>Cafe Macchiato is also a fine drink, especially when following up on the fortunes of the Azzurri or the standings in the Giro d’Italia</figcaption>
</figure>


<h4 id="leanpub-auto-reference-types">reference types</h4>

<p>So what kinds of values might be the same type and have the same contents, but not be considered identical to JavaScript? Let’s meet a data structure that is very common in contemporary programming languages, the <em>Array</em> (other languages sometimes call it a List or a Vector).</p>

<p>An array looks like this: <code>[1, 2, 3]</code>. This is an expression, and you can combine <code>[]</code> with other expressions. Go wild with things like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">2</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="o">+</code><code class="mi">1</code><code class="p">]</code>
<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="o">+</code><code class="mi">1</code><code class="o">+</code><code class="mi">1</code><code class="p">]</code>
</pre></div>

</figure>

<p>Notice that you are always generating arrays with the same contents. But are they identical the same way that every value of <code>42</code> is identical to every other value of <code>42</code>? Try these for yourself:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">2</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="o">+</code><code class="mi">1</code><code class="p">]</code> <code class="o">===</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">]</code>
<code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">]</code> <code class="o">===</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="o">===</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
</pre></div>

</figure>

<p>How about that! When you type <code>[1, 2, 3]</code> or any of its variations, you are typing an expression that generates its own <em>unique</em> array that is not identical to any other array, even if that other array also looks like <code>[1, 2, 3]</code>. It’s as if JavaScript is generating new cups of coffee with serial numbers on the bottom.</p>

<p>They look the same, but if you examine them with <code>===</code>, you see that they are different. Every time you evaluate an expression (including typing something in) to create an array, you’re creating a new, distinct value even if it <em>appears</em> to be the same as some other array value. As we’ll see, this is true of many other kinds of values, including <em>functions</em>, the main subject of this book.</p>


<div class="footnotes">
  <ol>
    <li id="fn-representation">Technically, it’s a <em>representation</em> of a value using Base10 notation, but we needn’t worry about that in this book. You and I both understand that this means “42,” and so does the computer.<a href="https://leanpub.com/javascriptallongesix/read#fnref-representation" rel="rev-footnote">↩</a>
</li>
    <li id="fn-homoiconicity">In some languages, expressions are a kind of value unto themselves and can be manipulated. The grandfather of such languages is Lisp. JavaScript is not such a language, expressions in and of themselves are not values.<a href="https://leanpub.com/javascriptallongesix/read#fnref-homoiconicity" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-a-rich-aroma-basic-numbers">A Rich Aroma: Basic Numbers</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/expressions-title.jpg" alt="Mathematics and Coffee">
  <figcaption>Mathematics and Coffee</figcaption>
</figure>


<blockquote>
  <p>In computer science, a literal is a notation for representing a fixed value in source code. Almost all programming languages have notations for atomic values such as integers, floating-point numbers, and strings, and usually for booleans and characters; some also have notations for elements of enumerated types and compound values such as arrays, records, and objects. An anonymous function is a literal for the function type.—<a href="https://en.wikipedia.org/wiki/Literal_(computer_programming)">Wikipedia</a></p>
</blockquote>

<p>JavaScript, like most languages, has a collection of literals. We saw that an expression consisting solely of numbers, like <code>42</code>, is a literal. It represents the number forty-two, which is 42 base 10. Not all numbers are base ten. If we start a literal with a zero, it is an octal literal. So the literal <code>042</code> is 42 base 8, which is actually 34 base 10.</p>

<p>Internally, both <code>042</code> and <code>34</code> have the same representation, as <a href="http://en.wikipedia.org/wiki/Double-precision_floating-point_format">double-precision floating point</a> numbers. A computer’s internal representation for numbers is important to understand. The machine’s representation of a number almost never lines up perfectly with our understanding of how a number behaves, and thus there will be places where the computer’s behaviour surprises us if we don’t know a little about what it’s doing “under the hood.” </p>

<p>For example, the largest integer JavaScript can safely<sup id="fnref-safe"><a href="https://leanpub.com/javascriptallongesix/read#fn-safe" rel="footnote">1</a></sup> handle is <code>9007199254740991</code>, or <code>2</code><sup>`53`</sup><code>- 1</code>. Like most programming languages, JavaScript does not allow us to use commas to separate groups of digits. </p>

<h4 id="leanpub-auto-floating">floating</h4>

<p>Most programmers never encounter the limit on the magnitude of an integer. But we mentioned that numbers are represented internally as floating point, meaning that they need not be just integers. We can, for example, write <code>1.5</code> or <code>33.33</code>, and JavaScript represents these literals as floating point numbers.</p>

<p>It’s tempting to think we now have everything we need to do things like handle amounts of money, but as the late John Belushi would say, “Nooooooooooooooooooooo.” A computer’s internal representation for a floating point number is binary, while our literal number was in base ten. This makes no meaningful difference for integers, but it does for fractions, because some fractions base 10 do not have exact representations base 2.</p>

<p>One of the most oft-repeated examples is this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mf">1.0</code>
  <code class="c1">//=&gt; 1</code>
<code class="mf">1.0</code> <code class="o">+</code> <code class="mf">1.0</code>
  <code class="c1">//=&gt; 2</code>
<code class="mf">1.0</code> <code class="o">+</code> <code class="mf">1.0</code> <code class="o">+</code> <code class="mf">1.0</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>However:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mf">0.1</code>
  <code class="c1">//=&gt; 0.1</code>
<code class="mf">0.1</code> <code class="o">+</code> <code class="mf">0.1</code>
  <code class="c1">//=&gt; 0.2</code>
<code class="mf">0.1</code> <code class="o">+</code> <code class="mf">0.1</code> <code class="o">+</code> <code class="mf">0.1</code>
  <code class="c1">//=&gt; 0.30000000000000004</code>
</pre></div>

</figure>

<p>This kind of “inexactitude” can be ignored  when performing calculations that have an acceptable deviation. For example, when centering some text on a page, as long as the difference between what you might calculate longhand and JavaScript’s calculation is less than a pixel, there is no observable error.</p>

<p>But as a rule, if you need to work with real numbers, you should have more than a nodding acquaintance with the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE Standard for Floating-Point Arithmetic</a>. Professional programmers almost never use floating point numbers to represent monetary amounts. For example, “$43.21” will nearly always be presented as two numbers: <code>43</code> for dollars and <code>21</code> for cents, not <code>43.21</code>. In this book, we need not think about such details, but outside of this book, we must.</p>

<h4 id="leanpub-auto-operations-on-numbers">operations on numbers</h4>

<p>As we’ve seen, JavaScript has many common arithmetic operators. We can create expressions that look very much like mathematical expressions, for example we can write <code>1 + 1</code> or <code>2 * 3</code> or <code>42 - 34</code> or even <code>6 / 2</code>. These can be combined to make more complex expressions, like <code>2 * 5 + 1</code>.</p>

<p>In JavaScript, operators have an order of precedence designed to mimic the way humans typically parse written arithmetic. So:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">2</code> <code class="o">*</code> <code class="mi">5</code> <code class="o">+</code> <code class="mi">1</code>
  <code class="c1">//=&gt; 11</code>
<code class="mi">1</code> <code class="o">+</code> <code class="mi">5</code> <code class="o">*</code> <code class="mi">2</code>
  <code class="c1">//=&gt; 11</code>
</pre></div>

</figure>

<p>JavaScript treats the expressions as if we had written <code>(2 * 5) + 1</code> and <code>1 + (5 * 2)</code>, because the <code>*</code> operator has a <em>higher precedence</em> than the <code>+</code> operator. JavaScript has many more operators. In a sense, they behave like little functions. If we write <code>1 + 2</code>, this is conceptually similar to writing <code>plus(1, 2)</code> (assuming we have a function that adds two numbers bound to the name <code>plus</code>, of course).</p>

<p>In addition to the common <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, JavaScript also supports modulus, <code>%</code>, and unary negation, <code>-</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">-</code><code class="p">(</code><code class="mi">457</code> <code class="o">%</code> <code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; -1</code>
</pre></div>

</figure>

<p>There are lots and lots more operators that can be used with numbers, including bitwise operators like <code>|</code> and <code>&amp;</code> that allow you to operate directly on a number’s binary representation, and a number of other operators that perform assignment or logical comparison that we will look at later.</p>

<div class="footnotes">
  <ol>
    <li id="fn-safe">Implementations of JavaScript are free to handle larger numbers. For example, if you type <code>9007199254740991 + 9007199254740991</code> into <code>node.js</code>, it will happily report that the answer is <code>18014398509481982</code>. But code that depends upon numbers larger than <code>9007199254740991</code> may not be reliable when moved to other implementations.<a href="https://leanpub.com/javascriptallongesix/read#fnref-safe" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="functions">The first sip: Basic Functions</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/leaf-roaster.jpg" alt="The perfect Café Allongé begins with the right beans, properly roasted. JavaScript Allongé begins with functions, properly dissected.">
  <figcaption>The perfect Café Allongé begins with the right beans, properly roasted. JavaScript Allongé begins with functions, properly dissected.</figcaption>
</figure>


<h3 id="leanpub-auto-as-little-as-possible-about-functions-but-no-less">As Little As Possible About Functions, But No Less</h3>

<p>In JavaScript, functions are values, but they are also much more than simple numbers, strings, or even complex data structures like trees or maps. Functions represent computations to be performed. Like numbers, strings, and arrays, they have a representation. Let’s start with the second simplest possible function.<sup id="fnref-simplest"><a href="https://leanpub.com/javascriptallongesix/read#fn-simplest" rel="footnote">1</a></sup> In JavaScript, it looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code>
</pre></div>

</figure>

<p>This is a function that is applied to no values and returns <code>0</code>. Let’s verify that our function is a value like all others:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">)</code>
  <code class="c1">//=&gt; [Function]</code>
</pre></div>

</figure>

<p>What!? Why didn’t it type back <code>() =&gt; 0</code> for us? This <em>seems</em> to break our rule that if an expression is also a value, JavaScript will give the same value back to us. What’s going on? The simplest and easiest answer is that although the JavaScript interpreter does indeed return that value, displaying it on the screen is a slightly different matter. <code>[Function]</code> is a choice made by the people who wrote Node.js, the JavaScript environment that hosts the JavaScript REPL. If you try the same thing in a browser, you may see something else.</p>

<div class="page-break"></div>
<aside>
  <p>I’d prefer something else, but I must accept that what gets typed back to us on the screen is arbitrary, and all that really counts is that it is somewhat useful for a human to read. But we must understand that whether we see <code>[Function]</code> or <code>() =&gt; 0</code>, internally JavaScript has a full and proper function.</p>

</aside>

<h4 id="leanpub-auto-functions-and-identities">functions and identities</h4>

<p>You recall that we have two types of values with respect to identity: Value types and reference types. Value types share the same identity if they have the same contents. Reference types do not.</p>

<p>Which kind are functions? Let’s try them out and see. For reasons of appeasing the JavaScript parser, we’ll enclose our functions in parentheses:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="o">===</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Like arrays, every time you evaluate an expression to produce a function, you get a new function that is not identical to any other function, even if you use the same expression to generate it. “Function” is a reference type.</p>

<h4 id="leanpub-auto-applying-functions">applying functions</h4>

<p>Let’s put functions to work. The way we use functions is to <em>apply</em> them to zero or more values called <em>arguments</em>. Just as <code>2 + 2</code> produces a value (in this case <code>4</code>), applying a function to zero or more arguments produces a value as well.</p>

<p>Here’s how we apply a function to some values in JavaScript: Let’s say that <em>fn_expr</em> is an expression that when evaluated, produces a function. Let’s call the arguments <em>args</em>. Here’s how to apply a function to some arguments:</p>

<p><em>fn_expr</em><code>(</code><em>args</em><code>)</code></p>

<p>Right now, we only know about one such expression: <code>() =&gt; 0</code>, so let’s use it. We’ll put it in parentheses<sup id="fnref-ambiguous"><a href="https://leanpub.com/javascriptallongesix/read#fn-ambiguous" rel="footnote">2</a></sup> to keep the parser happy, like we did above: <code>(() =&gt; 0)</code>. Since we aren’t giving it any arguments, we’ll simply write <code>()</code> after the expression. So we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">)()</code>
  <code class="c1">//=&gt; 0</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-functions-that-return-values-and-evaluate-expressions">functions that return values and evaluate expressions</h4>

<p>We’ve seen <code>() =&gt; 0</code>. We know that <code>(() =&gt; 0)()</code> returns <code>0</code>, and this is unsurprising. Likewise, the following all ought to be obvious:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">1</code><code class="p">)()</code>
  <code class="c1">//=&gt; 1</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="s2">"Hello, JavaScript"</code><code class="p">)()</code>
  <code class="c1">//=&gt; "Hello, JavaScript"</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="kc">Infinity</code><code class="p">)()</code>
  <code class="c1">//=&gt; Infinity</code>
</pre></div>

</figure>

<p>Well, the last one’s a doozy, but still, the general idea is this: We can make a function that returns a value by putting the value to the right of the arrow.</p>

<p>In the prelude, we looked at expressions. Values like <code>0</code> are expressions, as are things like <code>40 + 2</code>. Can we put an expression to the right of the arrow?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)()</code>
  <code class="c1">//=&gt; 2</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="s2">"Hello, "</code> <code class="o">+</code> <code class="s2">"JavaScript"</code><code class="p">)()</code>
  <code class="c1">//=&gt; "Hello, JavaScript"</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="kc">Infinity</code> <code class="o">*</code> <code class="kc">Infinity</code><code class="p">)()</code>
  <code class="c1">//=&gt; Infinity</code>
</pre></div>

</figure>

<p>Yes we can. We can put any expression to the right of the arrow. For example, <code>(() =&gt; 0)()</code> is an expression. Can we put it to the right of an arrow, like this: <code>() =&gt; (() =&gt; 0)()</code>?</p>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">)())()</code>
  <code class="c1">//=&gt; 0</code>
</pre></div>

</figure>

<p>Yes we can! Functions can return the value of evaluating another function.</p>

<p>When dealing with expressions that have a lot of the same characters (like parentheses), you may find it helpful to format the code to make things stand out. So we can also write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code>
    <code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">0</code>
      <code class="p">)()</code>
  <code class="p">)()</code>
  <code class="c1">//=&gt; 0</code>
</pre></div>

</figure>

<p>It evaluates to the same thing, <code>0</code>.</p>

<h4 id="leanpub-auto-commas">commas</h4>

<p>The comma operator in JavaScript is interesting. It takes two arguments, evaluates them both, and itself evaluates to the value of the right-hand argument. In other words:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 4</code>
</pre></div>

</figure>

<p>We can use commas with functions to create functions that evaluate multiple expressions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">))()</code>
  <code class="c1">//=&gt; 4</code>
</pre></div>

</figure>

<p>This is useful when trying to do things that might involve <em>side-effects</em>, but we’ll get to that later. In most cases, JavaScript does not care whether things are separated by spaces, tabs, or line breaks. So we can also write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)</code>
</pre></div>

</figure>

<p>Or even:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">(</code>
    <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
  <code class="p">)</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-the-simplest-possible-block">the simplest possible block</h4>

<p>There’s another thing we can put to the right of an arrow, a <em>block</em>. A block has zero or more <em>statements</em>, separated by semicolons.<sup id="fnref-asi"><a href="https://leanpub.com/javascriptallongesix/read#fn-asi" rel="footnote">3</a></sup></p>

<p>So, this is a valid function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>It returns the result of evaluating a block that has no statements. What would that be? Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{})()</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>What is this <code>undefined</code>?</p>

<h4 id="leanpub-auto-undefined"><code>undefined</code></h4>

<p>In JavaScript, the absence of a value is written <code>undefined</code>, and it means there is no value. It will crop up again. <code>undefined</code> is its own type of value, and it acts like a value type:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">undefined</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>Like numbers, booleans and strings, JavaScript can print out the value <code>undefined</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">undefined</code> <code class="o">===</code> <code class="kc">undefined</code>
  <code class="c1">//=&gt; true</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{})()</code> <code class="o">===</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{})()</code>
  <code class="c1">//=&gt; true</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{})()</code> <code class="o">===</code> <code class="kc">undefined</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>No matter how you evaluate <code>undefined</code>, you get an identical value back. <code>undefined</code> is a value that means “I don’t have a value.” But it’s still a value :-)</p>

<aside>
  <p>You might think that <code>undefined</code> in JavaScript is equivalent to <code>NULL</code> in SQL. No. In SQL, two things that are <code>NULL</code> are not equal to nor share the same identity, because two unknowns can’t be equal. In JavaScript, every <code>undefined</code> is identical to every other <code>undefined</code>.</p>

</aside>

<h4 id="leanpub-auto-void">void</h4>

<p>We’ve seen that JavaScript represents an undefined value by typing <code>undefined</code>, and we’ve generated undefined values in two ways:</p>

<ol class="numeric">
  <li>By evaluating a function that doesn’t return a value <code>(() =&gt; {})()</code>, and;</li>
  <li>By writing <code>undefined</code> ourselves.</li>
</ol>

<p>There’s a third way, with JavaScript’s <code>void</code> operator. Behold:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">void</code> <code class="mi">0</code>
  <code class="c1">//=&gt; undefined</code>
<code class="k">void</code> <code class="mi">1</code>
  <code class="c1">//=&gt; undefined</code>
<code class="k">void</code> <code class="p">(</code><code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p><code>void</code> is an operator that takes any value and evaluates to <code>undefined</code>, always. So, when we deliberately want an undefined value, should we use the first, second, or third form?<sup id="fnref-fourth"><a href="https://leanpub.com/javascriptallongesix/read#fn-fourth" rel="footnote">4</a></sup> The answer is, use <code>void</code>. By convention, use <code>void 0</code>.</p>

<p>The first form works but it’s cumbersome. The second form works most of the time, but it is possible to break it by reassigning <code>undefined</code> to a different value, something we’ll discuss in <a href="https://leanpub.com/javascriptallongesix/read#reassignment">Reassignment and Mutation</a>. The third form is guaranteed to always work, so that’s what we will use.<sup id="fnref-void"><a href="https://leanpub.com/javascriptallongesix/read#fn-void" rel="footnote">5</a></sup></p>

<h4 id="leanpub-auto-back-on-the-block">back on the block</h4>

<p>Back to our function. We evaluated this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{})()</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>We said that the function returns the result of evaluating a <em>block</em>, and we said that a block is a (possibly empty) list of JavaScript <em>statements</em> separated by semicolons.<sup id="fnref-break"><a href="https://leanpub.com/javascriptallongesix/read#fn-break" rel="footnote">6</a></sup></p>

<p>Something like: <code>{</code> statement<sup>1</sup><code>;</code> statement<sup>2</sup><code>;</code> statement<sup>3</sup><code>; ... ;</code> statement<sup>n</sup> <code>}</code></p>

<p>We haven’t discussed these <em>statements</em>. What’s a statement?</p>

<p>There are many kinds of JavaScript statements, but the first kind is one we’ve already met. An expression is a JavaScript statement. Although they aren’t very practical, these are valid JavaScript functions, and they return <code>undefined</code> when applied:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">}</code>
<code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">}</code>
</pre></div>

</figure>

<p>As we saw with commas above, we can rearrange these functions onto multiple lines when we feel its more readable that way:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>But no matter how we arrange them, a block with one or more expressions still evaluates to <code>undefined</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">})()</code>
  <code class="c1">//=&gt; undefined</code>
  
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">})()</code>
  <code class="c1">//=&gt; undefined</code>
  
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
  <code class="p">})()</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>As you can see, a block with one expression does not behave like an expression, and a block with more than one expression does not behave like an expression constructed with the comma operator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)()</code>
  <code class="c1">//=&gt; 4</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">})()</code>
  <code class="c1">//=&gt; undefined</code>
  
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">))()</code>
  <code class="c1">//=&gt; 4</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code> <code class="p">})()</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>So how do we get a function that evaluates a block to return a value when applied? With the <code>return</code> keyword and any expression:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">0</code> <code class="p">})()</code>
  <code class="c1">//=&gt; 0</code>
  
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">1</code> <code class="p">})()</code>
  <code class="c1">//=&gt; 1</code>
  
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="s1">'Hello '</code> <code class="o">+</code> <code class="s1">'World'</code> <code class="p">})()</code>
  <code class="c1">// 'Hello World'</code>
</pre></div>

</figure>

<p>The <code>return</code> keyword creates a <em>return statement</em> that immediately terminates the function application and returns the result of evaluating its expression. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">return</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
  <code class="p">})()</code>
  <code class="c1">//=&gt; 4</code>
</pre></div>

</figure>

<p>And also:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
  <code class="p">})()</code>
  <code class="c1">//=&gt; 2</code>
</pre></div>

</figure>

<p>The return statement is the first statement we’ve seen, and it behaves differently than an expression. For example, you can’t use one as the expression in a simple function, because it isn’t an expression:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="k">return</code> <code class="mi">0</code><code class="p">)()</code>
  <code class="c1">//=&gt; ERROR</code>
</pre></div>

</figure>

<p>Statements belong inside blocks and only inside blocks. Some languages simplify this by making everything an expression, but JavaScript maintains this distinction, so when learning JavaScript we also learn about statements like function declarations, for loops, if statements, and so forth. We’ll see a few more of these later.</p>

<h4 id="leanpub-auto-functions-that-evaluate-to-functions">functions that evaluate to functions</h4>

<p>If an expression that evaluates to a function is, well, an expression, and if a return statement can have any expression on its right side… <em>Can we put an expression that evaluates to a function on the right side of a function expression?</em></p>

<p>Yes:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code>
</pre></div>

</figure>

<p>That’s a function! It’s a function that when applied, evaluates to a function that when applied, evaluates to <code>0</code>.  So we have <em>a function, that returns a function, that returns zero</em>. Likewise:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code>
</pre></div>

</figure>

<p>That’s a function, that returns a function, that returns <code>true</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code><code class="p">)()()</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>We could, of course, do the same thing with a block if we wanted:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code> <code class="p">}</code>
</pre></div>

</figure>

<p>But we generally don’t.</p>

<hr class="scene-break">

<p>Well. We’ve been very clever, but so far this all seems very abstract. Diffraction of a crystal is beautiful and interesting in its own right, but you can’t blame us for wanting to be shown a practical use for it, like being able to determine the composition of a star millions of light years away. So… In the next chapter, “<a href="https://leanpub.com/javascriptallongesix/read#fargs">I’d Like to Have an Argument, Please</a>,” we’ll see how to make functions practical.</p>

<h3 id="fargs">Ah. I’d Like to Have an Argument, Please.</h3>

<p>Up to now, we’ve looked at functions without arguments. We haven’t even said what an argument <em>is</em>, only that our functions don’t have any.</p>

<aside>
  <p>Most programmers are perfectly familiar with arguments (often called “parameters”). Secondary school mathematics discusses this. So you know what they are, and I know that you know what they are, but please be patient with the explanation!</p>

</aside>

<p>Let’s make a function with an argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">room</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>This function has one argument, <code>room</code>, and an empty body. Here’s a function with two arguments and an empty body:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">room</code><code class="p">,</code> <code class="nx">board</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{}</code>
</pre></div>

</figure>

<p>I’m sure you are perfectly comfortable with the idea that this function has two arguments, <code>room</code>, and <code>board</code>. What does one do with the arguments? Use them in the body, of course. What do you think this is?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code>
</pre></div>

</figure>

<p>It’s a function for calculating the circumference of a circle given the diameter. I read that aloud as “When applied to a value representing the diameter, this function <em>returns</em> the diameter times 3.14159265.”</p>

<p>Remember that to apply a function with no arguments, we wrote <code>(() =&gt; {})()</code>. To apply a function with an argument (or arguments), we put the argument (or arguments) within the parentheses, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>You won’t be surprised to see how to write and apply a function to two arguments:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">room</code><code class="p">,</code> <code class="nx">board</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">room</code> <code class="o">+</code> <code class="nx">board</code><code class="p">)(</code><code class="mi">800</code><code class="p">,</code> <code class="mi">150</code><code class="p">)</code>
  <code class="c1">//=&gt; 950</code>
</pre></div>

</figure>

<aside class="tip blurb">
    <h4 id="leanpub-auto-a-quick-summary-of-functions-and-bodies">a quick summary of functions and bodies</h4>

  <p>How arguments are used in a body’s expression is probably perfectly obvious to you from the examples, especially if you’ve used any programming language (except for the dialect of BASIC–which I recall from my secondary school–that didn’t allow parameters when you called a procedure).</p>

  <p>Expressions consist either of representations of values (like <code>3.14159265</code>, <code>true</code>, and <code>undefined</code>), operators that combine expressions (like <code>3 + 2</code>), some special forms like <code>[1, 2, 3]</code> for creating arrays out of expressions, or <code>function (</code><em>arguments</em><code>) {</code><em>body-statements</em><code>}</code> for creating functions.</p>

  <p>One of the important possible statements is a return statement. A return statement accepts any valid JavaScript expression.</p>

  <p>This loose definition is recursive, so we can intuit (or use our experience with other languages) that since a function can contain a return statement with an expression, we can write a function that returns a function, or an array that contains another array expression. Or a function that returns an array, an array of functions, a function that returns an array of functions, and so forth:</p>

  <figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{};</code>

<code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>

<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="mi">4</code><code class="p">];</code>

<code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">1</code><code class="p">,</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">2</code><code class="p">,</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">3</code>
  <code class="p">];</code>
</pre></div>

  </figure>

</aside>

<h4 id="call-by-value">call by value</h4>

<p>Like most contemporary programming languages, JavaScript uses the “call by value” <a href="http://en.wikipedia.org/wiki/Evaluation_strategy">evaluation strategy</a>. That means that when you write some code that appears to apply a function to an expression or expressions, JavaScript evaluates all of those expressions and applies the functions to the resulting value(s).</p>

<p>So when you write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">1</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>What happened internally is that the expression <code>1 + 1</code> was evaluated first, resulting in <code>2</code>. Then our circumference function was applied to <code>2</code>.<sup id="fnref-f2f"><a href="https://leanpub.com/javascriptallongesix/read#fn-f2f" rel="footnote">8</a></sup></p>

<p>We’ll see <a href="https://leanpub.com/javascriptallongesix/read#call-by-sharing">below</a> that while JavaScript always calls by value, the notion of a “value” has additional subtlety. But before we do, let’s look at variables.</p>

<h4 id="leanpub-auto-variables-and-bindings">variables and bindings</h4>

<p>Right now everything looks simple and straightforward, and we can move on to talk about arguments in more detail. And we’re going to work our way up from <code>(diameter) =&gt; diameter * 3.14159265</code> to functions like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code>
</pre></div>

</figure>

<aside>
  <p><code>(x) =&gt; (y) =&gt; x</code> just looks crazy, as if we are learning English as a second language and the teacher promises us that soon we will be using words like <em>antidisestablishmentarianism</em>. Besides a desire to use long words to sound impressive, this is not going to seem attractive until we find ourselves wanting to discuss the role of the Church of England in 19th century British politics.</p>

  <p>But there’s another reason for learning the word <em>antidisestablishmentarianism</em>: We might learn how prefixes and postfixes work in English grammar. It’s the same thing with <code>(x) =&gt; (y) =&gt; x</code>. It has a certain important meaning in its own right, and it’s also an excellent excuse to learn about functions that make functions, environments, variables, and more.</p>

</aside>

<p>In order to talk about how this works, we should agree on a few terms (you may already know them, but let’s check-in together and “synchronize our dictionaries”). The first <code>x</code>, the one in <code>(x) =&gt; ...</code>, is an <em>argument</em>. The <code>y</code> in <code>function (y) ...</code> is another argument. The second <code>x</code>, the one in <code>=&gt; x</code>, is not an argument, <em>it’s an expression referring to a variable</em>. Arguments and variables work the same way whether we’re talking about <code>(x) =&gt; (y) =&gt; x</code>  or just plain <code>(x) =&gt; x</code>.</p>

<p>Every time a function is invoked (“invoked” means “applied to zero or more arguments”), a new <em>environment</em> is created. An environment is a (possibly empty) dictionary that maps variables to values by name. The <code>x</code> in the expression that we call a “variable” is itself an expression that is evaluated by looking up the value in the environment.</p>

<p>How does the value get put in the environment? Well for arguments, that is very simple. When you apply the function to the arguments, an entry is placed in the dictionary for each argument. So when we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>
</pre></div>

</figure>

<p>What happens is this:</p>

<ol class="numeric">
  <li>JavaScript parses this whole thing as an expression made up of several sub-expressions.</li>
  <li>It then starts evaluating the expression, including evaluating sub-expressions</li>
  <li>One sub-expression, <code>(x) =&gt; x</code> evaluates to a function.</li>
  <li>Another, <code>2</code>, evaluates to the number 2.</li>
  <li>JavaScript now evaluates applying the function to the argument <code>2</code>. Here’s where it gets interesting…</li>
  <li>An environment is created.</li>
  <li>The value ‘2’ is bound to the name ‘x’ in the environment.</li>
  <li>The expression ‘x’ (the right side of the function) is evaluated within the environment we just created.</li>
  <li>The value of a variable when evaluated in an environment is the value bound to the variable’s name in that environment, which is ‘2’</li>
  <li>And that’s our result.</li>
</ol>

<p>When we talk about environments, we’ll use an <a href="http://json.org/">unsurprising syntax</a> for showing their bindings: <code>{x: 2, ...}</code>. meaning, that the environment is a dictionary, and that the value <code>2</code> is bound to the name <code>x</code>, and that there might be other stuff in that dictionary we aren’t discussing right now.</p>

<h4 id="call-by-sharing">call by sharing</h4>

<p>Earlier, we distinguished JavaScript’s <em>value types</em> from its <em>reference types</em>. At that time, we looked at how JavaScript distinguishes objects that are identical from objects that are not. Now it is time to take another look at the distinction between value and reference types.</p>

<p>There is a property that JavaScript strictly maintains: When a value–any value–is passed as an argument to a function, the value bound in the function’s environment must be identical to the original.</p>

<p>We said that JavaScript binds names to values, but we didn’t say what it means to bind a name to a value. Now we can elaborate: When JavaScript binds a value-type to a name, it makes a copy of the value and places the copy in the environment. As you recall, value types like strings and numbers are identical to each other if they have the same content. So JavaScript can make as many copies of strings, numbers, or booleans as it wishes.</p>

<p>What about reference types? JavaScript does not place copies of reference values in any environment. JavaScript places <em>references</em> to reference types in environments, and when the value needs to be used, JavaScript uses the reference to obtain the original.</p>

<p>Because many references can share the same value, and because JavaScript passes references as arguments, JavaScript can be said to implement “call by sharing” semantics. Call by sharing is generally understood to be a specialization of call by value, and it explains why some values are known as value types and other values are known as reference types.</p>

<p>And with that, we’re ready to look at <em>closures</em>. When we combine our knowledge of value types, reference types, arguments, and closures, we’ll understand why this function always evaluates to <code>true</code> no matter what argument<sup id="fnref-NaNPedantry"><a href="https://leanpub.com/javascriptallongesix/read#fn-NaNPedantry" rel="footnote">9</a></sup> you apply it to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">ref1</code><code class="p">,</code> <code class="nx">ref2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ref1</code> <code class="o">===</code> <code class="nx">ref2</code><code class="p">)(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code>
</pre></div>

</figure>

<h3 id="closures">Closures and Scope</h3>

<p>It’s time to see how a function within a function works:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">)(</code><code class="mi">1</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>
</pre></div>

</figure>

<p>First off, let’s use what we learned above. Given <code>(</code><em>some function</em><code>)(</code><em>some argument</em><code>)</code>, we know that we apply the function to the argument, create an environment, bind the value of the argument to the name, and evaluate the function’s expression. So we do that first with this code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">)(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; [Function]</code>
</pre></div>

</figure>

<p>The environment belonging to the function with signature <code>(x) =&gt; ...</code> becomes <code>{x: 1, ...}</code>, and the result of applying the function is another function value. It makes sense that the result value is a function, because the expression for <code>(x) =&gt; ...</code>’s body is:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code>
</pre></div>

</figure>

<p>So now we have a value representing that function. Then we’re going to take the value of that function and apply it to the argument <code>2</code>, something like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  <code class="p">((</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
</pre></div>

</figure>

<p>So we seem to get a new environment <code>{y: 2, ...}</code>. How is the expression <code>x</code> going to be evaluated in that function’s environment? There is no <code>x</code> in its environment, it must come from somewhere else.</p>

<aside>
  <p>This, by the way, is one of the great defining characteristics of JavaScript and languages in the same family: Whether they allow things like functions to nest inside each other, and if so, how they handle variables from “outside” of a function that are referenced inside a function. For example, here’s the equivalent code in Ruby:</p>

  <figure class="code">
<div class="highlight"><pre><code></code><code class="nb">lambda</code> <code class="p">{</code> <code class="o">|</code><code class="n">x</code><code class="o">|</code>
  <code class="nb">lambda</code> <code class="p">{</code> <code class="o">|</code><code class="n">y</code><code class="o">|</code> <code class="n">x</code> <code class="p">}</code>
<code class="p">}</code><code class="o">[</code><code class="mi">1</code><code class="o">][</code><code class="mi">2</code><code class="o">]</code>
  <code class="c1">#=&gt; 1</code>
</pre></div>

  </figure>

  <p>Now let’s enjoy a relaxed Allongé before we continue!</p>

</aside>

<h4 id="leanpub-auto-if-functions-without-free-variables-are-pure-are-closures-impure">if functions without free variables are pure, are closures impure?</h4>

<p>The function <code>(y) =&gt; x</code> is interesting. It contains a <em>free variable</em>, <code>x</code>.<sup id="fnref-nonlocal"><a href="https://leanpub.com/javascriptallongesix/read#fn-nonlocal" rel="footnote">10</a></sup> A free variable is one that is not bound within the function. Up to now, we’ve only seen one way to “bind” a variable, namely by passing in an argument with the same name. Since the function <code>(y) =&gt; x</code> doesn’t have an argument named <code>x</code>, the variable <code>x</code> isn’t bound in this function, which makes it “free.”</p>

<p>Now that we know that variables used in a function are either bound or free, we can bifurcate functions into those with free variables and those without:</p>

<ul>
  <li>Functions containing no free variables are called <em>pure functions</em>.</li>
  <li>Functions containing one or more free variables are called <em>closures</em>.</li>
</ul>

<p>Pure functions are easiest to understand. They always mean the same thing wherever you use them. Here are some pure functions we’ve already seen:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{}</code>

<code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code>
  
<code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code>
</pre></div>

</figure>

<p>The first function doesn’t have any variables, therefore doesn’t have any free variables. The second doesn’t have any free variables, because its only variable is bound. The third one is actually two functions, one inside the other. <code>(y) =&gt; ...</code> has a free variable, but the entire expression refers to <code>(x) =&gt; ...</code>, and it doesn’t have a free variable: The only variable anywhere in its body is <code>x</code>, which is certainly bound within <code>(x) =&gt; ...</code>.</p>

<p>From this, we learn something: A pure function can contain a closure.</p>

<aside class="exercise blurb">
    <p>If pure functions can contain closures, can a closure contain a pure function? Using only what we’ve learned so far, attempt to compose a closure that contains a pure function. If you can’t, give your reasoning for why it’s impossible.</p>

</aside>

<p>Pure functions always mean the same thing because all of their “inputs” are fully defined by their arguments. Not so with a closure. If I present to you this pure function <code>(x, y) =&gt; x + y</code>, we know exactly what it does with <code>(2, 2)</code>. But what about this closure: <code>(y) =&gt; x + y</code>? We can’t say what it will do with argument <code>(2)</code> without understanding the magic for evaluating the free variable <code>x</code>.</p>

<h4 id="leanpub-auto-its-always-the-environment">it’s always the environment</h4>

<p>To understand how closures are evaluated, we need to revisit environments. As we’ve said before, all functions are associated with an environment. We also hand-waved something when describing our environment. Remember that we said the environment for <code>((x) =&gt; (y) =&gt; x)(1)</code> is <code>{x: 1, ...}</code> and that the environment for <code>((y) =&gt; x)(2)</code> is <code>{y: 2, ...}</code>? Let’s fill in the blanks!</p>

<p>The environment for <code>((y) =&gt; x)(2)</code> is <em>actually</em> <code>{y: 2, '..': {x: 1, ...}}</code>. <code>'..'</code> means something like “parent” or “enclosure” or “super-environment.” It’s <code>(x) =&gt; ...</code>’s environment, because the function <code>(y) =&gt; x</code> is within <code>(x) =&gt; ...</code>’s body. So whenever a function is applied to arguments, its environment always has a reference to its parent environment.</p>

<p>And now you can guess how we evaluate <code>((y) =&gt; x)(2)</code> in the environment <code>{y: 2, '..': {x: 1, ...}}</code>. The variable <code>x</code> isn’t in <code>(y) =&gt; ...</code>’s immediate environment, but it is in its parent’s environment, so it evaluates to <code>1</code> and that’s what <code>((y) =&gt; x)(2)</code> returns even though it ended up ignoring its own argument.</p>

<aside>
  <p><code>(x) =&gt; x</code> is called the I Combinator, or the <em>Identity Function</em>. <code>(x) =&gt; (y) =&gt; x</code> is called the K Combinator, or <em>Kestrel</em>. Some people get so excited by this that they write entire books about them, some are <a href="http://www.amzn.com/0192801422?tag=raganwald001-20">great</a>, some–how shall I put this–are <a href="https://leanpub.com/combinators" title="Kestrels, Quirky Birds, and Hopeless Egocentricity">interesting</a> if you use Ruby.</p>

</aside>

<p>Functions can have grandparents too:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code>
   <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code>
     <code class="p">(</code><code class="nx">z</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code>
</pre></div>

</figure>

<p>This function does much the same thing as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code>
</pre></div>

</figure>

<p>Only you call it with <code>(1)(2)(3)</code> instead of <code>(1, 2, 3)</code>. The other big difference is that you can call it with <code>(1)</code> and get a function back that you can later call with <code>(2)(3)</code>.</p>

<div class="page-break"></div>
<aside>
  <p>The first function is the result of <a href="https://en.wikipedia.org/wiki/Currying">currying</a> the second function. Calling a curried function with only some of its arguments is sometimes called <a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a>. Some programming languages automatically curry and partially evaluate functions without the need to manually nest them.</p>

</aside>

<h4 id="leanpub-auto-shadowy-variables-from-a-shadowy-planet">shadowy variables from a shadowy planet</h4>

<p>An interesting thing happens when a variable has the same name as an ancestor environment’s variable. Consider:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code>
</pre></div>

</figure>

<p>The function <code>(x, y) =&gt; x + y</code> is a pure function, because its <code>x</code> is defined within its own environment. Although its parent also defines an <code>x</code>, it is ignored when evaluating <code>x + y</code>. JavaScript always searches for a binding starting with the functions own environment and then each parent in turn until it finds one. The same is true of:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="nx">z</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="p">(</code><code class="nx">w</code><code class="p">)</code> <code class="o">=&gt;</code>
        <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code>
</pre></div>

</figure>

<p>When evaluating <code>x + y + z</code>, JavaScript will find <code>x</code> and <code>y</code> in the great-grandparent scope and <code>z</code> in the parent scope. The <code>x</code> in the great-great-grandparent scope is ignored, as are both <code>w</code>s. When a variable has the same name as an ancestor environment’s binding, it is said to <em>shadow</em> the ancestor.</p>

<p>This is often a good thing.</p>

<h4 id="leanpub-auto-which-came-first-the-chicken-or-the-egg">which came first, the chicken or the egg?</h4>

<p>This behaviour of pure functions and closures has many, many consequences that can be exploited to write software. We are going to explore them in some detail as well as look at some of the other mechanisms JavaScript provides for working with variables and mutable state.</p>

<p>But before we do so, there’s one final question: Where does the ancestry start? If there’s no other code in a file, what is <code>(x) =&gt; x</code>’s parent environment?</p>

<p>JavaScript always has the notion of at least one environment we do not control: A global environment in which many useful things are bound such as libraries full of standard functions. So when you invoke <code>((x) =&gt; x)(1)</code> in the REPL, its full environment is going to look like this: <code>{x: 1, '..': </code><em>global environment</em><code>}</code>.</p>

<p>Sometimes, programmers wish to avoid this. If you don’t want your code to operate directly within the global environment, what can you do? Create an environment for them, of course. Many programmers choose to write every JavaScript file like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// top of the file</code>
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  
  <code class="c1">// ... lots of JavaScript ...</code>
  
<code class="p">})();</code>
<code class="c1">// bottom of the file</code>
</pre></div>

</figure>

<p>The effect is to insert a new, empty environment in between the global environment and your own functions: <code>{x: 1, '..': {'..': </code><em>global environment</em><code>}}</code>. As we’ll see when we discuss mutable state, this helps to prevent programmers from accidentally changing the global state that is shared by all code in the program.</p>

<h3 id="const">That Constant Coffee Craving</h3>

<p>Up to now, all we’ve really seen are <em>anonymous functions</em>, functions that don’t have a name. This feels very different from programming in most other languages, where the focus is on naming functions, methods, and procedures. Naming things is a critical part of programming, but all we’ve seen so far is how to name arguments.</p>

<p>There are other ways to name things in JavaScript, but before we learn some of those, let’s see how to use what we already have to name things. Let’s revisit a very simple example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code>
</pre></div>

</figure>

<p>What is this “3.14159265” number? <a href="https://en.wikipedia.org/wiki/Pi">PI</a>, obviously. We’d like to name it so that we can write something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
</pre></div>

</figure>

<p>In order to bind <code>3.14159265</code> to the name <code>PI</code>, we’ll need a function with a parameter of <code>PI</code> applied to an argument of <code>3.14159265</code>. If we put our function expression in parentheses, we can apply it to the argument of <code>3.14159265</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> 
  <code class="c1">// ????</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>What do we put inside our new function that binds <code>3.14159265</code> to the name <code>PI</code> when evaluated? Our circumference function, of course:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>This expression, when evaluated, returns a function that calculates circumferences. That sounds bad, but when we think about it, <code>(diameter) =&gt; diameter * 3.14159265</code> is also an expression, that when evaluated, returns a function that calculates circumferences. All of our “functions” are expressions. This one has a few more moving parts, that’s all. But we can use it just like <code>(diameter) =&gt; diameter * 3.14159265</code>.</p>

<p>Let’s test it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
  
<code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>That works! We can bind anything we want in an expression by wrapping it in a function that is immediately invoked with the value we want to bind.<sup id="fnref-explain-iife"><a href="https://leanpub.com/javascriptallongesix/read#fn-explain-iife" rel="footnote">11</a></sup></p>

<h4 id="leanpub-auto-inside-out">inside-out</h4>

<p>There’s another way we can make a function that binds <code>3.14159265</code> to the name <code>PI</code> and then uses that in its expression. We can turn things inside-out by putting the binding inside our diameter calculating function, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>It produces the same result as our previous expressions for a diameter-calculating function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
  
<code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>

<code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mf">3.14159265</code><code class="p">))(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>Which one is better? Well, the first one seems simplest, but a half-century of experience has taught us that names matter. A “magic literal” like <code>3.14159265</code> is anathema to sustainable software development.</p>

<p>The third one is easiest for most people to read. It separates concerns nicely: The “outer” function describes its parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="c1">// ...</code>
</pre></div>

</figure>

<p>Everything else is encapsulated in its body. That’s how it should be, naming <code>PI</code> is its concern, not ours. The other formulation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="c1">// ...</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>“Exposes” naming <code>PI</code> first, and we have to look inside to find out why we care. So, should we should always write this?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>Well, the wrinkle with this is that typically, invoking functions is considerably more expensive than evaluating expressions. Every time we invoke the outer function, we’ll invoke the inner function. We could get around this by writing </p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>But then we’ve obfuscated our code, and we don’t want to do that unless we absolutely have to.</p>

<p>What would be very nice is if the language gave us a way to bind names inside of blocks without incurring the cost of a function invocation. And JavaScript does.</p>

<h4 id="leanpub-auto-const">const</h4>

<p>Another way to write our “circumference” function would be to pass <code>PI</code> along with the diameter argument, something like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">,</code> <code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
</pre></div>

</figure>

<p>And we could use it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">,</code> <code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mi">2</code><code class="p">,</code> <code class="mf">3.14159265</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>This differs from our example above in that there is only one environment, rather than two. We have one binding in the environment representing our regular argument, and another our “constant.” That’s more efficient, and it’s <em>almost</em> what we wanted all along: A way to bind <code>3.14159265</code> to a readable name.</p>

<p>JavaScript gives us a way to do that, the <code>const</code> keyword. We’ll learn a lot more about <code>const</code> in future chapters, but here’s the most important thing we can do with <code>const</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The <code>const</code> keyword introduces one or more bindings in the block that encloses it. It doesn’t incur the cost of a function invocation. That’s great. Even better, it puts the symbol (like <code>PI</code>) close to the value (<code>3.14159265</code>). That’s much better than what we were writing.</p>

<p>We use the <code>const</code> keyword in a <em>const statement</em>. <code>const</code> statements occur inside blocks, we can’t use them when we write a fat arrow that has an expression as its body.</p>

<p>It works just as we want. Instead of:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mf">3.14159265</code><code class="p">))(</code><code class="mi">2</code><code class="p">)</code>
</pre></div>

</figure>

<p>Or:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">,</code> <code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">)(</code><code class="mi">2</code><code class="p">,</code> <code class="mf">3.14159265</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>We write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>We can bind any expression. Functions are expressions, so we can bind helper functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">d</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">calc</code> <code class="o">=</code> <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>

    <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">};</code>

  <code class="k">return</code> <code class="s2">"The circumference is "</code> <code class="o">+</code> <code class="nx">calc</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Notice <code>calc(d)</code>? This underscores what we’ve said: if we have an expression that evaluates to a function, we apply it with <code>()</code>. A name that’s bound to a function is a valid expression evaluating to a function.<sup id="fnref-namedfn"><a href="https://leanpub.com/javascriptallongesix/read#fn-namedfn" rel="footnote">12</a></sup></p>

<aside>
  <p>Amazing how such an important idea–naming functions–can be explained <em>en passant</em> in just a few words. That emphasizes one of the things JavaScript gets really, really right: Functions as “first class entities.” Functions are values that can be bound to names like any other value, passed as arguments, returned from other functions, and so forth.</p>

</aside>

<p>We can bind more than one name-value pair by separating them with commas. For readability, most people put one binding per line:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">d</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code>   <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">,</code>
      <code class="nx">calc</code> <code class="o">=</code> <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>

  <code class="k">return</code> <code class="s2">"The circumference is "</code> <code class="o">+</code> <code class="nx">calc</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-nested-blocks">nested blocks</h4>

<p>Up to now, we’ve only ever seen blocks we use as the body of functions. But there are other kinds of blocks. One of the places you can find blocks is in an <code>if</code> statement. In JavaScript, an <code>if</code> statement looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">else</code>
      <code class="k">return</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And it works for fairly small numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">else</code>
      <code class="k">return</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">})(</code><code class="mi">13</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>The <code>if</code> statement is a statement, not an expression (an unfortunate design choice), and its clauses are statements or blocks. So we could also write something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">odd</code> <code class="o">=</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">y</code><code class="p">);</code>
      
      <code class="k">return</code> <code class="nx">odd</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And this also works:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">odd</code> <code class="o">=</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">y</code><code class="p">);</code>
      
      <code class="k">return</code> <code class="nx">odd</code><code class="p">(</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">})(</code><code class="mi">42</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>We’ve used a block as the <code>else</code> clause, and since it’s a block, we’ve placed a <code>const</code> statement inside it.</p>

<h4 id="leanpub-auto-const-and-lexical-scope">const and lexical scope</h4>

<p>This seems very straightforward, but alas, there are some semantics of binding names that we need to understand if we’re to place <code>const</code> anywhere we like. The first thing to ask ourselves is, what happens if we use <code>const</code> to bind two different values to the “same” name?</p>

<p>Let’s back up and reconsider how closures work. What happens if we use parameters to bind two different values to the same name?</p>

<p>Here’s the second formulation of our diameter function, bound to a name using an IIFE:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter_fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="c1">// ...</code>
<code class="p">)(</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
<code class="p">)</code>
</pre></div>

</figure>

<p>It’s more than a bit convoluted, but it binds <code>((PI) =&gt; (diameter) =&gt; diameter * PI)(3.14159265)</code> to <code>diameter_fn</code> and evaluates the expression that we’ve elided. We can use any expression in there, and that expression can invoke <code>diameter_fn</code>. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter_fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">diameter_fn</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
<code class="p">)(</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
<code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>We know this from the chapter on <a href="https://leanpub.com/javascriptallongesix/read#closures">closures</a>, but even though <code>PI</code> is not bound when we invoke <code>diameter_fn</code> by evaluating <code>diameter_fn(2)</code>, <code>PI</code> <em>is</em> bound when we evaluated <code>(diameter) =&gt; diameter * PI</code>, and thus the expression <code>diameter * PI</code> is able to access values for <code>PI</code> and <code>diameter</code> when we evaluate <code>diameter_fn</code>.</p>

<p>This is called <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope">lexical scoping</a>, because we can discover where a name is bound by looking at the source code for the program. We can see that <code>PI</code> is bound in an environment surrounding <code>(diameter) =&gt; diameter * PI</code>, we don’t need to know where <code>diameter_fn</code> is invoked.</p>

<p>We can test this by deliberately creating a “conflict:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter_fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">diameter_fn</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
  <code class="p">)(</code><code class="mi">3</code><code class="p">)</code>
<code class="p">)(</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
<code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>Although we have bound <code>3</code> to <code>PI</code> in the environment surrounding <code>diameter_fn(2)</code>, the value that counts is <code>3.14159265</code>, the value we bound to <code>PI</code> in the environment surrounding (diameter) ⇒ diameter * PI.</p>

<p>That much we can carefully work out from the way closures work. Does <code>const</code> work the same way? Let’s find out:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter_fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  
  <code class="k">return</code> <code class="nx">diameter_fn</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>
<code class="p">})(</code>
  <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
    
    <code class="k">return</code> <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">})()</code>
<code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>Yes. Binding values to names with <code>const</code> works just like binding values to names with parameter invocations, it uses lexical scope.</p>

<h4 id="leanpub-auto-are-consts-also-from-a-shadowy-planet">are consts also from a shadowy planet?</h4>

<p>We just saw that values bound with <code>const</code> use lexical scope, just like values bound with parameters. They are looked up in the environment where they are declared. And we know that functions create environments. Parameters are declared when we create functions, so it makes sense that parameters are bound to environments created when we invoke functions.</p>

<p>But <code>const</code> statements can appear inside blocks, and we saw that blocks can appear inside of other blocks, including function bodies. So where are <code>const</code> variables bound? In the function environment? Or in an environment corresponding to the block?</p>

<p>We can test this by creating another conflict. But instead of binding two different variables to the same name in two different places, we’ll bind two different values to the same name, but one environment will be completely enclosed by the other.</p>

<p>Let’s start, as above, by doing this with parameters. We’ll start with:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
<code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>And gratuitously wrap it in another IIFE so that we can bind <code>PI</code> to something else:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
<code class="p">)(</code><code class="mi">3</code><code class="p">)</code>
</pre></div>

</figure>

<p>This still evaluates to a function that calculates diameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code>
  <code class="p">)(</code><code class="mf">3.14159265</code><code class="p">)</code>
<code class="p">)(</code><code class="mi">3</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>And we can see that our <code>diameter * PI</code> expression uses the binding for <code>PI</code> in the closest parent environment.  but one question: Did binding <code>3.14159265</code> to <code>PI</code> somehow change the binding in the “outer” environment? Let’s rewrite things slightly differently:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{})(</code><code class="mi">3</code><code class="p">);</code>
  
  <code class="k">return</code> <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mf">3.14159265</code><code class="p">)</code>
</pre></div>

</figure>

<p>Now we bind <code>3</code> to <code>PI</code> in an otherwise empty IIFE inside of our IIFE that binds <code>3.14159265</code> to <code>PI</code>. Does that binding “overwrite” the outer one? Will our function return <code>6</code> or <code>6.2831853</code>? This is a book, you’ve already scanned ahead, so you know that the answer is <strong>no</strong>, the inner binding does not overwrite the outer binding:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="p">((</code><code class="nx">PI</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{})(</code><code class="mi">3</code><code class="p">);</code>
  
  <code class="k">return</code> <code class="p">(</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mf">3.14159265</code><code class="p">)(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>We say that when we bind a variable using a parameter inside another binding, the inner binding <em>shadows</em> the outer binding. It has effect inside its own scope, but does not affect the binding in the enclosing scope.</p>

<p>So what about <code>const</code>. Does it work the same way?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
  
  <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  <code class="p">})();</code>
  
  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>Yes, names bound with <code>const</code> shadow enclosing bindings just like parameters. But wait! There’s more!!!</p>

<p>Parameters are only bound when we invoke a function. That’s why we made all these IIFEs. But <code>const</code> statements can appear inside blocks. What happens when we use a <code>const</code> inside of a block?</p>

<p>We’ll need a gratuitous block. We’ve seen <code>if</code> statements, what could be more gratuitous than:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// an immediately invoked block statement (IIBS)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  
  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
  
    <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>

<code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
  
  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>Ah! <code>const</code> statements don’t just shadow values bound within the environments created by functions, they shadow values bound within environments created by blocks!</p>

<p>This is enormously important. Consider the alternative: What if <code>const</code> could be declared inside of a block, but it always bound the name in the function’s scope. In that case, we’d see things like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
  
  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; would return 6 if const had function scope</code>
</pre></div>

</figure>

<p>If <code>const</code> always bound its value to the name defined in the function’s environment, placing a <code>const</code> statement inside of a block would merely rebind the existing name, overwriting its old contents. That would be super-confusing. And this code would “work:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">((</code><code class="nx">diameter</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="mf">3.14159265</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">diameter</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; would return 6.2831853 if const had function scope</code>
</pre></div>

</figure>

<p>Again, confusing. Typically, we want to bind our names as close to where we need them as possible. This design rule is called the <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Principle of Least Privilege</a>, and it has both quality and security implications. Being able to bind a name inside of a block means that if the name is only needed in the block, we are not “leaking” its binding to other parts of the code that do not need to interact with it.</p>

<h4 id="rebinding-peek">rebinding</h4>

<p>By default, JavaScript permits us to <em>rebind</em> new values to names bound with a parameter. For example, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">evenStevens</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="nx">n</code> <code class="o">=</code> <code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">evenStevens</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">evenStevens</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>The line <code>n = n - 2;</code> <em>rebinds</em> a new value to the name <code>n</code>. We will discuss this at much greater length in <a href="https://leanpub.com/javascriptallongesix/read#reassignment">Reassignment</a>, but long before we do, let’s try a similar thing with a name bound using <code>const</code>. We’ve already bound <code>evenStevens</code> using <code>const</code>, let’s try rebinding it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">evenStevens</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">evenStevens</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
  <code class="c1">//=&gt; ERROR, evenStevens is read-only</code>
</pre></div>

</figure>

<p>JavaScript does not permit us to rebind a name that has been bound with <code>const</code>. We can <em>shadow</em> it by using <code>const</code> to declare a new binding with a new function or block scope, but we cannot rebind a name that was bound with <code>const</code> in an existing scope.</p>

<p>This is valuable, as it greatly simplifies the analysis of programs to see at a glance that when something is bound with <code>const</code>, we need never worry that its value may change.</p>

<h3 id="named-function-expressions">Naming Functions</h3>

<p>Let’s get right to it. This code does <em>not</em> name a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">repeat</code> <code class="o">=</code> <code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">str</code> <code class="o">+</code> <code class="nx">str</code>
</pre></div>

</figure>

<p>It doesn’t name the function “repeat” for the same reason that <code>const answer = 42</code> doesn’t name the number <code>42</code>. This syntax binds an anonymous function to a name in an environment, but the function itself remains anonymous.</p>

<h4 id="leanpub-auto-the-function-keyword">the <code>function</code> keyword</h4>

<p>JavaScript <em>does</em> have a syntax for naming a function, we use the <code>function</code> keyword. Until ECMAScript 2015 was created, <code>function</code> was the usual syntax for writing functions.</p>

<p>Here’s our <code>repeat</code> function written using a “fat arrow”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">str</code> <code class="o">+</code> <code class="nx">str</code>
</pre></div>

</figure>

<p>And here’s (almost) the exact same function written using the <code>function</code> keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">str</code> <code class="o">+</code> <code class="nx">str</code> <code class="p">}</code>
</pre></div>

</figure>

<p>Let’s look at the obvious differences:</p>

<ol class="numeric">
  <li>We introduce a function with the <code>function</code> keyword.</li>
  <li>Something else we’re about to discuss is optional.</li>
  <li>We have arguments in parentheses, just like fat arrow functions.</li>
  <li>We do not have a fat arrow, we go directly to the body.</li>
  <li>We always use a block, we cannot write <code>function (str) str + str</code>. This means that if we want our functions to return a value, we always need to use the <code>return</code> keyword</li>
</ol>

<p>If we leave out the “something optional” that comes after the <code>function</code> keyword, we can translate all of the fat arrow functions that we’ve seen into <code>function</code> keyword functions, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="mf">1.618</code><code class="o">**</code><code class="nx">n</code> <code class="o">-</code> <code class="o">-</code><code class="mf">1.618</code><code class="o">**-</code><code class="nx">n</code><code class="p">)</code> <code class="o">/</code> <code class="mf">2.236</code>
</pre></div>

</figure>

<p>Can be written as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">(</code><code class="mf">1.618</code><code class="o">**</code><code class="nx">n</code> <code class="o">-</code> <code class="o">-</code><code class="mf">1.618</code><code class="o">**-</code><code class="nx">n</code><code class="p">)</code> <code class="o">/</code> <code class="mf">2.236</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This still does not <em>name</em> a function, but as we noted above, functions written with the <code>function</code> keyword have an optional “something else.” Could that “something else” name a function? Yes, of course.<sup id="fnref-ofcourse"><a href="https://leanpub.com/javascriptallongesix/read#fn-ofcourse" rel="footnote">13</a></sup></p>

<p>Here are our example functions written with names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">repeat</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">repeat</code> <code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">str</code> <code class="o">+</code> <code class="nx">str</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">fib</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fib</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">(</code><code class="mf">1.618</code><code class="o">**</code><code class="nx">n</code> <code class="o">-</code> <code class="o">-</code><code class="mf">1.618</code><code class="o">**-</code><code class="nx">n</code><code class="p">)</code> <code class="o">/</code> <code class="mf">2.236</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Placing a name between the <code>function</code> keyword and the argument list names the function. Confusingly, the name of the function is not exactly the same thing as the name we may choose to bind to the value of the function. For example, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="kr">double</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">repeat</code> <code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">str</code> <code class="o">+</code> <code class="nx">str</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In this expression, <code>double</code> is the name in the environment, but <code>repeat</code> is the function’s actual name. This is a <em>named function expression</em>. That may seem confusing, but think of the binding names as properties of the environment, not of the function. While the name of the function is a property of the function, not of the environment.</p>

<p>And indeed the name <em>is</em> a property:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">double</code><code class="p">.</code><code class="nx">name</code>
  <code class="c1">//=&gt; 'repeat'</code>
</pre></div>

</figure>

<p>In this book we are not examining JavaScript’s tooling such as debuggers baked into browsers, but we will note that when you are navigating call stacks in all modern tools, the function’s binding name is ignored but its actual name is displayed, so naming functions is very useful even if they don’t get a formal binding, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">someBackboneView</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'click'</code><code class="p">,</code> <code class="kd">function</code> <code class="nx">clickHandler</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">//...</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Now, the function’s actual name has no effect on the environment in which it is used. To whit:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">bindingName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">actualName</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">//...</code>
<code class="p">};</code>

<code class="nx">bindingName</code>
  <code class="c1">//=&gt; [Function: actualName]</code>

<code class="nx">actualName</code>
  <code class="c1">//=&gt; ReferenceError: actualName is not defined</code>
</pre></div>

</figure>

<p>So “actualName” isn’t bound in the environment where we use the named function expression. Is it bound anywhere else? Yes it is. Here’s a function that determines whether a positive integer is even or not. We’ll use it in an IIFE so that we don’t have to bind it to a name with <code>const</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="nx">even</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">return</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
<code class="p">})(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>

<code class="p">(</code><code class="kd">function</code> <code class="nx">even</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">return</code> <code class="o">!</code><code class="nx">even</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code>
<code class="p">})(</code><code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Clearly, the name <code>even</code> is bound to the function <em>within the function’s body</em>. Is it bound to the function outside of the function’s body?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">even</code>
  <code class="c1">//=&gt; Can't find variable: even</code>
</pre></div>

</figure>

<p><code>even</code> is bound within the function itself, but not outside it. This is useful for making recursive functions as we see above, and it speaks to the principle of least privilege: If you don’t <em>need</em> to name it anywhere else, you needn’t.</p>

<h4 id="function-declarations">function declarations</h4>

<p>There is another syntax for naming and/or defining a function. It’s called a <em>function declaration statement</em>, and it looks a lot like a named function expression, only we use it as a statement:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">someName</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This behaves a <em>little</em> like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">someName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">someName</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>In that it binds a name in the environment to a named function. However, there are two important differences. First, function declarations are <em>hoisted</em> to the top of the function in which they occur.</p>

<p>Consider this example where we try to use the variable <code>fizzbuzz</code> as a function before we bind a function to it with <code>const</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">fizzbuzz</code><code class="p">();</code>

  <code class="kr">const</code> <code class="nx">fizzbuzz</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fizzbuzz</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Fizz"</code> <code class="o">+</code> <code class="s2">"Buzz"</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; undefined is not a function (evaluating 'fizzbuzz()')</code>
</pre></div>

</figure>

<p>We haven’t actually bound a function to the name <code>fizzbuzz</code> before we try to use it, so we get an error. But a function <em>declaration</em> works differently:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">fizzbuzz</code><code class="p">();</code>

  <code class="kd">function</code> <code class="nx">fizzbuzz</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Fizz"</code> <code class="o">+</code> <code class="s2">"Buzz"</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; 'FizzBuzz'</code>
</pre></div>

</figure>

<p>Although <code>fizzbuzz</code> is declared later in the function, JavaScript behaves as if we’d written:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">fizzbuzz</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fizzbuzz</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Fizz"</code> <code class="o">+</code> <code class="s2">"Buzz"</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="nx">fizzbuzz</code><code class="p">();</code>
<code class="p">})()</code>
</pre></div>

</figure>

<p>The definition of the <code>fizzbuzz</code> is “hoisted” to the top of its enclosing scope (an IIFE in this case). This behaviour is intentional on the part of JavaScript’s design to facilitate a certain style of programming where you put the main logic up front, and the “helper functions” at the bottom. It is not necessary to declare functions in this way in JavaScript, but understanding the syntax and its behaviour (especially the way it differs from <code>const</code>) is essential for working with production code.</p>

<h4 id="leanpub-auto-function-declaration-caveatscaveats">function declaration caveats<sup id="fnref-caveats"><a href="https://leanpub.com/javascriptallongesix/read#fn-caveats" rel="footnote">14</a></sup>
</h4>

<p>Function declarations are formally only supposed to be made at what we might call the “top level” of a function. Although some JavaScript environments permit the following code, this example is technically illegal and definitely a bad idea:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">camelCase</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">fizzbuzz</code><code class="p">();</code>

  <code class="k">if</code> <code class="p">(</code><code class="nx">camelCase</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">function</code> <code class="nx">fizzbuzz</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="s2">"Fizz"</code> <code class="o">+</code> <code class="s2">"Buzz"</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kd">function</code> <code class="nx">fizzbuzz</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="s2">"Fizz"</code> <code class="o">+</code> <code class="s2">"Buzz"</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})(</code><code class="kc">true</code><code class="p">)</code>
  <code class="c1">//=&gt; 'FizzBuzz'? Or ERROR: Can't find variable: fizzbuzz?</code>
</pre></div>

</figure>

<p>Function declarations are not supposed to occur inside of blocks. The big trouble with expressions like this is that they may work just fine in your test environment but work a different way in production. Or it may work one way today and a different way when the JavaScript engine is updated, say with a new optimization.</p>

<p>Another caveat is that a function declaration cannot exist inside of <em>any</em> expression, otherwise it’s a function expression. So this is a function declaration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">trueDat</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code> <code class="p">}</code>
</pre></div>

</figure>

<p>But this is not:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="nx">trueDat</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code> <code class="p">})</code>
</pre></div>

</figure>

<p>The parentheses make this an expression, not a function declaration.</p>

<h3 id="combinators">Combinators and Function Decorators</h3>

<h4 id="leanpub-auto-higher-order-functions">higher-order functions</h4>

<p>As we’ve seen, JavaScript functions take values as arguments and return values. JavaScript functions are values, so JavaScript functions can take functions as arguments, return functions, or both. Generally speaking, a function that either takes functions as arguments, or returns a function, or both, is referred to as a “higher-order” function.</p>

<p>Here’s a very simple higher-order function that takes a function as an argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">repeat</code> <code class="o">=</code> <code class="p">(</code><code class="nx">num</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">num</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code>
    <code class="o">?</code> <code class="p">(</code><code class="nx">repeat</code><code class="p">(</code><code class="nx">num</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">fn</code><code class="p">),</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">num</code><code class="p">))</code>
    <code class="o">:</code> <code class="kc">undefined</code>

<code class="nx">repeat</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Hello </code><code class="si">${</code><code class="nx">n</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
<code class="p">})</code>
  <code class="c1">//=&gt;</code>
    <code class="s1">'Hello 1'</code>
    <code class="s1">'Hello 2'</code>
    <code class="s1">'Hello 3'</code>
    <code class="kc">undefined</code>
</pre></div>

</figure>

<p>Higher-order functions dominate <em>JavaScript Allongé</em>. But before we go on, we’ll talk about some specific types of higher-order functions.</p>

<h4 id="leanpub-auto-combinators">combinators</h4>

<p>The word “combinator” has a precise technical meaning in mathematics:</p>

<blockquote>
  <p>“A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.”–<a href="https://en.wikipedia.org/wiki/Combinatory_logic" title="Combinatory Logic">Wikipedia</a></p>
</blockquote>

<p>If we were learning Combinatorial Logic, we’d start with the most basic combinators like <code>S</code>, <code>K</code>, and <code>I</code>, and work up from there to practical combinators. We’d learn that the fundamental combinators are named after birds following the example of Raymond Smullyan’s famous book <a href="http://www.amazon.com/gp/product/B00A1P096Y/ref=as_li_ss_tl?ie=UTF8&amp;camp=1789&amp;creative=390957&amp;creativeASIN=B00A1P096Y&amp;linkCode=as2&amp;tag=raganwald001-20">To Mock a Mockingbird</a>.</p>

<p>In this book, we will be using a looser definition of “combinator:” Higher-order pure functions that take only functions as arguments and return a function. We won’t be strict about using only previously defined combinators in their construction.</p>

<p>Let’s start with a useful combinator: Most programmers call it <em>Compose</em>, although the logicians call it the B combinator or “Bluebird.” Here is the typical<sup id="fnref-bluebird"><a href="https://leanpub.com/javascriptallongesix/read#fn-bluebird" rel="footnote">15</a></sup> programming implementation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">c</code><code class="p">))</code>
</pre></div>

</figure>

<p>Let’s say we have:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">addOne</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">doubleOf</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
</pre></div>

</figure>

<p>With <code>compose</code>, anywhere you would write</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">doubleOfAddOne</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">doubleOf</code><code class="p">(</code><code class="nx">addOne</code><code class="p">(</code><code class="nx">number</code><code class="p">));</code>
</pre></div>

</figure>

<p>You could also write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">doubleOfAddOne</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">doubleOf</code><code class="p">,</code> <code class="nx">addOne</code><code class="p">);</code>
</pre></div>

</figure>

<p>This is, of course, just one example of many. You’ll find lots more perusing the recipes in this book. While some programmers believe “There Should Only Be One Way To Do It,” having combinators available as well as explicitly writing things out with lots of symbols and keywords has some advantages when used judiciously.</p>

<h4 id="leanpub-auto-a-balanced-statement-about-combinators">a balanced statement about combinators</h4>

<p>Code that uses a lot of combinators tends to name the verbs and adverbs (like <code>doubleOf</code>, <code>addOne</code>, and <code>compose</code>) while avoiding language keywords and the names of nouns (like <code>number</code>). So one perspective is that combinators are useful when you want to emphasize what you’re doing and how it fits together, and more explicit code is useful when you want to emphasize what you’re working with.</p>

<h4 id="decorators">function decorators</h4>

<p>A <em>function decorator</em> is a higher-order function that takes one function as an argument, returns another function, and the returned function is a variation of the argument function. Here’s a ridiculously simple  decorator:<sup id="fnref-variadic"><a href="https://leanpub.com/javascriptallongesix/read#fn-variadic" rel="footnote">16</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">not</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>
</pre></div>

</figure>

<p>So instead of writing <code>!someFunction(42)</code>, we can write <code>not(someFunction)(42)</code>. Hardly progress. But like <code>compose</code>, we could write either:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">something</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">;</code>
</pre></div>

</figure>

<p>And elsewhere, write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">nothing</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">something</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">nothing</code> <code class="o">=</code> <code class="nx">not</code><code class="p">(</code><code class="nx">something</code><code class="p">);</code>
</pre></div>

</figure>

<p><code>not</code> is a function decorator because it modifies a function while remaining strongly related to the original function’s semantics. You’ll see other function decorators in the recipes, like <a href="https://leanpub.com/javascriptallongesix/read#once">once</a> and <a href="https://leanpub.com/javascriptallongesix/read#maybe">maybe</a>. Function decorators aren’t strict about being pure functions, so there’s more latitude for making decorators than combinators.</p>

<h3 id="buildingblocks">Building Blocks</h3>

<p>When you look at functions within functions in JavaScript, there’s a bit of a “spaghetti code” look to it. The strength of JavaScript is that you can do anything. The weakness is that you will. There are ifs, fors, returns, everything thrown higgledy piggledy together. Although you needn’t restrict yourself to a small number of simple patterns, it can be helpful to understand the patterns so that you can structure your code around some basic building blocks.</p>

<h4 id="leanpub-auto-composition">composition</h4>

<p>One of the most basic of these building blocks is <em>composition</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">cookAndEat</code> <code class="o">=</code> <code class="p">(</code><code class="nx">food</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">eat</code><code class="p">(</code><code class="nx">cook</code><code class="p">(</code><code class="nx">food</code><code class="p">));</code>
</pre></div>

</figure>

<p>It’s really that simple: Whenever you are chaining two or more functions together, you’re composing them. You can compose them with explicit JavaScript code as we’ve just done. You can also generalize composition with the B Combinator or “compose” that we saw in <a href="https://leanpub.com/javascriptallongesix/read#combinators">Combinators and Decorators</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">c</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">cookAndEat</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">eat</code><code class="p">,</code> <code class="nx">cook</code><code class="p">);</code>
</pre></div>

</figure>

<p>If that was all there was to it, composition wouldn’t matter much. But like many patterns, using it when it applies is only 20% of the benefit. The other 80% comes from organizing your code such that you can use it: Writing functions that can be composed in various ways.</p>

<p>In the recipes, we’ll look at a decorator called  <a href="https://leanpub.com/javascriptallongesix/read#once">once</a>: It ensures that a function can only be executed once. Thereafter, it does nothing. Once is useful for ensuring that certain side effects are not repeated. We’ll also look at <a href="https://leanpub.com/javascriptallongesix/read#maybe">maybe</a>: It ensures that a function does nothing if it is given nothing (like <code>null</code> or <code>undefined</code>) as an argument.</p>

<p>Of course, you needn’t use combinators to implement either of these ideas, you can use if statements. But <code>once</code> and <code>maybe</code> compose, so you can chain them together as you see fit:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">actuallyTransfer</code><code class="o">=</code> <code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">,</code> <code class="nx">amount</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="c1">// do something</code>

<code class="kr">const</code> <code class="nx">invokeTransfer</code> <code class="o">=</code> <code class="nx">once</code><code class="p">(</code><code class="nx">maybe</code><code class="p">(</code><code class="nx">actuallyTransfer</code><code class="p">(...)));</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-partial-application">partial application</h4>

<p>Another basic building block is <em>partial application</em>. When a function takes multiple arguments, we “apply” the function to the arguments by evaluating it with all of the arguments, producing a value. But what if we only supply some of the arguments? In that case, we can’t get the final value, but we can get a function that represents <em>part</em> of our application.</p>

<p>Code is easier than words for this. The <a href="http://underscorejs.org/">Underscore</a> library provides a higher-order function called <em>map</em>.<sup id="fnref-headache"><a href="https://leanpub.com/javascriptallongesix/read#fn-headache" rel="footnote">17</a></sup> It applies another function to each element of an array, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">)</code>
  <code class="c1">//=&gt; [1, 4, 9]</code>
</pre></div>

</figure>

<p>We don’t want to fool around writing <code>_.</code>, so we can use it by writing:<sup id="fnref-_map"><a href="https://leanpub.com/javascriptallongesix/read#fn-_map" rel="footnote">18</a></sup></p>

<p>This code implements a partial application of the map function by applying the function <code>(n) =&gt; n * n</code> as its second argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squareAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code>  <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>
</pre></div>

</figure>

<p>The resulting function–<code>squareAll</code>–is still the map function, it’s just that we’ve applied one of its two arguments already. <code>squareAll</code> is nice, but why write one function every time we want to partially apply a function to a map? We can abstract this one level higher. <code>mapWith</code> takes any function as an argument and returns a partially applied map function.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="nx">fn</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">squareAll</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>

<code class="nx">squareAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
  <code class="c1">//=&gt; [1, 4, 9]</code>
</pre></div>

</figure>

<p>We’ll discuss <code>mapWith</code> again. The important thing to see is that partial application is orthogonal to composition, and that they both work together nicely:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">safeSquareAll</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">maybe</code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">));</code>

<code class="nx">safeSquareAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
  <code class="c1">//=&gt; [1, null, 4, 9]</code>
</pre></div>

</figure>

<p>We generalized composition with the <code>compose</code> combinator. Partial application also has a combinator, which we’ll see in the <a href="https://leanpub.com/javascriptallongesix/read#partial">partial</a> recipe.</p>

<h3 id="magic-names">Magic Names</h3>

<p>When a function is applied to arguments (or “called”), JavaScript binds the values of arguments to the function’s argument names in an environment created for the function’s execution. What we haven’t discussed so far is that JavaScript also binds values to some “magic” names in addition to any you put in the argument list.<sup id="fnref-read-only"><a href="https://leanpub.com/javascriptallongesix/read#fn-read-only" rel="footnote">19</a></sup></p>

<h4 id="leanpub-auto-the-function-keyword-1">the function keyword</h4>

<p>There are two separate rules for these “magic” names, one for when you invoke a function using the <code>function</code> keyword, and another for functions defined with “fat arrows.” We’ll begin with how things work for functions defined with the <code>function</code> keyword.</p>

<p>The first magic name is  <code>this</code>, and it is bound to something called the function’s <a href="https://leanpub.com/javascriptallongesix/read#context">context</a>. We will explore <code>this</code> in more detail when we start discussing objects and classes. The second magic name is very interesting, it’s called <code>arguments</code>, and the most interesting thing about it is that it contains a list of arguments passed to a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">plus</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
<code class="p">}</code>

<code class="nx">plus</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<p>Although <code>arguments</code> looks like an array, it isn’t an array: It’s more like an object<sup id="fnref-pojo"><a href="https://leanpub.com/javascriptallongesix/read#fn-pojo" rel="footnote">20</a></sup> that happens to bind some values to properties with names that look like integers starting with zero:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">args</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">arguments</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">args</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; { '0': 2, '1': 3 }</code>
</pre></div>

</figure>

<p><code>arguments</code> always contains all of the arguments passed to a function, regardless of how many are declared. Therefore, we can write <code>plus</code> like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">plus</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
<code class="p">}</code>

<code class="nx">plus</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<p>When discussing objects, we’ll discuss properties in more depth. Here’s something interesting about <code>arguments</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">howMany</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">arguments</code><code class="p">[</code><code class="s1">'length'</code><code class="p">];</code>
<code class="p">}</code>

<code class="nx">howMany</code><code class="p">()</code>
  <code class="c1">//=&gt; 0</code>

<code class="nx">howMany</code><code class="p">(</code><code class="s1">'hello'</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">howMany</code><code class="p">(</code><code class="s1">'sharks'</code><code class="p">,</code> <code class="s1">'are'</code><code class="p">,</code> <code class="s1">'apex'</code><code class="p">,</code> <code class="s1">'predators'</code><code class="p">)</code>
  <code class="c1">//=&gt; 4</code>
</pre></div>

</figure>

<p>The most common use of the <code>arguments</code> binding is to build functions that can take a variable number of arguments. We’ll see it used in many of the recipes, starting off with <a href="https://leanpub.com/javascriptallongesix/read#simple-partial">partial application</a> and <a href="https://leanpub.com/javascriptallongesix/read#ellipses">ellipses</a>.</p>

<h4 id="leanpub-auto-magic-names-and-fat-arrows">magic names and fat arrows</h4>

<p>The magic names <code>this</code> and <code>arguments</code> have a different behaviour when you invoke a function that was defined with a fat arrow: Instead of being bound when the function is invoked, the fat arrow function always acquires the bindings for <code>this</code> and <code>arguments</code> from its enclosing scope, just like any other binding.</p>

<p>For example, when this expression’s inner function is defined with <code>function</code>, <code>arguments[0]</code> refers to its only argument, <code>"inner"</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">})(</code><code class="s1">'inner'</code><code class="p">);</code>
<code class="p">})(</code><code class="s1">'outer'</code><code class="p">)</code>
  <code class="c1">//=&gt; "inner"</code>
</pre></div>

</figure>

<p>But if we use a fat arrow, <code>arguments</code> will be defined in the outer environment, the one defined with <code>function</code>. And thus <code>arguments[0]</code> will refer to <code>"outer"</code>, not to <code>"inner"</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">])(</code><code class="s1">'inner'</code><code class="p">);</code>
<code class="p">})(</code><code class="s1">'outer'</code><code class="p">)</code>
  <code class="c1">//=&gt; "outer"</code>
</pre></div>

</figure>

<p>Although it seems quixotic for the two syntaxes to have different semantics, it makes sense when you consider the design goal: Fat arrow functions are designed to be very lightweight and are often used with constructs like mapping or callbacks to emulate syntax.</p>

<p>To give a contrived example, this function takes a number and returns an array representing a row in a hypothetical multiplication table. It uses <code>mapWith</code>, which we discussed in <a href="https://leanpub.com/javascriptallongesix/read#buildingblocks">Building Blocks</a>.<sup id="fnref-mapWith"><a href="https://leanpub.com/javascriptallongesix/read#fn-mapWith" rel="footnote">21</a></sup> We’ll use <code>arguments</code> just to show the difference between using a fat arrow and the function keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">mapWith</code><code class="p">(</code>
    <code class="p">(</code><code class="nx">column</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">column</code> <code class="o">*</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">]</code>
  <code class="p">)</code>
<code class="p">}</code>

<code class="nx">row</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; [3,6,9,12,15,18,21,24,27,30,33,36]</code>
</pre></div>

</figure>

<p>This works just fine, because <code>arguments[0]</code> refers to the <code>3</code> we passed to the function <code>row</code>. Our “fat arrow” function <code>(column) =&gt; column * arguments[0]</code> doesn’t bind <code>arguments</code> when it’s invoked. But if we rewrite <code>row</code> to use the <code>function</code> keyword, it stops working:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">mapWith</code><code class="p">(</code>
    <code class="kd">function</code> <code class="p">(</code><code class="nx">column</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">column</code> <code class="o">*</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="p">},</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">]</code>
  <code class="p">)</code>
<code class="p">}</code>

<code class="nx">row</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; [1,4,9,16,25,36,49,64,81,100,121,144]</code>
</pre></div>

</figure>

<p>Now our inner function binds <code>arguments[0]</code> every time it is invoked, so we get the same result as if we’d written
<code>function (column) { return column * column }</code>.</p>

<p>Although this example is clearly unrealistic, there is a general design principle that deserves attention. Sometimes, a function is meant to be used as a Big-F function. It has a name, it is called by different pieces of code, it’s a first-class entity in the code.</p>

<p>But sometimes, a function is a small-f function. It’s a simple representation of an expression to be computed. In our example above, <code>row</code> is a Big-F function, but <code>(column) =&gt; column * arguments[0]</code> is a small-f function, it exists just to give <code>mapWith</code> something to apply.</p>

<p>Having magic variables apply to Big-F functions but not to small-G functions makes it much easier to use small-F functions as syntax, treating them as expressions or blocks that can be passed to functions like <code>mapWith</code>.</p>

<h3 id="leanpub-auto-summary">Summary</h3>

<aside class="tip blurb">
    <h4 id="leanpub-auto-functions">Functions</h4>

  <ul>
    <li>Functions are values that can be part of expressions, returned from other functions, and so forth.</li>
    <li>Functions are <em>reference values</em>.</li>
    <li>Functions are applied to arguments.</li>
    <li>The arguments are passed by sharing, which is also called “pass by value.”</li>
    <li>Fat arrow functions have expressions or blocks as their bodies.</li>
    <li>
<code>function</code> keyword functions always have blocks as their bodies.</li>
    <li>Function bodies have zero or more statements.</li>
    <li>Expression bodies evaluate to the value of the expression.</li>
    <li>Block bodies evaluate to whatever is returned with the <code>return</code> keyword, or to <code>undefined</code>.</li>
    <li>JavaScript uses <code>const</code> to bind values to names within block scope.</li>
    <li>JavaScript uses function declarations to bind functions to names within function scope. Function declarations are “hoisted.”</li>
    <li>Function application creates a scope.</li>
    <li>Blocks also create scopes if <code>const</code> statements are within them.</li>
    <li>Scopes are nested and free variable references closed over.</li>
    <li>Variables can shadow variables in an enclosing scope.</li>
  </ul>

</aside>

<div class="footnotes">
  <ol>
    <li id="fn-simplest">The simplest possible function is <code>() =&gt; {}</code>, we’ll see that later.<a href="https://leanpub.com/javascriptallongesix/read#fnref-simplest" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ambiguous">If you’re used to other programming languages, you’ve probably internalized the idea that sometimes parentheses are used to group operations in an expression like math, and sometimes to apply a function to arguments. If not… Welcome to the <a href="https://en.wikipedia.org/wiki/ALGOL">ALGOL</a> family of programming languages!<a href="https://leanpub.com/javascriptallongesix/read#fnref-ambiguous" rel="rev-footnote">↩</a>
</li>
    <li id="fn-asi">Sometimes, you will find JavaScript that has statements that are separated by newlines without semi-colons. This works because JavaScript has a feature that can infer where the semi-colons should be most of the time. We will not take advantage of this feature, but it’s helpful to know it exists.<a href="https://leanpub.com/javascriptallongesix/read#fnref-asi" rel="rev-footnote">↩</a>
</li>
    <li id="fn-fourth">Experienced JavaScript programmers are aware that there’s a fourth way, using a function argument. This was actually the preferred mechanism until <code>void</code> became commonplace.<a href="https://leanpub.com/javascriptallongesix/read#fnref-fourth" rel="rev-footnote">↩</a>
</li>
    <li id="fn-void">As an exercise for the reader, we suggest you ask your friendly neighbourhood programming language designer or human factors subject-matter expert to explain why a keyword called <code>void</code> is used to generate an <code>undefined</code> value, instead of calling them both <code>void</code> or both <code>undefined</code>. We have no idea.<a href="https://leanpub.com/javascriptallongesix/read#fnref-void" rel="rev-footnote">↩</a>
</li>
    <li id="fn-break">You can also separate statements with line breaks. Readers who follow internet flame-fests may be aware of something called <a href="http://lucumr.pocoo.org/2011/2/6/automatic-semicolon-insertion/">automatic semi-colon insertion</a>. Basically, there’s a step where JavaScript looks at your code and follows some rules to guess where you meant to put semicolons in should you leave them out. This feature was originally created as a kind of helpful error-correction. Some programmers argue that since it’s part of the language’s definition, it’s fair game to write code that exploits it, so they deliberately omit any semicolon that JavaScript will insert for them.<a href="https://leanpub.com/javascriptallongesix/read#fnref-break" rel="rev-footnote">↩</a>
</li>
    <li id="fn-mp">Abuse of this feature by extending the behaviour of built-in classes is a controversial topic.<a href="https://leanpub.com/javascriptallongesix/read#fnref-mp" rel="rev-footnote">↩</a>
</li>
    <li id="fn-f2f">We said that you can’t apply a function to an expression. You <em>can</em> apply a function to one or more functions. Functions are values! This has interesting applications, and they will be explored much more thoroughly in <a href="https://leanpub.com/javascriptallongesix/read#consumers">Functions That Are Applied to Functions</a>.<a href="https://leanpub.com/javascriptallongesix/read#fnref-f2f" rel="rev-footnote">↩</a>
</li>
    <li id="fn-NaNPedantry">Unless the argument is <code>NaN</code>, which isn’t equal to anything, <em>including itself</em>. <code>NaN</code> in JavaScript behaves a lot like <code>NULL</code> in SQL.<a href="https://leanpub.com/javascriptallongesix/read#fnref-NaNPedantry" rel="rev-footnote">↩</a>
</li>
    <li id="fn-nonlocal">You may also hear the term “non-local variable.” <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables">Both are correct.</a> <a href="https://leanpub.com/javascriptallongesix/read#fnref-nonlocal" rel="rev-footnote">↩</a>
</li>
    <li id="fn-explain-iife">JavaScript programmers regularly use the idea of writing an expression that denotes a function and then immediately applying it to arguments. Explaining the pattern, Ben Alman coined the term [Immediately Invoked Function Expression][iife] for it, often abbreviated “IIFE.”<a href="https://leanpub.com/javascriptallongesix/read#fnref-explain-iife" rel="rev-footnote">↩</a>
</li>
    <li id="fn-namedfn">We’re into the second chapter and we’ve finally named a function. Sheesh.<a href="https://leanpub.com/javascriptallongesix/read#fnref-namedfn" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ofcourse">“Yes of course?” Well, in chapter of a book dedicated to naming functions, it is not surprising that feature we mention has something to do with naming functions.<a href="https://leanpub.com/javascriptallongesix/read#fnref-ofcourse" rel="rev-footnote">↩</a>
</li>
    <li id="fn-caveats">A number of the caveats discussed here were described in Jyrly Zaytsev’s excellent article <a href="http://kangax.github.com/nfe/">Named function expressions demystified</a>.<a href="https://leanpub.com/javascriptallongesix/read#fnref-caveats" rel="rev-footnote">↩</a>
</li>
    <li id="fn-bluebird">As we’ll discuss later, this implementation of the B Combinator is correct in languages like Scheme, but for truly general-purpose use in JavaScript, it needs to correctly manage the <a href="https://leanpub.com/javascriptallongesix/read#context">function context</a>.<a href="https://leanpub.com/javascriptallongesix/read#fnref-bluebird" rel="rev-footnote">↩</a>
</li>
    <li id="fn-variadic">We’ll see later why an even more useful version would be written <code>(fn) =&gt; (...args) =&gt; !fn(...args)</code><a href="https://leanpub.com/javascriptallongesix/read#fnref-variadic" rel="rev-footnote">↩</a>
</li>
    <li id="fn-headache">Modern JavaScript implementations provide a map method for arrays, but Underscore’s implementation also works with older browsers if you are working with that headache.<a href="https://leanpub.com/javascriptallongesix/read#fnref-headache" rel="rev-footnote">↩</a>
</li>
    <li id="fn-_map">If we don’t want to sort out <a href="http://underscorejs.org/">Underscore</a>, we can also write the following: <code>const map = (a, fn) =&gt; a.map(fn);</code>, and trust that it works even though we haven’t discussed methods yet.
      <p>const map = _.map;<a href="https://leanpub.com/javascriptallongesix/read#fnref-_map" rel="rev-footnote">↩</a></p>
    </li>
    <li id="fn-read-only">You should never attempt to define your own bindings against “magic” names that JavaScript binds for you. It is wise to treat them as read-only at all times.<a href="https://leanpub.com/javascriptallongesix/read#fnref-read-only" rel="rev-footnote">↩</a>
</li>
    <li id="fn-pojo">We’ll look at <a href="https://leanpub.com/javascriptallongesix/read#arrays">arrays</a> and <a href="https://leanpub.com/javascriptallongesix/read#pojos">plain old javascript objects</a> in depth later.<a href="https://leanpub.com/javascriptallongesix/read#fnref-pojo" rel="rev-footnote">↩</a>
</li>
    <li id="fn-mapWith">Yes, we also used the name <code>mapWith</code> for working with ordinary collections elsewhere. If we were writing a library of functions, we would have to disambiguate the two kinds of mapping functions with special names, namespaces, or modules. But for the purposes of discussing ideas, we can use the same name twice in two different contexts. It’s the same idea, after all.<a href="https://leanpub.com/javascriptallongesix/read#fnref-mapWith" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-recipes-with-basic-functions">Recipes with Basic Functions</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/mirage.jpg" alt="Before combining ingredients, begin with implements so clean, they gleam.">
  <figcaption>Before combining ingredients, begin with implements so clean, they gleam.</figcaption>
</figure>


<p>Having looked at basic pure functions and closures, we’re going to see some practical recipes that focus on the premise of functions that return functions.</p>

<h4 id="leanpub-auto-disclaimer">Disclaimer</h4>

<p>The recipes are written for practicality, and their implementation may introduce JavaScript features that haven’t been discussed in the text to this point, such as methods and/or prototypes. The overall <em>use</em> of each recipe will fit within the spirit of the language discussed so far, even if the implementations may not.</p>

<h3 id="simple-partial">Partial Application</h3>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#buildingblocks">Building Blocks</a>, we discussed partial application, but we didn’t write a generalized recipe for it. This is such a common tool that many libraries provide some form of partial application. You’ll find examples in <a href="https://github.com/fogus/lemonad">Lemonad</a> from Michael Fogus, <a href="http://osteele.com/sources/javascript/functional/">Functional JavaScript</a> from Oliver Steele and the terse but handy <a href="https://github.com/substack/node-ap">node-ap</a> from James Halliday.</p>

<p>These two recipes are for quickly and simply applying a single argument, either the leftmost or rightmost.<sup id="fnref-inspired"><a href="https://leanpub.com/javascriptallongesix/read#fn-inspired" rel="footnote">1</a></sup> If you want to bind more than one argument, or you want to leave a “hole” in the argument list, you will need to either use a <a href="https://leanpub.com/javascriptallongesix/read#partial">generalized partial recipe</a>, or you will need to repeatedly apply arguments. They are <a href="https://leanpub.com/javascriptallongesix/read#context">context</a>-agnostic.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callFirst</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">larg</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">larg</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">callLast</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rarg</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">rarg</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">greet</code> <code class="o">=</code> <code class="p">(</code><code class="nx">me</code><code class="p">,</code> <code class="nx">you</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="sb">`Hello, </code><code class="si">${</code><code class="nx">you</code><code class="si">}</code><code class="sb">, my name is </code><code class="si">${</code><code class="nx">me</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
  
<code class="kr">const</code> <code class="nx">heliosSaysHello</code> <code class="o">=</code> <code class="nx">callFirst</code><code class="p">(</code><code class="nx">greet</code><code class="p">,</code> <code class="s1">'Helios'</code><code class="p">);</code>

<code class="nx">heliosSaysHello</code><code class="p">(</code><code class="s1">'Eartha'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello, Eartha, my name is Helios'</code>
  
<code class="kr">const</code> <code class="nx">sayHelloToCeline</code> <code class="o">=</code> <code class="nx">callLast</code><code class="p">(</code><code class="nx">greet</code><code class="p">,</code> <code class="s1">'Celine'</code><code class="p">);</code>

<code class="nx">sayHelloToCeline</code><code class="p">(</code><code class="s1">'Eartha'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello, Celine, my name is Eartha'</code>
</pre></div>

</figure>

<p>As noted above, our partial recipe allows us to create functions that are partial applications of functions that are context aware. We’d need a different recipe if we wish to create partial applications of object methods.</p>

<p>We take it a step further, and can use gathering and spreading to allow for partial application with more than one argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callLeft</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">,</code> <code class="p">...</code><code class="nx">remainingArgs</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">callRight</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>
</pre></div>

</figure>

<h3 id="leanpub-auto-unary">Unary</h3>

<p>“Unary” is a function decorator that modifies the number of arguments a function takes: Unary takes any function and turns it into a function taking exactly one argument.</p>

<p>The most common use case is to fix a problem. JavaScript has a <code>.map</code> method for arrays, and many libraries offer a <code>map</code> function with the same semantics. Here it is in action:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="s1">'1'</code><code class="p">,</code> <code class="s1">'2'</code><code class="p">,</code> <code class="s1">'3'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nb">parseFloat</code><code class="p">)</code>
  <code class="c1">//=&gt; [1, 2, 3]</code>
</pre></div>

</figure>

<p>In that example, it looks exactly like the mapping function you’ll find in most languages: You pass it a function, and it calls the function with one argument, the element of the array. However, that’s not the whole story. JavaScript’s <code>map</code> actually calls each function with <em>three</em> arguments: The element, the index of the element in the array, and the array itself.</p>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">element</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">({</code><code class="nx">element</code><code class="o">:</code> <code class="nx">element</code><code class="p">,</code> <code class="nx">index</code><code class="o">:</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">arr</code><code class="o">:</code> <code class="nx">arr</code><code class="p">})</code>
<code class="p">})</code>
  <code class="c1">//=&gt; { element: 1, index: 0, arr: [ 1, 2, 3 ] }</code>
  <code class="c1">//   { element: 2, index: 1, arr: [ 1, 2, 3 ] }</code>
  <code class="c1">//   { element: 3, index: 2, arr: [ 1, 2, 3 ] }</code>
</pre></div>

</figure>

<p>If you pass in a function taking only one argument, it simply ignores the additional arguments. But some functions have optional second or even third arguments. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="s1">'1'</code><code class="p">,</code> <code class="s1">'2'</code><code class="p">,</code> <code class="s1">'3'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">)</code>
  <code class="c1">//=&gt; [1, NaN, NaN]</code>
</pre></div>

</figure>

<p>This doesn’t work because <code>parseInt</code> is defined as <code>parseInt(string[, radix])</code>. It takes an optional radix argument. And when you call <code>parseInt</code> with <code>map</code>, the index is interpreted as a radix. Not good! What we want is to convert <code>parseInt</code> into a function taking only one argument.</p>

<p>We could write <code>['1', '2', '3'].map((s) =&gt; parseInt(s))</code>, or we could come up with a decorator to do the job for us:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">unary</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">1</code>
    <code class="o">?</code> <code class="nx">fn</code>
    <code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">something</code><code class="p">)</code>
      <code class="p">}</code>
</pre></div>

</figure>

<p>And now we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="s1">'1'</code><code class="p">,</code> <code class="s1">'2'</code><code class="p">,</code> <code class="s1">'3'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">unary</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">))</code>
  <code class="c1">//=&gt; [1, 2, 3]</code>
</pre></div>

</figure>

<p>Presto!</p>

<h3 id="tap">Tap</h3>

<p>One of the most basic combinators is the “K Combinator,” nicknamed the “Kestrel:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">K</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>
</pre></div>

</figure>

<p>It has some surprising applications. One is when you want to do something with a value for side-effects, but keep the value around. Behold:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">tap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>
    <code class="k">typeof</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">===</code> <code class="s1">'function'</code> <code class="o">&amp;&amp;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">),</code>
    <code class="nx">value</code>
  <code class="p">)</code>
</pre></div>

</figure>

<p><code>tap</code> is a traditional name borrowed from various Unix shell commands. It takes a value and returns a function that always returns the value, but if you pass it a function, it executes the function for side-effects. Let’s see it in action as a poor-man’s debugger:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">tap</code><code class="p">(</code><code class="s1">'espresso'</code><code class="p">)((</code><code class="nx">it</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Our drink is '</code><code class="si">${</code><code class="nx">it</code><code class="si">}</code><code class="sb">'`</code><code class="p">)</code> 
<code class="p">});</code>
<code class="c1">//=&gt; Our drink is 'espresso'</code>
     <code class="s1">'espresso'</code>
</pre></div>

</figure>

<p>It’s easy to turn off:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">tap</code><code class="p">(</code><code class="s1">'espresso'</code><code class="p">)();</code>
  <code class="c1">//=&gt; 'espresso'</code>
</pre></div>

</figure>

<p>Libraries like <a href="http://underscorejs.org/">Underscore</a> use a version of <code>tap</code> that is “uncurried:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">_</code><code class="p">.</code><code class="nx">tap</code><code class="p">(</code><code class="s1">'espresso'</code><code class="p">,</code> <code class="p">(</code><code class="nx">it</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Our drink is '</code><code class="si">${</code><code class="nx">it</code><code class="si">}</code><code class="sb">'`</code><code class="p">)</code> 
<code class="p">);</code>
  <code class="c1">//=&gt; Our drink is 'espresso'</code>
       <code class="s1">'espresso'</code>
</pre></div>

</figure>

<p>Let’s enhance our recipe so that it works both ways:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">tap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">curried</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>
      <code class="k">typeof</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">===</code> <code class="s1">'function'</code> <code class="o">&amp;&amp;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">),</code>
      <code class="nx">value</code>
    <code class="p">);</code>
  
  <code class="k">return</code> <code class="nx">fn</code> <code class="o">===</code> <code class="kc">undefined</code>
         <code class="o">?</code> <code class="nx">curried</code>
         <code class="o">:</code> <code class="nx">curried</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Now we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">tap</code><code class="p">(</code><code class="s1">'espresso'</code><code class="p">)((</code><code class="nx">it</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Our drink is '</code><code class="si">${</code><code class="nx">it</code><code class="si">}</code><code class="sb">'`</code><code class="p">)</code> 
<code class="p">});</code>
<code class="c1">//=&gt; Our drink is 'espresso'</code>
     <code class="s1">'espresso'</code>
</pre></div>

</figure>

<p>Or:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">tap</code><code class="p">(</code><code class="s1">'espresso'</code><code class="p">,</code> <code class="p">(</code><code class="nx">it</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Our drink is '</code><code class="si">${</code><code class="nx">it</code><code class="si">}</code><code class="sb">'`</code><code class="p">)</code> 
<code class="p">});</code>
<code class="c1">//=&gt; Our drink is 'espresso'</code>
     <code class="s1">'espresso'</code>
</pre></div>

</figure>

<p>And if we wish it to do nothing at all, We can write either <code>tap('espresso')()</code> or <code>tap('espresso', null)</code></p>

<p>p.s. <code>tap</code> can do more than just act as a debugging aid. It’s also useful for working with <a href="https://leanpub.com/javascriptallongesix/read#tap-methods">object and instance methods</a>.</p>

<h3 id="maybe">Maybe</h3>

<p>A common problem in programming is checking for <code>null</code> or <code>undefined</code> (hereafter called “nothing,” while all other values including <code>0</code>, <code>[]</code> and <code>false</code> will be called “something”). Languages like JavaScript do not strongly enforce the notion that a particular variable or particular property be something, so programs are often written to account for values that may be nothing.</p>

<p>This recipe concerns a pattern that is very common: A function <code>fn</code> takes a value as a parameter, and its behaviour by design is to do nothing if the parameter is nothing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">isSomething</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">value</code> <code class="o">!==</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="nx">value</code> <code class="o">!==</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">checksForSomething</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">isSomething</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code> <code class="p">{</code>
    <code class="c1">// function's true logic</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Alternately, the function may be intended to work with any value, but the code calling the function wishes to emulate the behaviour of doing nothing by design when given nothing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">something</code> <code class="o">=</code>
  <code class="nx">isSomething</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>
    <code class="o">?</code> <code class="nx">doesntCheckForSomething</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">value</code><code class="p">;</code>
</pre></div>

</figure>

<p>Naturally, there’s a function decorator recipe for that, borrowed from Haskell’s <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad">maybe monad</a>, Ruby’s <a href="https://github.com/raganwald/andand">andand</a>, and CoffeeScript’s existential method invocation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">arg</code> <code class="k">of</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">arg</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p><code>maybe</code> reduces the logic of checking for nothing to a function call:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">maybe</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">)(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>

<code class="nx">maybe</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">c</code><code class="p">)(</code><code class="mi">1</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>As a bonus, <code>maybe</code> plays very nicely with instance methods, we’ll discuss those <a href="https://leanpub.com/javascriptallongesix/read#classes">later</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Model</code> <code class="p">()</code> <code class="p">{};</code>

<code class="nx">Model</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setSomething</code> <code class="o">=</code> <code class="nx">maybe</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">something</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>If some code ever tries to call <code>model.setSomething</code> with nothing, the operation will be skipped.</p>

<h3 id="leanpub-auto-once">Once</h3>

<p><code>once</code> is an extremely helpful combinator. It ensures that a function can only be called, well, <em>once</em>. Here’s the recipe:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">done</code> <code class="o">?</code> <code class="k">void</code> <code class="mi">0</code> <code class="o">:</code> <code class="p">((</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">),</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">))</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Very simple! You pass it a function, and you get a function back. That function will call your function once, and thereafter will return <code>undefined</code> whenever it is called. Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">askedOnBlindDate</code> <code class="o">=</code> <code class="nx">once</code><code class="p">(</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"sure, why not?"</code>
<code class="p">);</code>

<code class="nx">askedOnBlindDate</code><code class="p">()</code>
  <code class="c1">//=&gt; 'sure, why not?'</code>

<code class="nx">askedOnBlindDate</code><code class="p">()</code>
  <code class="c1">//=&gt; undefined</code>

<code class="nx">askedOnBlindDate</code><code class="p">()</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>It seems some people will only try blind dating once.</p>

<p>(Note: There are some subtleties with decorators like <code>once</code> that involve the intersection of state with methods. We’ll look at that again in <a href="https://leanpub.com/javascriptallongesix/read#stateful-method-decorators">stateful method decorators</a>.)</p>

<h3 id="leanpub-auto-left-variadic-functions">Left-Variadic Functions</h3>

<p>A <em>variadic function</em> is a function that is designed to accept a variable number of arguments.<sup id="fnref-eng"><a href="https://leanpub.com/javascriptallongesix/read#fn-eng" rel="footnote">2</a></sup> In JavaScript, you can make a variadic function by gathering parameters. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">abccc</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="p">...</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code>
<code class="p">};</code>

<code class="nx">abccc</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">]</code>
</pre></div>

</figure>

<p>This can be useful when writing certain kinds of destructuring algorithms. For example, we might want to have a function that builds some kind of team record. It accepts a coach, a captain, and an arbitrary number of players. Easy in ECMAScript 2015:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">team</code><code class="p">(</code><code class="nx">coach</code><code class="p">,</code> <code class="nx">captain</code><code class="p">,</code> <code class="p">...</code><code class="nx">players</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">captain</code><code class="si">}</code><code class="sb"> (captain)`</code><code class="p">);</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">player</code> <code class="k">of</code> <code class="nx">players</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">player</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`squad coached by </code><code class="si">${</code><code class="nx">coach</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">team</code><code class="p">(</code><code class="s1">'Luis Enrique'</code><code class="p">,</code> <code class="s1">'Xavi Hernández'</code><code class="p">,</code> <code class="s1">'Marc-André ter Stegen'</code><code class="p">,</code>
     <code class="s1">'Martín Montoya'</code><code class="p">,</code> <code class="s1">'Gerard Piqué'</code><code class="p">)</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">Xavi</code> <code class="nx">Hernández</code> <code class="p">(</code><code class="nx">captain</code><code class="p">)</code>
    <code class="nx">Marc</code><code class="o">-</code><code class="nx">André</code> <code class="nx">ter</code> <code class="nx">Stegen</code>
    <code class="nx">Martín</code> <code class="nx">Montoya</code>
    <code class="nx">Gerard</code> <code class="nx">Piqué</code>
    <code class="nx">squad</code> <code class="nx">coached</code> <code class="nx">by</code> <code class="nx">Luis</code> <code class="nx">Enrique</code>
</pre></div>

</figure>

<p>But we can’t go the other way around:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">team2</code><code class="p">(...</code><code class="nx">players</code><code class="p">,</code> <code class="nx">captain</code><code class="p">,</code> <code class="nx">coach</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">captain</code><code class="si">}</code><code class="sb"> (captain)`</code><code class="p">);</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">player</code> <code class="k">of</code> <code class="nx">players</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">player</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`squad coached by </code><code class="si">${</code><code class="nx">coach</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt; Unexpected token</code>
</pre></div>

</figure>

<p>ECMAScript 2015 only permits gathering parameters from the <em>end</em> of the parameter list. Not the beginning. What to do?</p>

<h4 id="leanpub-auto-a-history-lesson">a history lesson</h4>

<p>In “Ye Olde Days,”<sup id="fnref-ye"><a href="https://leanpub.com/javascriptallongesix/read#fn-ye" rel="footnote">3</a></sup> JavaScript could not gather parameters, and we had to either do backflips with <code>arguments</code> and <code>.slice</code>, or we wrote ourselves a <code>variadic</code> decorator that could gather arguments into the last declared parameter. Here it is in all of its ECMAScript-5 glory:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">__slice</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">rightVariadic</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="mi">1</code><code class="p">)</code> <code class="k">return</code> <code class="nx">fn</code><code class="p">;</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">ordinaryArgs</code> <code class="o">=</code> <code class="p">(</code><code class="mi">1</code> <code class="o">&lt;=</code> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code> <code class="o">?</code>
          <code class="nx">__slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">arguments</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code> <code class="o">:</code> <code class="p">[]),</code>
        <code class="nx">restOfTheArgsList</code> <code class="o">=</code> <code class="nx">__slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">arguments</code><code class="p">,</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">),</code>
        <code class="nx">args</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;=</code> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code> <code class="o">?</code>
          <code class="nx">ordinaryArgs</code><code class="p">.</code><code class="nx">concat</code><code class="p">([</code><code class="nx">restOfTheArgsList</code><code class="p">])</code> <code class="o">:</code> <code class="p">[]);</code>

    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="nx">firstAndButFirst</code> <code class="o">=</code> <code class="nx">rightVariadic</code><code class="p">(</code><code class="kd">function</code> <code class="nx">test</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">butFirst</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">butFirst</code><code class="p">]</code>
<code class="p">});</code>

<code class="nx">firstAndButFirst</code><code class="p">(</code><code class="s1">'why'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid'</code><code class="p">)</code>
  <code class="c1">//=&gt; ["why",["hello","there","little","droid"]]</code>
</pre></div>

</figure>

<p>We don’t need <code>rightVariadic</code> any more, because instead of:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">firstAndButFirst</code> <code class="o">=</code> <code class="nx">rightVariadic</code><code class="p">(</code>
  <code class="kd">function</code> <code class="nx">test</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">butFirst</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">butFirst</code><code class="p">]</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>We now simply write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstAndButFirst</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">butFirst</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">butFirst</code><code class="p">];</code>
</pre></div>

</figure>

<p>This is a <em>right-variadic function</em>, meaning that it has one or more fixed arguments, and the rest are gathered into the rightmost argument.</p>

<h4 id="leanpub-auto-overcoming-limitations">overcoming limitations</h4>

<p>It’s nice to have progress. But as noted above, we can’t write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">butLastAndLast</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">[</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">];</code>
</pre></div>

</figure>

<p>That’s a <em>left-variadic function</em>. All left-variadic functions have one or more fixed arguments, and the rest are gathered into the leftmost argument. JavaScript doesn’t do this. But if we wanted to write left-variadic functions, could we make ourselves a <code>leftVariadic</code> decorator to turn a function with one or more arguments into a left-variadic function?</p>

<p>We sure can, by using the techniques from <code>rightVariadic</code>. Mind you, we can take advantage of modern JavaScript to simplify the code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">leftVariadic</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">gathered</code> <code class="o">=</code> <code class="nx">args</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>
            <code class="nx">spread</code>   <code class="o">=</code> <code class="nx">args</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>

      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code>
        <code class="k">this</code><code class="p">,</code> <code class="p">[</code><code class="nx">gathered</code><code class="p">].</code><code class="nx">concat</code><code class="p">(</code><code class="nx">spread</code><code class="p">)</code>
      <code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">butLastAndLast</code> <code class="o">=</code> <code class="nx">leftVariadic</code><code class="p">((</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">]);</code>

<code class="nx">butLastAndLast</code><code class="p">(</code><code class="s1">'why'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid'</code><code class="p">)</code>
  <code class="c1">//=&gt; [["why","hello","there","little"],"droid"]</code>
</pre></div>

</figure>

<p>Our <code>leftVariadic</code> function is a decorator that turns any function into a function that gathers parameters <em>from the left</em>, instead of from the right.</p>

<h4 id="leanpub-auto-left-variadic-destructuring">left-variadic destructuring</h4>

<p>Gathering arguments for functions is one of the ways JavaScript can <em>destructure</em> arrays. Another way is when assigning variables, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">butFirst</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'why'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid'</code><code class="p">];</code>

<code class="nx">first</code>
  <code class="c1">//=&gt; 'why'</code>
<code class="nx">butFirst</code>
  <code class="c1">//=&gt; ["hello","there","little","droid"]</code>
</pre></div>

</figure>

<p>As with parameters, we can’t gather values from the left when destructuring an array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[...</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'why'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid'</code><code class="p">];</code>
  <code class="c1">//=&gt; Unexpected token</code>
</pre></div>

</figure>

<p>We could use <code>leftVariadic</code> the hard way:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="nx">leftVariadic</code><code class="p">((</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">])(...[</code><code class="s1">'wh\</code>
<code class="s1">y'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid'</code><code class="p">]);</code>

<code class="nx">butLast</code>
  <code class="c1">//=&gt; ['why', 'hello', 'there', 'little']</code>

<code class="nx">last</code>
  <code class="c1">//=&gt; 'droid'</code>
</pre></div>

</figure>

<p>But we can write our own left-gathering function utility using the same principles without all the tedium:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">leftGather</code> <code class="o">=</code> <code class="p">(</code><code class="nx">outputArrayLength</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">inputArray</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">inputArray</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nx">inputArray</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="nx">outputArrayLength</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)].</code><code class="nx">conc</code><code class="o">\</code>
<code class="nx">at</code><code class="p">(</code>
      <code class="nx">inputArray</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="nx">inputArray</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="nx">outputArrayLength</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code>
    <code class="p">)</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="nx">leftGather</code><code class="p">(</code><code class="mi">2</code><code class="p">)([</code><code class="s1">'why'</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="s1">'there'</code><code class="p">,</code> <code class="s1">'little'</code><code class="p">,</code> <code class="s1">'droid\</code>
<code class="s1">'</code><code class="p">]);</code>

<code class="nx">butLast</code>
  <code class="c1">//=&gt; ['why', 'hello', 'there', 'little']</code>

<code class="nx">last</code>
  <code class="c1">//=&gt; 'droid'</code>
</pre></div>

</figure>

<p>With <code>leftGather</code>, we have to supply the length of the array we wish to use as the result, and it gathers excess arguments into it from the left, just like <code>leftVariadic</code> gathers excess parameters for a function.</p>

<h3 id="leanpub-auto-compose-and-pipeline">Compose and Pipeline</h3>

<p>Here is the B Combinator, or <code>compose</code> that we saw in <a href="https://leanpub.com/javascriptallongesix/read#combinators">Combinators and Decorators</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">c</code><code class="p">))</code>
</pre></div>

</figure>

<p>As we saw before, given:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">addOne</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">doubleOf</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
</pre></div>

</figure>

<p>Instead of:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">doubleOfAddOne</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">doubleOf</code><code class="p">(</code><code class="nx">addOne</code><code class="p">(</code><code class="nx">number</code><code class="p">));</code>
</pre></div>

</figure>

<p>We could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">doubleOfAddOne</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">doubleOf</code><code class="p">,</code> <code class="nx">addOne</code><code class="p">);</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-variadic-compose-and-recursion">variadic compose and recursion</h4>

<p>If we wanted to implement a <code>compose3</code>, we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">d</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">c</code><code class="p">(</code><code class="nx">d</code><code class="p">)))</code>
</pre></div>

</figure>

<p>Or observe that it is really:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">a</code><code class="p">(</code><code class="nx">compose</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)))</code>
</pre></div>

</figure>

<p>Once we get to <code>compose4</code>, we ask ourselves if there is a better way. For example, if we had a <em>variadic</em> compose, we could write <code>compose(a, b)</code>, <code>compose(a, b, c)</code>, or <code>compose(a, b, c, d)</code>.</p>

<p>We can implement a variadic <code>compose</code> recursively. The easiest way to reason about writing a recursive <code>compose</code> is to start with the smallest or <em>degenerate</em> case. If <code>compose</code> only took one argument, it would look like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code>
</pre></div>

</figure>

<p>The next thing is to have a way of breaking a piece off the problem. We can do this with a variadic function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="s2">"to be determined"</code>
</pre></div>

</figure>

<p>We can test whether we have the degenerate case:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">rest</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">a</code>
    <code class="o">:</code> <code class="s2">"to be determined"</code>
</pre></div>

</figure>

<p>If it is not the degenerate case, we need to combine what we have with the solution for the rest. In other words, we need to combine <code>fn</code> with <code>compose(...rest)</code>. How do we do that? Well, consider <code>compose(a, b)</code>. We know that <code>compose(b)</code> is the degenerate case, it’s just <code>b</code>. And we know that <code>compose(a, b)</code> is <code>(c) =&gt; a(b(c))</code>.</p>

<p>So let’s substitute <code>compose(b)</code> for <code>b</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">compose</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">b</code><code class="p">))</code> <code class="o">===</code> <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">compose</code><code class="p">(</code><code class="nx">b</code><code class="p">)(</code><code class="nx">c</code><code class="p">))</code>
</pre></div>

</figure>

<p>Now substitute <code>...rest</code> for <code>b</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">compose</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="o">===</code> <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">compose</code><code class="p">(...</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">c</code><code class="p">))</code>
</pre></div>

</figure>

<p>This is our solution:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">rest</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">a</code>
    <code class="o">:</code> <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">compose</code><code class="p">(...</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">c</code><code class="p">))</code>
</pre></div>

</figure>

<p>There are others, of course. <code>compose</code> can be implemented with iteration or with <code>.reduce</code>, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">fns</code><code class="p">.</code><code class="nx">reverse</code><code class="p">().</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">acc</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">acc</code><code class="p">),</code> <code class="nx">value</code><code class="p">);</code>
</pre></div>

</figure>

<p>But the principle behaviour is the same: To compose a series of functions together, creating a new one. And the value is the same: We can write smaller, single purpose functions and put them together in different ways.</p>

<h4 id="leanpub-auto-the-semantics-of-compose">the semantics of compose</h4>

<p>With <code>compose</code>, we’re usually making a new function. Although it works perfectly well, we don’t need to write things like <code>compose(double, addOne)(3)</code> inline to get the result <code>8</code>. It’s easier and clearer to write <code>double(addOne(3))</code>.</p>

<p>On the other hand, when working with something like method decorators, it can help to write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">setter</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">fluent</code><code class="p">,</code> <code class="nx">maybe</code><code class="p">);</code>

<code class="c1">// ...</code>

<code class="nx">SomeClass</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setUser</code> <code class="o">=</code> <code class="nx">setter</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">user</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="nx">user</code><code class="p">;</code>
<code class="p">});</code>

<code class="nx">SomeClass</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setPrivileges</code> <code class="o">=</code> <code class="nx">setter</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">privileges</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">privileges</code> <code class="o">=</code> <code class="nx">privileges</code><code class="p">;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This makes it clear that <code>setter</code> adds the behaviour of both <code>fluent</code> and <code>maybe</code> to each method it decorates, and it’s sometimes easier to read <code>const setter = compose(fluent, maybe);</code> than:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">setter</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">maybe</code><code class="p">(</code><code class="nx">fn</code><code class="p">));</code>
</pre></div>

</figure>

<p>The take-away is that <code>compose</code> is helpful when we are defining a new function that combines the effects of existing functions.</p>

<h4 id="pipeline">pipeline</h4>

<p><code>compose</code> is extremely handy, but one thing it doesn’t communicate well is the order on operations. <code>compose</code> is written that way because it matches the way explicitly composing functions works in JavaScript and most other languages: When you write a(b(…)), <code>a</code> happens after <code>b</code>.</p>

<p>Sometimes it makes more sense to compose functions in data flow order, as in “The value flows through a and then through b.” For this, we can use the <code>pipeline</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">pipeline</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">fns</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">acc</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">acc</code><code class="p">),</code> <code class="nx">value</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">setter</code> <code class="o">=</code> <code class="nx">pipeline</code><code class="p">(</code><code class="nx">addOne</code><code class="p">,</code> <code class="kr">double</code><code class="p">);</code>
</pre></div>

</figure>

<p>Comparing <code>pipeline</code> to <code>compose</code>, pipeline says “add one to the number and then double it.” Compose says, “double the result of adding one to the number.” Both do the same job, but communicate their intention in opposite ways.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/saltspring----rollers.jpg" alt="Saltspring Island Roasting Facility">
  <figcaption>Saltspring Island Roasting Facility</figcaption>
</figure>


<div class="footnotes">
  <ol>
    <li id="fn-inspired">
<code>callFirst</code> and <code>callLast</code> were inspired by Michael Fogus’ <a href="https://github.com/fogus/lemonad">Lemonad</a>. Thanks!<a href="https://leanpub.com/javascriptallongesix/read#fnref-inspired" rel="rev-footnote">↩</a>
</li>
    <li id="fn-eng">English is about as inconsistent as JavaScript: Functions with a fixed number of arguments can be unary, binary, ternary, and so forth. But can they be “variary?” No! They have to be “variadic.”<a href="https://leanpub.com/javascriptallongesix/read#fnref-eng" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ye">Another history lesson. “Ye” in “Ye Olde,” was not actually spelled with a “Y” in days of old, it was spelled with a <a href="https://en.wikipedia.org/wiki/Thorn_(letter)">thorn</a>, and is pronounced “the.” Another word, “Ye” in “Ye of little programming faith,” is pronounced “ye,” but it’s a different word altogether.<a href="https://leanpub.com/javascriptallongesix/read#fnref-ye" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-picking-the-bean-choice-and-truthiness">Picking the Bean: Choice and Truthiness</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/antidote.jpg" alt="Decaf and the Antidote">
  <figcaption>Decaf and the Antidote</figcaption>
</figure>


<p>We’ve seen operators that act on numeric values, like <code>+</code> and <code>%</code>. In addition to numbers, we often need to represent a much more basic idea of truth or falsehood. Is this array empty? Does this person have a middle name? Is this user logged in?</p>

<p>JavaScript does have “boolean” values, they’re written <code>true</code> and <code>false</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">true</code>
  <code class="c1">//=&gt; true</code>

<code class="kc">false</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p><code>true</code> and <code>false</code> are value types. All values of <code>true</code> are <code>===</code> all other values of true. We can see that is the case by looking at some operators we can perform on boolean values, <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code>. To being with, <code>!</code> is a unary prefix operator that negates its argument. So:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">!</code><code class="kc">true</code>
  <code class="c1">//=&gt; false</code>

<code class="o">!</code><code class="kc">false</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>The <code>&amp;&amp;</code> and <code>||</code> operators are binary infix operators that perform “logical and” and “logical or” respectively:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">false</code> <code class="o">&amp;&amp;</code> <code class="kc">false</code> <code class="c1">//=&gt; false</code>
<code class="kc">false</code> <code class="o">&amp;&amp;</code> <code class="kc">true</code>  <code class="c1">//=&gt; false</code>
<code class="kc">true</code>  <code class="o">&amp;&amp;</code> <code class="kc">false</code> <code class="c1">//=&gt; false</code>
<code class="kc">true</code>  <code class="o">&amp;&amp;</code> <code class="kc">true</code>  <code class="c1">//=&gt; true</code>

<code class="kc">false</code> <code class="o">||</code> <code class="kc">false</code> <code class="c1">//=&gt; false</code>
<code class="kc">false</code> <code class="o">||</code> <code class="kc">true</code>  <code class="c1">//=&gt; true</code>
<code class="kc">true</code>  <code class="o">||</code> <code class="kc">false</code> <code class="c1">//=&gt; true</code>
<code class="kc">true</code>  <code class="o">||</code> <code class="kc">true</code>  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Now, note well: We have said what happens if you pass boolean values to <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code>, but we’ve said nothing about expressions or about passing other values. We’ll look at those presently.</p>

<h4 id="leanpub-auto-truthiness-and-the-ternary-operator">truthiness and the ternary operator</h4>

<p>In JavaScript, there is a notion of “truthiness.” Every value is either “truthy” or “falsy.” Obviously, <code>false</code> is falsy. So are <code>null</code> and <code>undefined</code>, values that semantically represent “no value.” <code>NaN</code> is falsy, a value representing the result of a calculation that is not a number.<sup id="fnref-NaN"><a href="https://leanpub.com/javascriptallongesix/read#fn-NaN" rel="footnote">1</a></sup> And there are more: <code>0</code> is falsy, a value representing “none of something.” The empty string, <code>''</code> is falsy, a value representing having no characters.</p>

<p>Every other value in JavaScript is “truthy” except the aforementioned <code>false</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>0</code>, and <code>''</code>. (Many other languages that have a notion of truthiness consider zero and the empty string to be truthy, not falsy, so beware of blindly transliterating code from one language to another!)</p>

<p>The reason why truthiness matters is that the various logical operators (as well as the if statement) actually operate on <em>truthiness</em>, not on boolean values. This affects the way the <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> operators work. We’ll look at them in a moment, but first, we’ll look at one more operator.</p>

<p>JavaScript inherited an operator from the C family of languages, the <em>ternary</em> operator. It’s the only operator that takes <em>three</em> arguments. It looks like this: <code>first ? second : third</code>. It evaluates <code>first</code>, and if <code>first</code> is “truthy”, it evaluates <code>second</code> and that is its value. If <code>first</code> is not truthy, it evaluates <code>third</code> and that is its value.</p>

<p>This is a lot like the <code>if</code> statement, however it is an <em>expression</em>, not a statement, and that can be very valuable. It also doesn’t introduce braces, and that can be a help or a hindrance if we want to introduce a new scope or use statements.</p>

<p>Here’re some simple examples of the ternary operator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kc">true</code> <code class="o">?</code> <code class="s1">'Hello'</code> <code class="o">:</code> <code class="s1">'Good bye'</code>
  <code class="c1">//=&gt; 'Hello'</code>

<code class="mi">0</code> <code class="o">?</code> <code class="s1">'Hello'</code> <code class="o">:</code> <code class="s1">'Good bye'</code>
  <code class="c1">//=&gt; 'Good bye'</code>

<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">5</code> <code class="o">?</code> <code class="s1">'Pentatonic'</code> <code class="o">:</code> <code class="s1">'Quasimodal'</code>
  <code class="c1">//=&gt; 'Pentatonic'</code>
</pre></div>

</figure>

<p>The fact that either the second or the third (but not both) expressions are evaluated can have important repercussions. Consider this hypothetical example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">status</code> <code class="o">=</code> <code class="nx">isAuthorized</code><code class="p">(</code><code class="nx">currentUser</code><code class="p">)</code> <code class="o">?</code> <code class="nx">deleteRecord</code><code class="p">(</code><code class="nx">currentRecord</code><code class="p">)</code> <code class="o">:</code> <code class="s1">'Forbid\</code>
<code class="s1">den'</code><code class="p">;</code>
</pre></div>

</figure>

<p>We certainly don’t want JavaScript trying to evaluate <code>deleteRecord(currentRecord)</code> unless <code>isAuthorized(currentUser)</code> returns <code>true</code>.</p>

<h4 id="leanpub-auto-truthiness-and-operators">truthiness and operators</h4>

<p>Our logical operators <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> are a little more subtle than our examples above implied. <code>!</code> is the simplest. It always returns <code>false</code> if its argument is truthy, and <code>true</code> is its argument is not truthy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="o">!</code><code class="mi">5</code>
  <code class="c1">//=&gt; false</code>

<code class="o">!</code><code class="kc">undefined</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Programmers often take advantage of this behaviour to observe that <code>!!(someExpression)</code> will always evaluate to <code>true</code> is <code>someExpression</code> is truthy, and to <code>false</code> if it is not. So in JavaScript (and other languages with similar semantics), when you see something like <code>!!currentUser()</code>, this is an idiom that means “true if currentUser is truthy.” Thus, a function like <code>currentUser()</code> is free to return <code>null</code>, or <code>undefined</code>, or <code>false</code> if there is no current user.</p>

<p>Thus, <code>!!</code> is the way we write “is truthy” in JavaScript. How about <code>&amp;&amp;</code> and <code>||</code>? What haven’t we discussed?</p>

<p>First, and unlike <code>!</code>, <code>&amp;&amp;</code> and <code>||</code> do not necessarily evaluate to <code>true</code> or <code>false</code>. To be precise:</p>

<ul>
  <li>
<code>&amp;&amp;</code> evaluates its left-hand expression.
    <ul>
      <li>If its left-hand expression evaluates to something falsy, <code>&amp;&amp;</code> returns the value of its left-hand expression without evaluating its right-hand expression.</li>
      <li>If its left-hand expression evaluates to something truthy, <code>&amp;&amp;</code> evaluates its right-hand expression and returns the value of the right-hand expression.</li>
    </ul>
  </li>
  <li>
<code>||</code> evaluates its left-hand expression.
    <ul>
      <li>If its left-hand expression evaluates to something truthy, <code>||</code> returns the value of its left-hand expression without evaluating its right-hand expression.</li>
      <li>If its left-hand expression evaluates to something false, <code>||</code> evaluates its right-hand expression and returns the value of the right-hand expression.</li>
    </ul>
  </li>
</ul>

<p>If we look at our examples above, we see that when we pass <code>true</code> and <code>false</code> to <code>&amp;&amp;</code> and <code>||</code>, we do indeed get <code>true</code> or <code>false</code> as a result. But when we pass other values, we no longer get <code>true</code> or <code>false</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">1</code> <code class="o">||</code> <code class="mi">2</code>
  <code class="c1">//=&gt; 1</code>

<code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="kc">undefined</code>
  <code class="c1">//=&gt; null</code>

<code class="kc">undefined</code> <code class="o">&amp;&amp;</code> <code class="kc">null</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>In JavaScript, <code>&amp;&amp;</code> and <code>||</code> aren’t boolean logical operators in the logical sense. They don’t operate strictly on logical values, and they don’t commute: <code>a || b</code> is not always equal to <code>b || a</code>, and the same goes for <code>&amp;&amp;</code>.</p>

<p>This is not a subtle distinction.</p>

<h4 id="leanpub-auto-and--are-control-flow-operators">
<code>||</code> and <code>&amp;&amp;</code> are control-flow operators</h4>

<p>We’ve seen the ternary operator: It is a <em>control-flow</em> operator, not a logical operator. The same is true of <code>&amp;&amp;</code> and <code>||</code>. Consider this <a href="https://leanpub.com/javascriptallongesix/read#tail">tail-recursive</a> function that determines whether a positive integer is even:</p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code> <code class="o">||</code> <code class="p">(</code><code class="nx">n</code> <code class="o">!==</code> <code class="mi">1</code> <code class="o">&amp;&amp;</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">))</code>

<code class="nx">even</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>If <code>n === 0</code>, JavaScript does not evaluate <code>(n !== 1 &amp;&amp; even(n - 2))</code>. This is very important! Imagine that JavaScript evaluated both sides of the <code>||</code> operator before determining its value. <code>n === 0</code> would be true. What about <code>(n !== 1 &amp;&amp; even(n - 2))</code>? Well, it would evaluate <code>even(n - 2)</code>, or <code>even(-2)</code></p>

<p>This leads us to evaluate <code>n === 0 || (n !== 1 &amp;&amp; even(n - 2))</code> all over again, and this time we end up evaluating <code>even(-4)</code>. And then <code>even(-6)</code>. and so on and so forth until JavaScript throws up its hands and runs out of stack space.</p>

<p>But that’s not what happens. <code>||</code> and <code>&amp;&amp;</code> have <em>short-cut semantics</em>. In this case, if <code>n === 0</code>, JavaScript does not evaluate <code>(n !== 1 &amp;&amp; even(n - 2))</code>. Likewise, if <code>n === 1</code>, JavaScript evaluates <code>n !== 1 &amp;&amp; even(n - 2)</code> as <code>false</code> without ever evaluating <code>even(n - 2)</code>.</p>

<p>This is more than just an optimization. It’s best to think of <code>||</code> and <code>&amp;&amp;</code> as control-flow operators. The expression on the left is always evaluated, and its value determines whether the expression on the right is evaluated or not.</p>

<h4 id="leanpub-auto-function-parameters-are-eager">function parameters are eager</h4>

<p>In contrast to the behaviour of the ternary operator, <code>||</code>, and <code>&amp;&amp;</code>, function parameters are always <em>eagerly evaluated</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">or</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">||</code> <code class="nx">b</code>

<code class="kr">const</code> <code class="nx">and</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">&amp;&amp;</code> <code class="nx">b</code>

<code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">or</code><code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">and</code><code class="p">(</code><code class="nx">n</code> <code class="o">!==</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">)))</code>

<code class="nx">even</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
  <code class="c1">//=&gt; Maximum call stack size exceeded.</code>
</pre></div>

</figure>

<p>Now our expression <code>or(n === 0, and(n !== 1, even(n - 2)))</code> is calling functions, and JavaScript always evaluates the expressions for parameters before passing the values to a function to invoke. This leads to the infinite recursion we fear.</p>

<p>If we need to have functions with control-flow semantics, we can pass anonymous functions. We obviously don’t need anything like this for <code>or</code> and <code>and</code>, but to demonstrate the technique:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">or</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">()</code> <code class="o">||</code> <code class="nx">b</code><code class="p">()</code>

<code class="kr">const</code> <code class="nx">and</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">()</code> <code class="o">&amp;&amp;</code> <code class="nx">b</code><code class="p">()</code>

<code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">or</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">and</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">!==</code> <code class="mi">1</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">even</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">)))</code>

<code class="nx">even</code><code class="p">(</code><code class="mi">7</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Here we’ve passed functions that contain the expressions we want to evaluate, and now we can write our own functions that can delay evaluation.</p>

<h4 id="leanpub-auto-summary-1">summary</h4>

<ul>
  <li>Logical operators are based on truthiness and falsiness, not the strict values <code>true</code> and <code>false</code>.</li>
  <li>
<code>!</code> is a logical operator, it always returns <code>true</code> or <code>false</code>.</li>
  <li>The ternary operator (<code>?:</code>), <code>||</code>, and <code>&amp;&amp;</code> are control flow operators, they do not always return <code>true</code> or <code>false</code>, and they have short-cut semantics.</li>
  <li>Function invocation uses eager evaluation, so if we need to roll our own control-flow semantics, we pass it functions, not expressions.</li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn-NaN">We will not discuss JavaScript’s numeric behaviour in much depth in this book, but the most important thing to know is that it implements the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point"> IEEE Standard for Floating-Point Arithmetic (IEEE 754)</a>, a technical standard for floating-point computation established in 1985 by the Institute of Electrical and Electronics Engineers (IEEE).<a href="https://leanpub.com/javascriptallongesix/read#fnref-NaN" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="composing-data">Composing and Decomposing Data</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/stacked-cups.jpg" alt="Stacked Cups">
  <figcaption>Stacked Cups</figcaption>
</figure>


<blockquote>
  <p>Recursion is the root of computation since it trades description for time.—Alan Perlis, <a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Epigrams in Programming</a></p>
</blockquote>

<h3 id="arraysanddestructuring">Arrays and Destructuring Arguments</h3>

<p>While we have mentioned arrays briefly, we haven’t had a close look at them. Arrays are JavaScript’s “native” representation of lists. Strings are important because they represent writing. Lists are important because they represent ordered collections of things, and ordered collections are a fundamental abstraction for making sense of reality.</p>

<h4 id="leanpub-auto-array-literals">array literals</h4>

<p>JavaScript has a literal syntax for creating an array: The <code>[</code> and <code>]</code> characters. We can create an empty array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[]</code>
  <code class="c1">//=&gt; []</code>
</pre></div>

</figure>

<p>We can create an array with one or more <em>elements</em> by placing them between the brackets and separating the items with commas. Whitespace is optional:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
  <code class="c1">//=&gt; [1]</code>

<code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]</code>
  <code class="c1">//=&gt; [2,3,4]</code>
</pre></div>

</figure>

<p>Any expression will work:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code> <code class="mi">2</code><code class="p">,</code>
  <code class="mi">3</code><code class="p">,</code>
  <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code>
<code class="p">]</code>
  <code class="c1">//=&gt; [2,3,4]</code>
</pre></div>

</figure>

<p>Including an expression denoting another array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[[[[[]]]]]</code>
</pre></div>

</figure>

<p>This is an array with one element that is an array with one element that is an array with one element that is an array with one element that is an empty array. Although that seems like something nobody would ever construct, many students have worked with almost the exact same thing when they explored various means of constructing arithmetic from Set Theory.</p>

<p>Any expression will do, including names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">something</code><code class="p">];</code>

<code class="nx">wrap</code><code class="p">(</code><code class="s2">"lunch"</code><code class="p">)</code>
  <code class="c1">//=&gt; ["lunch"]</code>
</pre></div>

</figure>

<p>Array literals are expressions, and arrays are <em>reference types</em>. We can see that each time an array literal is evaluated, we get a new, distinct array, even if it contains the exact same elements:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[]</code> <code class="o">===</code> <code class="p">[]</code>
  <code class="c1">//=&gt; false</code>

<code class="p">[</code><code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">]</code> <code class="o">===</code> <code class="p">[</code><code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">]</code>
  <code class="c1">//=&gt; false</code>

<code class="kr">const</code> <code class="nx">array_of_one</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="mi">1</code><code class="p">];</code>

<code class="nx">array_of_one</code><code class="p">()</code> <code class="o">===</code> <code class="nx">array_of_one</code><code class="p">()</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-element-references">element references</h4>

<p>Array elements can be extracted using <code>[</code> and <code>]</code> as postfix operators. We pass an integer as an index of the element to extract:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"one"</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">];</code>

<code class="nx">oneTwoThree</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
  <code class="c1">//=&gt; 'one'</code>

<code class="nx">oneTwoThree</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
  <code class="c1">//=&gt; 'two'</code>

<code class="nx">oneTwoThree</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>
  <code class="c1">//=&gt; 'three'</code>
</pre></div>

</figure>

<p>As we can see, JavaScript Arrays are <a href="https://en.wikipedia.org/wiki/Zero-based_numbering">zero-based</a>.</p>

<p>We know that every array is its own unique entity, with its own unique reference. What about the contents of an array? Does it store references to the things we give it? Or copies of some kind?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">[],</code>
      <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="nx">x</code><code class="p">];</code>

<code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">===</code> <code class="nx">x</code>
  <code class="c1">//=&gt; true, arrays store references to the things you put in them.</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-destructuring-arrays">destructuring arrays</h4>

<p>There is another way to extract elements from arrays: <em>Destructuring</em>, a feature going back to Common Lisp, if not before. We saw how to construct an array literal using <code>[</code>, expressions, <code>,</code> and <code>]</code>. Here’s an example of an array literal that uses a name:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">something</code><code class="p">];</code>
</pre></div>

</figure>

<p>Let’s expand it to use a block and an extra name:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">wrapped</code> <code class="o">=</code> <code class="p">[</code><code class="nx">something</code><code class="p">];</code>

  <code class="k">return</code> <code class="nx">wrapped</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">wrap</code><code class="p">(</code><code class="s2">"package"</code><code class="p">)</code>
  <code class="c1">//=&gt; ["package"]</code>
</pre></div>

</figure>

<p>The line <code>const wrapped = [something];</code> is interesting. On the left hand is a name to be bound, and on the right hand is an array literal, a template for constructing an array, very much like a quasi-literal string.</p>

<p>In JavaScript, we can actually <em>reverse</em> the statement and place the template on the left and a value on the right:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">unwrap</code> <code class="o">=</code> <code class="p">(</code><code class="nx">wrapped</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[</code><code class="nx">something</code><code class="p">]</code> <code class="o">=</code> <code class="nx">wrapped</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">something</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">unwrap</code><code class="p">([</code><code class="s2">"present"</code><code class="p">])</code>
  <code class="c1">//=&gt; "present"</code>
</pre></div>

</figure>

<p>The statement <code>const [something] = wrapped;</code> <em>destructures</em> the array represented by <code>wrapped</code>, binding the value of its single element to the name <code>something</code>. We can do the same thing with more than one element:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">surname</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">last</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">surname</code><code class="p">([</code><code class="s2">"Reginald"</code><code class="p">,</code> <code class="s2">"Braithwaite"</code><code class="p">])</code>
  <code class="c1">//=&gt; "Braithwaite"</code>
</pre></div>

</figure>

<p>We could do the same thing with <code>(name) =&gt; name[1]</code>, but destructuring is code that resembles the data it consumes, a valuable coding style.</p>

<p>Destructuring can nest:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">description</code> <code class="o">=</code> <code class="p">(</code><code class="nx">nameAndOccupation</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">],</code> <code class="nx">occupation</code><code class="p">]</code> <code class="o">=</code> <code class="nx">nameAndOccupation</code><code class="p">;</code>

  <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> is a </code><code class="si">${</code><code class="nx">occupation</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">description</code><code class="p">([[</code><code class="s2">"Reginald"</code><code class="p">,</code> <code class="s2">"Braithwaite"</code><code class="p">],</code> <code class="s2">"programmer"</code><code class="p">])</code>
  <code class="c1">//=&gt; "Reginald is a programmer"</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-gathering">gathering</h4>

<p>Sometimes we need to extract arrays from arrays. Here is the most common pattern: Extracting the head and gathering everything but the head from an array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">car</code><code class="p">,</code> <code class="p">...</code><code class="nx">cdr</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>

<code class="nx">car</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">cdr</code>
  <code class="c1">//=&gt; [2, 3, 4, 5]</code>
</pre></div>

</figure>

<p><a href="https://en.wikipedia.org/wiki/CAR_and_CDR"><code>car</code> and <code>cdr</code></a> are archaic terms that go back to an implementation of Lisp running on the IBM 704 computer. Some other languages call them <code>first</code> and <code>butFirst</code>, or <code>head</code> and <code>tail</code>. We will use a common convention and call variables we gather <code>rest</code>, but refer to the <code>...</code> operation as a “gather,” following Kyle Simpson’s example.<sup id="fnref-getify"><a href="https://leanpub.com/javascriptallongesix/read#fn-getify" rel="footnote">1</a></sup></p>

<p>Alas, the <code>...</code> notation does not provide a universal patten-matching capability. For example, we cannot write</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[...</code><code class="nx">butLast</code><code class="p">,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
  <code class="c1">//=&gt; ERROR</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...,</code> <code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
  <code class="c1">//=&gt; ERROR</code>
</pre></div>

</figure>

<p>Now, when we introduced destructuring, we saw that it is kind-of-sort-of the reverse of array literals. So if</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapped</code> <code class="o">=</code> <code class="p">[</code><code class="nx">something</code><code class="p">];</code>
</pre></div>

</figure>

<p>Then:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">unwrapped</code><code class="p">]</code> <code class="o">=</code> <code class="nx">something</code><code class="p">;</code>
</pre></div>

</figure>

<p>What is the reverse of gathering? We know that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">car</code><code class="p">,</code> <code class="p">...</code><code class="nx">cdr</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>
</pre></div>

</figure>

<p>What is the reverse? It would be:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">cons</code> <code class="o">=</code> <code class="p">[</code><code class="nx">car</code><code class="p">,</code> <code class="p">...</code><code class="nx">cdr</code><code class="p">];</code>
</pre></div>

</figure>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"one"</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">];</code>

<code class="p">[</code><code class="s2">"zero"</code><code class="p">,</code> <code class="p">...</code><code class="nx">oneTwoThree</code><code class="p">]</code>
  <code class="c1">//=&gt; ["zero","one","two","three"]</code>
</pre></div>

</figure>

<p>It works! We can use <code>...</code> to place the elements of an array inside another array. We say that using <code>...</code> to destructure is gathering, and using it in a literal to insert elements is called “spreading.”</p>

<h4 id="leanpub-auto-destructuring-is-not-pattern-matching">destructuring is not pattern matching</h4>

<p>Some other languages have something called <em>pattern matching</em>, where you can write something like a destructuring assignment, and the language decides whether the “patterns” matches at all. If it does, assignments are made where appropriate.</p>

<p>In such a language, if you wrote something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">what</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
</pre></div>

</figure>

<p>That match would fail because the array doesn’t have an element to assign to <code>what</code>. But this is not how JavaScript works. JavaScript tries its best to assign things, and if there isn’t something that fits, JavaScript binds <code>undefined</code> to the name. Therefore:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">what</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nx">what</code>
  <code class="c1">//=&gt; undefined</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">which</code><code class="p">,</code> <code class="nx">what</code><code class="p">,</code> <code class="nx">who</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"duck feet"</code><code class="p">,</code> <code class="s2">"tiger tail"</code><code class="p">];</code>

<code class="nx">who</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>And if there aren’t any items to assign with <code>...</code>, JavaScript assigns an empty array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[...</code><code class="nx">they</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nx">they</code>
  <code class="c1">//=&gt; []</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">which</code><code class="p">,</code> <code class="nx">what</code><code class="p">,</code> <code class="p">...</code><code class="nx">they</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"duck feet"</code><code class="p">,</code> <code class="s2">"tiger tail"</code><code class="p">];</code>

<code class="nx">they</code>
  <code class="c1">//=&gt; []</code>
</pre></div>

</figure>

<p>From its very inception, JavaScript has striven to avoid catastrophic errors. As a result, it often coerces values, passes <code>undefined</code> around, or does whatever it can to keep executing without failing. This often means that we must write our own code to detect failure conditions, as we cannot reply on the language to point out when we are doing semantically meaningless things.</p>

<h4 id="leanpub-auto-destructuring-and-return-values">destructuring and return values</h4>

<p>Some languages support multiple return values: A function can return several things at once, like a value and an error code. This can easily be emulated in JavaScript with destructuring:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">description</code> <code class="o">=</code> <code class="p">(</code><code class="nx">nameAndOccupation</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">nameAndOccupation</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="s2">""</code><code class="p">,</code> <code class="s2">"occupation missing"</code><code class="p">]</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">[[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">],</code> <code class="nx">occupation</code><code class="p">]</code> <code class="o">=</code> <code class="nx">nameAndOccupation</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">[</code><code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> is a </code><code class="si">${</code><code class="nx">occupation</code><code class="si">}</code><code class="sb">`</code><code class="p">,</code> <code class="s2">"ok"</code><code class="p">];</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">reg</code><code class="p">,</code> <code class="nx">status</code><code class="p">]</code> <code class="o">=</code> <code class="nx">description</code><code class="p">([[</code><code class="s2">"Reginald"</code><code class="p">,</code> <code class="s2">"Braithwaite"</code><code class="p">],</code> <code class="s2">"programmer"</code><code class="p">]);</code>

<code class="nx">reg</code>
  <code class="c1">//=&gt; "Reginald is a programmer"</code>

<code class="nx">status</code>
   <code class="c1">//=&gt; "ok"</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-destructuring-parameters">destructuring parameters</h4>

<p>Consider the way we pass arguments to parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">foo</code><code class="p">()</code>
<code class="nx">bar</code><code class="p">(</code><code class="s2">"smaug"</code><code class="p">)</code>
<code class="nx">baz</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>
</pre></div>

</figure>

<p>It is very much like an array literal. And consider how we bind values to parameter names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">...</code>
<code class="kr">const</code> <code class="nx">bar</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">...</code>
<code class="kr">const</code> <code class="nx">baz</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">...</code>
</pre></div>

</figure>

<p>It <em>looks</em> like destructuring. It acts like destructuring. There is only one difference: We have not tried gathering. Let’s do that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">nums</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">nums</code><code class="p">;</code>

<code class="nx">numbers</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; [1,2,3,4,5]</code>

<code class="kr">const</code> <code class="nx">headAndTail</code> <code class="o">=</code> <code class="p">(</code><code class="nx">head</code><code class="p">,</code> <code class="p">...</code><code class="nx">tail</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">head</code><code class="p">,</code> <code class="nx">tail</code><code class="p">];</code>

<code class="nx">headAndTail</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; [1,[2,3,4,5]]</code>
</pre></div>

</figure>

<p>Gathering works with parameters! This is very useful indeed, and we’ll see more of it in a moment.<sup id="fnref-rest"><a href="https://leanpub.com/javascriptallongesix/read#fn-rest" rel="footnote">2</a></sup></p>

<h3 id="linear-recursion">Self-Similarity</h3>

<blockquote>
  <p>Recursion is the root of computation since it trades description for time.—Alan Perlis, <a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Epigrams in Programming</a></p>
</blockquote>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#arraysanddestructuring">Arrays and Destructuring Arguments</a>, we worked with the basic idea that putting an array together with a literal array expression was the reverse or opposite of taking it apart with a destructuring assignment.</p>

<p>We saw that the basic idea that putting an array together with a literal array expression was the reverse or opposite of taking it apart with a destructuring assignment.</p>

<p>Let’s be more specific. Some data structures, like lists, can obviously be seen as a collection of items. Some are empty, some have three items, some forty-two, some contain numbers, some contain strings, some a mixture of elements, there are all kinds of lists.</p>

<p>But we can also define a list by describing a rule for building lists. One of the simplest, and longest-standing in computer science, is to say that a list is:</p>

<ol class="numeric">
  <li>Empty, or;</li>
  <li>Consists of an element concatenated with a list .</li>
</ol>

<p>Let’s convert our rules to array literals. The first rule is simple: <code>[]</code> is a list. How about the second rule? We can express that using a spread. Given an element <code>e</code> and a list <code>list</code>, <code>[e, ...list]</code> is a list. We can test this manually by building up a list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[]</code>
<code class="c1">//=&gt; []</code>

<code class="p">[</code><code class="s2">"baz"</code><code class="p">,</code> <code class="p">...[]]</code>
<code class="c1">//=&gt; ["baz"]</code>

<code class="p">[</code><code class="s2">"bar"</code><code class="p">,</code> <code class="p">...[</code><code class="s2">"baz"</code><code class="p">]]</code>
<code class="c1">//=&gt; ["bar","baz"]</code>

<code class="p">[</code><code class="s2">"foo"</code><code class="p">,</code> <code class="p">...[</code><code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">]]</code>
<code class="c1">//=&gt; ["foo","bar","baz"]</code>
</pre></div>

</figure>

<p>Thanks to the parallel between array literals + spreads with destructuring + rests, we can also use the same rules to decompose lists:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="nx">first</code>
  <code class="c1">//=&gt; undefined</code>
<code class="nx">rest</code>
  <code class="c1">//=&gt; []:</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"foo"</code><code class="p">];</code>
<code class="nx">first</code>
  <code class="c1">//=&gt; "foo"</code>
<code class="nx">rest</code>
  <code class="c1">//=&gt; []</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">];</code>
<code class="nx">first</code>
  <code class="c1">//=&gt; "foo"</code>
<code class="nx">rest</code>
  <code class="c1">//=&gt; ["bar"]</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">];</code>
<code class="nx">first</code>
  <code class="c1">//=&gt; "foo"</code>
<code class="nx">rest</code>
  <code class="c1">//=&gt; ["bar","baz"]</code>
</pre></div>

</figure>

<p>For the purpose of this exploration, we will presume the following:<sup id="fnref-wellactually"><a href="https://leanpub.com/javascriptallongesix/read#fn-wellactually" rel="footnote">3</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="nx">isEmpty</code><code class="p">([])</code>
  <code class="c1">//=&gt; true</code>

<code class="nx">isEmpty</code><code class="p">([</code><code class="mi">0</code><code class="p">])</code>
  <code class="c1">//=&gt; false</code>

<code class="nx">isEmpty</code><code class="p">([[]])</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Armed with our definition of an empty list and with what we’ve already learned, we can build a great many functions that operate on arrays. We know that we can get the length of an array using its <code>.length</code>. But as an exercise, how would we write a <code>length</code> function using just what we have already?</p>

<p>First, we pick what we call a <em>terminal case</em>. What is the length of an empty array? <code>0</code>. So let’s start our function with the observation that if an array is empty, the length is <code>0</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="c1">// ???</code>
</pre></div>

</figure>

<p>We need something for when the array isn’t empty. If an array is not empty, and we break it into two pieces, <code>first</code> and <code>rest</code>, the length of our array is going to be <code>length(first) + length(rest)</code>. Well, the length of <code>first</code> is <code>1</code>, there’s just one element at the front. But we don’t know the length of <code>rest</code>. If only there was a function we could call… Like <code>length</code>!</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">rest</code><code class="p">);</code>
</pre></div>

</figure>

<p>Let’s try it!</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">length</code><code class="p">([])</code>
  <code class="c1">//=&gt; 0</code>
  
<code class="nx">length</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">])</code>
  <code class="c1">//=&gt; 1</code>
  
<code class="nx">length</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">])</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>Our <code>length</code> function is <em>recursive</em>, it calls itself. This makes sense because our definition of a list is recursive, and if a list is self-similar, it is natural to create an algorithm that is also self-similar.</p>

<h4 id="leanpub-auto-linear-recursion">linear recursion</h4>

<p>“Recursion” sometimes seems like an elaborate party trick. There’s even a joke about this:</p>

<blockquote>
  <p>When promising students are trying to choose between pure mathematics and applied engineering, they are given a two-part aptitude test. In the first part, they are led to a laboratory bench and told to follow the instructions printed on the card. They find a bunsen burner, a sparker, a tap, an empty beaker, a stand, and a card with the instructions “boil water.”</p>
</blockquote>

<blockquote>
  <p>Of course, all the students know what to do: They fill the beaker with water, place the stand on the burner and the beaker on the stand, then they turn the burner on and use the sparker to ignite the flame. After a bit the water boils, and they turn off the burner and are lead to a second bench.</p>
</blockquote>

<blockquote>
  <p>Once again, there is a card that reads, “boil water.” But this time, the beaker is on the stand over the burner, as left behind by the previous student. The engineers light the burner immediately. Whereas the mathematicians take the beaker off the stand and empty it, thus reducing the situation to a problem they have already solved.</p>
</blockquote>

<p>There is more to recursive solutions that simply functions that invoke themselves. Recursive algorithms follow the “divide and conquer” strategy for solving a problem:</p>

<ol class="numeric">
  <li>Divide the problem into smaller problems</li>
  <li>If a smaller problem is solvable, solve the small problem</li>
  <li>If a smaller problem is not solvable, divide and conquer that problem</li>
  <li>When all small problems have been solved, compose the solutions into one big solution</li>
</ol>

<p>The big elements of divide and conquer are a method for decomposing a problem into smaller problems, a test for the smallest possible problem, and a means of putting the pieces back together. Our solutions are a little simpler in that we don’t really break a problem down into multiple pieces, we break a piece off the problem that may or may not be solvable, and solve that before sticking it onto a solution for the rest of the problem.</p>

<p>This simpler form of “divide and conquer” is called <em>linear recursion</em>. It’s very useful and simple to understand. Let’s take another example. Sometimes we want to <em>flatten</em> an array, that is, an array of arrays needs to be turned into one array of elements that aren’t arrays.<sup id="fnref-unfold"><a href="https://leanpub.com/javascriptallongesix/read#fn-unfold" rel="footnote">4</a></sup></p>

<p>We already know how to divide arrays into smaller pieces. How do we decide whether a smaller problem is solvable? We need a test for the terminal case. Happily, there is something along these lines provided for us:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="s2">"foo"</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>
  
<code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">])</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>The usual “terminal case” will be that flattening an empty array will produce an empty array. The next terminal case is that if an element isn’t an array, we don’t flatten it, and can put it together with the rest of our solution directly. Whereas if an element is an array, we’ll flatten it and put it together with the rest of our solution.</p>

<p>So our first cut at a <code>flatten</code> function will look like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">flatten</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[];</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">first</code><code class="p">))</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">flatten</code><code class="p">(</code><code class="nx">rest</code><code class="p">)];</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[...</code><code class="nx">flatten</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="p">...</code><code class="nx">flatten</code><code class="p">(</code><code class="nx">rest</code><code class="p">)];</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">flatten</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="p">[]]])</code>
  <code class="c1">//=&gt; ["foo",3,4]</code>
</pre></div>

</figure>

<p>Once again, the solution directly displays the important elements: Dividing a problem into subproblems, detecting terminal cases, solving the terminal cases, and composing a solution from the solved portions.</p>

<h4 id="mapping">mapping</h4>

<p>Another common problem is applying a function to every element of an array. JavaScript has a built-in function for this, but let’s write our own using linear recursion.</p>

<p>If we want to square each number in a list, we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squareAll</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
                                            <code class="o">?</code> <code class="p">[]</code>
                                            <code class="o">:</code> <code class="p">[</code><code class="nx">first</code> <code class="o">*</code> <code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">squareAll</code><code class="p">(</code><code class="nx">rest</code><code class="p">)</code><code class="o">\</code>
<code class="p">];</code>
                                            
<code class="nx">squareAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>And if we wanted to “truthify” each element in a list, we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">truthyAll</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
                                            <code class="o">?</code> <code class="p">[]</code>
                                            <code class="o">:</code> <code class="p">[</code><code class="o">!!</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">truthyAll</code><code class="p">(</code><code class="nx">rest</code><code class="p">)];</code>

<code class="nx">truthyAll</code><code class="p">([</code><code class="kc">null</code><code class="p">,</code> <code class="kc">true</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s2">"foo"</code><code class="p">])</code>
  <code class="c1">//=&gt; [false,true,true,false,true]</code>
</pre></div>

</figure>

<p>This specific case of linear recursion is called “mapping,” and it is not necessary to constantly write out the same pattern again and again. Functions can take functions as arguments, so let’s “extract” the thing to do to each element and separate it from the business of taking an array apart, doing the thing, and putting the array back together.</p>

<p>Given the signature:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="c1">// ...</code>
</pre></div>

</figure>

<p>We can write it out using a ternary operator. Even in this small function, we can identify the terminal condition, the piece being broken off, and recomposing the solution.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="p">[]</code>
    <code class="o">:</code> <code class="p">[</code><code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="p">...</code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)];</code>
                                              
<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
  
<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="kc">null</code><code class="p">,</code> <code class="kc">true</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s2">"foo"</code><code class="p">])</code>
  <code class="c1">//=&gt; [false,true,true,false,true]</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-folding">folding</h4>

<p>With the exception of the <code>length</code> example at the beginning, our examples so far all involve rebuilding a solution using spreads.  But they needn’t. A function to compute the sum of the squares of a list of numbers might look like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sumSquares</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
                                         <code class="o">?</code> <code class="mi">0</code>
                                         <code class="o">:</code> <code class="nx">first</code> <code class="o">*</code> <code class="nx">first</code> <code class="o">+</code> <code class="nx">sumSquares</code><code class="p">(</code><code class="nx">rest</code><code class="p">);</code>
                                         
<code class="nx">sumSquares</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>There are two differences between <code>sumSquares</code> and our maps above:</p>

<ol class="numeric">
  <li>Given the terminal case of an empty list, we return a <code>0</code> instead of an empty list, and;</li>
  <li>We catenate the square of each element to the result of applying <code>sumSquares</code> to the rest of the elements.</li>
</ol>

<p>Let’s rewrite <code>mapWith</code> so that we can use it to sum squares.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">foldWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">terminalValue</code>
    <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">foldWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="nx">rest</code><code class="p">));</code>
</pre></div>

</figure>

<p>And now we supply a function that does slightly more than our mapping functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">foldWith</code><code class="p">((</code><code class="nx">number</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">number</code> <code class="o">*</code> <code class="nx">number</code> <code class="o">+</code> <code class="nx">rest</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>Our <code>foldWith</code> function is a generalization of our <code>mapWith</code> function. We can represent a map as a fold, we just need to supply the array rebuilding code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squareAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">foldWith</code><code class="p">((</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">first</code> <code class="o">*</code> <code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code><code class="o">\</code>
 <code class="p">[],</code> <code class="nx">array</code><code class="p">);</code>

<code class="nx">squareAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>And if we like, we can write <code>mapWith</code> using <code>foldWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">foldWith</code><code class="p">((</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="p">[</code><code class="o">\</code>
<code class="p">],</code> <code class="nx">array</code><code class="p">),</code>
      <code class="nx">squareAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">array</code><code class="p">);</code>

<code class="nx">squareAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>And to return to our first example, our version of <code>length</code> can be written as a fold:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">foldWith</code><code class="p">((</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">rest</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">array</code><code class="p">);</code>

<code class="nx">length</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-summary-2">summary</h4>

<p>Linear recursion is a basic building block of algorithms. Its basic form parallels the way linear data structures like lists are constructed: This helps make it understandable. Its specialized cases of mapping and folding are especially useful and can be used to build other functions. And finally, while folding is a special case of linear recursion, mapping is a special case of folding.</p>

<h3 id="tail">Tail Calls (and Default Arguments)</h3>

<p>The <code>mapWith</code> and <code>foldWith</code> functions we wrote in <a href="https://leanpub.com/javascriptallongesix/read#linear-recursion">Self-Similarity</a> are useful for illustrating the basic principles behind using recursion to work with self-similar data structures, but they are not “production-ready” implementations. One of the reasons they are not production-ready is that they consume memory proportional to the size of the array being folded.</p>

<p>Let’s look at how. Here’s our extremely simple <code>mapWith</code> function again:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="p">[]</code>
    <code class="o">:</code> <code class="p">[</code><code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="p">...</code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)];</code>

<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>Let’s step through its execution. First, <code>mapWith((x) =&gt; x * x, [1, 2, 3, 4, 5])</code> is invoked. <code>first</code> is not <code>undefined</code>, so it evaluates [fn(first), …mapWith(fn, rest)]. To do that, it has to evaluate <code>fn(first)</code> and <code>mapWith(fn, rest)</code>, then evaluate <code>[fn(first), ...mapWith(fn, rest)]</code>.</p>

<p>This is roughly equivalent to writing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[];</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">_temp1</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code>
          <code class="nx">_temp2</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">),</code>
          <code class="nx">_temp3</code> <code class="o">=</code> <code class="p">[</code><code class="nx">_temp1</code><code class="p">,</code> <code class="p">...</code><code class="nx">_temp2</code><code class="p">];</code>

    <code class="k">return</code> <code class="nx">_temp3</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Note that while evaluating <code>mapWith(fn, rest)</code>, JavaScript must retain the value <code>first</code> or <code>fn(first)</code>, plus some housekeeping information so it remembers what to do with <code>mapWith(fn, rest)</code> when it has a result. JavaScript cannot throw <code>first</code> away. So we know that JavaScript is going to hang on to <code>1</code>.</p>

<p>Next, JavaScript invokes <code>mapWith(fn, rest)</code>, which is semantically equivalent to <code>mapWith((x) =&gt; x * x, [2, 3, 4, 5])</code>. And the same thing happens: JavaScript has to hang on to <code>2</code> (or <code>4</code>, or both, depending on the implementation), plus some housekeeping information so it remembers what to do with that value, while it calls the equivalent of <code>mapWith((x) =&gt; x * x, [3, 4, 5])</code>.</p>

<p>This keeps on happening, so that JavaScript collects the values <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code> plus housekeeping information by the time it calls <code>mapWith((x) =&gt; x * x, [])</code>. It can start assembling the resulting array and start discarding the information it is saving.</p>

<p>That information is saved on a <em>call stack</em>, and it is quite expensive. Furthermore, doubling the length of an array will double the amount of space we need on the stack, plus double all the work required to set up and tear down the housekeeping data for each call (these are called <em>call frames</em>, and they include the place where the function was called, an environment, and so on).</p>

<p>In practice, using a method like this with more than about 50 items in an array may cause some implementations to run very slow, run out of memory and freeze, or cause an error.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code>
   <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code>
  <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code>
  <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">28</code><code class="p">,</code> <code class="mi">29</code><code class="p">,</code>
  <code class="mi">30</code><code class="p">,</code> <code class="mi">31</code><code class="p">,</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">33</code><code class="p">,</code> <code class="mi">34</code><code class="p">,</code> <code class="mi">35</code><code class="p">,</code> <code class="mi">36</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mi">38</code><code class="p">,</code> <code class="mi">39</code><code class="p">,</code>
  <code class="mi">40</code><code class="p">,</code> <code class="mi">41</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="mi">43</code><code class="p">,</code> <code class="mi">44</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mi">46</code><code class="p">,</code> <code class="mi">47</code><code class="p">,</code> <code class="mi">48</code><code class="p">,</code> <code class="mi">49</code><code class="p">,</code>
  <code class="mi">50</code><code class="p">,</code> <code class="mi">51</code><code class="p">,</code> <code class="mi">52</code><code class="p">,</code> <code class="mi">53</code><code class="p">,</code> <code class="mi">54</code><code class="p">,</code> <code class="mi">55</code><code class="p">,</code> <code class="mi">56</code><code class="p">,</code> <code class="mi">57</code><code class="p">,</code> <code class="mi">58</code><code class="p">,</code> <code class="mi">59</code><code class="p">,</code>
  <code class="mi">60</code><code class="p">,</code> <code class="mi">61</code><code class="p">,</code> <code class="mi">62</code><code class="p">,</code> <code class="mi">63</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">65</code><code class="p">,</code> <code class="mi">66</code><code class="p">,</code> <code class="mi">67</code><code class="p">,</code> <code class="mi">68</code><code class="p">,</code> <code class="mi">69</code><code class="p">,</code>
  <code class="mi">70</code><code class="p">,</code> <code class="mi">71</code><code class="p">,</code> <code class="mi">72</code><code class="p">,</code> <code class="mi">73</code><code class="p">,</code> <code class="mi">74</code><code class="p">,</code> <code class="mi">75</code><code class="p">,</code> <code class="mi">76</code><code class="p">,</code> <code class="mi">77</code><code class="p">,</code> <code class="mi">78</code><code class="p">,</code> <code class="mi">79</code><code class="p">,</code>
  <code class="mi">80</code><code class="p">,</code> <code class="mi">81</code><code class="p">,</code> <code class="mi">82</code><code class="p">,</code> <code class="mi">83</code><code class="p">,</code> <code class="mi">84</code><code class="p">,</code> <code class="mi">85</code><code class="p">,</code> <code class="mi">86</code><code class="p">,</code> <code class="mi">87</code><code class="p">,</code> <code class="mi">88</code><code class="p">,</code> <code class="mi">89</code><code class="p">,</code>
  <code class="mi">90</code><code class="p">,</code> <code class="mi">91</code><code class="p">,</code> <code class="mi">92</code><code class="p">,</code> <code class="mi">93</code><code class="p">,</code> <code class="mi">94</code><code class="p">,</code> <code class="mi">95</code><code class="p">,</code> <code class="mi">96</code><code class="p">,</code> <code class="mi">97</code><code class="p">,</code> <code class="mi">98</code><code class="p">,</code> <code class="mi">99</code><code class="p">,</code>
   <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code>
  <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code>
  <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">28</code><code class="p">,</code> <code class="mi">29</code><code class="p">,</code>
  <code class="mi">30</code><code class="p">,</code> <code class="mi">31</code><code class="p">,</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">33</code><code class="p">,</code> <code class="mi">34</code><code class="p">,</code> <code class="mi">35</code><code class="p">,</code> <code class="mi">36</code><code class="p">,</code> <code class="mi">37</code><code class="p">,</code> <code class="mi">38</code><code class="p">,</code> <code class="mi">39</code><code class="p">,</code>
  <code class="mi">40</code><code class="p">,</code> <code class="mi">41</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="mi">43</code><code class="p">,</code> <code class="mi">44</code><code class="p">,</code> <code class="mi">45</code><code class="p">,</code> <code class="mi">46</code><code class="p">,</code> <code class="mi">47</code><code class="p">,</code> <code class="mi">48</code><code class="p">,</code> <code class="mi">49</code><code class="p">,</code>
  <code class="mi">50</code><code class="p">,</code> <code class="mi">51</code><code class="p">,</code> <code class="mi">52</code><code class="p">,</code> <code class="mi">53</code><code class="p">,</code> <code class="mi">54</code><code class="p">,</code> <code class="mi">55</code><code class="p">,</code> <code class="mi">56</code><code class="p">,</code> <code class="mi">57</code><code class="p">,</code> <code class="mi">58</code><code class="p">,</code> <code class="mi">59</code><code class="p">,</code>
  <code class="mi">60</code><code class="p">,</code> <code class="mi">61</code><code class="p">,</code> <code class="mi">62</code><code class="p">,</code> <code class="mi">63</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">65</code><code class="p">,</code> <code class="mi">66</code><code class="p">,</code> <code class="mi">67</code><code class="p">,</code> <code class="mi">68</code><code class="p">,</code> <code class="mi">69</code><code class="p">,</code>
  <code class="mi">70</code><code class="p">,</code> <code class="mi">71</code><code class="p">,</code> <code class="mi">72</code><code class="p">,</code> <code class="mi">73</code><code class="p">,</code> <code class="mi">74</code><code class="p">,</code> <code class="mi">75</code><code class="p">,</code> <code class="mi">76</code><code class="p">,</code> <code class="mi">77</code><code class="p">,</code> <code class="mi">78</code><code class="p">,</code> <code class="mi">79</code><code class="p">,</code>
  <code class="mi">80</code><code class="p">,</code> <code class="mi">81</code><code class="p">,</code> <code class="mi">82</code><code class="p">,</code> <code class="mi">83</code><code class="p">,</code> <code class="mi">84</code><code class="p">,</code> <code class="mi">85</code><code class="p">,</code> <code class="mi">86</code><code class="p">,</code> <code class="mi">87</code><code class="p">,</code> <code class="mi">88</code><code class="p">,</code> <code class="mi">89</code><code class="p">,</code>
  <code class="mi">90</code><code class="p">,</code> <code class="mi">91</code><code class="p">,</code> <code class="mi">92</code><code class="p">,</code> <code class="mi">93</code><code class="p">,</code> <code class="mi">94</code><code class="p">,</code> <code class="mi">95</code><code class="p">,</code> <code class="mi">96</code><code class="p">,</code> <code class="mi">97</code><code class="p">,</code> <code class="mi">98</code><code class="p">,</code> <code class="mi">99</code>
<code class="p">])</code>
  <code class="c1">//=&gt; ???</code>
</pre></div>

</figure>

<p>Is there a better way? Yes. In fact, there are several better ways. Making algorithms faster is a very highly studied field of computer science. The one we’re going to look at here is called <em>tail-call optimization</em>, or “TCO.”</p>

<h4 id="leanpub-auto-tail-call-optimization">tail-call optimization</h4>

<p>A “tail-call” occurs when a function’s last act is to invoke another function, and then return whatever the other function returns. For example, consider the <code>maybe</code> function decorator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">arg</code> <code class="k">of</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">arg</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>There are three places it returns. The first two don’t return anything, they don’t matter. But the third is <code>fn.apply(this, args)</code>. This is a tail-call, because it invokes another function and returns its result. This is interesting, because after sorting out what to supply as arguments (<code>this</code>, <code>args</code>), JavaScript can throw away everything in its current stack frame. It isn’t going to do any more work, so it can throw its existing stack frame away.</p>

<p>And in fact, it does exactly that: It throws the stack frame away, and does not consume extra memory when making a <code>maybe</code>-wrapped call. This is a very important characteristic of JavaScript: <strong>If a function makes a call in tail position, JavaScript optimizes away the function call overhead and stack space.</strong></p>

<p>That is excellent, but one wrapping is not a big deal. When would we really care? Consider this implementation of <code>length</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">rest</code><code class="p">);</code>
</pre></div>

</figure>

<p>The <code>length</code> function calls itself, but it is not a tail-call, because it returns <code>1 + length(rest)</code>, not <code>length(rest)</code>.</p>

<p>The problem can be stated in such a way that the answer is obvious: <code>length</code> does not call itself in tail position, because it has to do two pieces of work, and while one of them is in the recursive call to <code>length</code>, the other happens after the recursive call.</p>

<p>The obvious solution?</p>

<h4 id="leanpub-auto-converting-non-tail-calls-to-tail-calls">converting non-tail-calls to tail-calls</h4>

<p>The obvious solution is push the <code>1 +</code> work into the call to <code>length</code>. Here’s our first cut:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">lengthDelaysWork</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">numberToBeAdded</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="mi">0</code> <code class="o">+</code> <code class="nx">numberToBeAdded</code>
    <code class="o">:</code> <code class="nx">lengthDelaysWork</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">numberToBeAdded</code><code class="p">)</code>

<code class="nx">lengthDelaysWork</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">],</code> <code class="mi">0</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>This <code>lengthDelaysWork</code> function calls itself in tail position. The <code>1 +</code> work is done before calling itself, and by the time it reaches the terminal position, it has the answer. Now that we’ve seen how it works, we can clean up the <code>0 + numberToBeAdded</code> business. But while we’re doing that, it’s annoying to remember to call it with a zero. Let’s fix that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">lengthDelaysWork</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">numberToBeAdded</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">numberToBeAdded</code>
    <code class="o">:</code> <code class="nx">lengthDelaysWork</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">numberToBeAdded</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">lengthDelaysWork</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or we could use partial application:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callLast</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="nx">callLast</code><code class="p">(</code><code class="nx">lengthDelaysWork</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>

<code class="nx">length</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">])</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>This version of <code>length</code> calls uses <code>lengthDelaysWork</code>, and JavaScript optimizes that not to take up memory proportional to the length of the string. We can use this technique with <code>mapWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWithDelaysWork</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">prepend</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">prepend</code>
    <code class="o">:</code> <code class="nx">mapWithDelaysWork</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">,</code> <code class="p">[...</code><code class="nx">prepend</code><code class="p">,</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">)]);</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="nx">callLast</code><code class="p">(</code><code class="nx">mapWithDelaysWork</code><code class="p">,</code> <code class="p">[]);</code>

<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>We can use it with ridiculously large arrays:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code>
     <code class="mi">0</code><code class="p">,</code>    <code class="mi">1</code><code class="p">,</code>    <code class="mi">2</code><code class="p">,</code>    <code class="mi">3</code><code class="p">,</code>    <code class="mi">4</code><code class="p">,</code>    <code class="mi">5</code><code class="p">,</code>    <code class="mi">6</code><code class="p">,</code>    <code class="mi">7</code><code class="p">,</code>    <code class="mi">8</code><code class="p">,</code>    <code class="mi">9</code><code class="p">,</code>
    <code class="mi">10</code><code class="p">,</code>   <code class="mi">11</code><code class="p">,</code>   <code class="mi">12</code><code class="p">,</code>   <code class="mi">13</code><code class="p">,</code>   <code class="mi">14</code><code class="p">,</code>   <code class="mi">15</code><code class="p">,</code>   <code class="mi">16</code><code class="p">,</code>   <code class="mi">17</code><code class="p">,</code>   <code class="mi">18</code><code class="p">,</code>   <code class="mi">19</code><code class="p">,</code>
    <code class="mi">20</code><code class="p">,</code>   <code class="mi">21</code><code class="p">,</code>   <code class="mi">22</code><code class="p">,</code>   <code class="mi">23</code><code class="p">,</code>   <code class="mi">24</code><code class="p">,</code>   <code class="mi">25</code><code class="p">,</code>   <code class="mi">26</code><code class="p">,</code>   <code class="mi">27</code><code class="p">,</code>   <code class="mi">28</code><code class="p">,</code>   <code class="mi">29</code><code class="p">,</code>
    <code class="mi">30</code><code class="p">,</code>   <code class="mi">31</code><code class="p">,</code>   <code class="mi">32</code><code class="p">,</code>   <code class="mi">33</code><code class="p">,</code>   <code class="mi">34</code><code class="p">,</code>   <code class="mi">35</code><code class="p">,</code>   <code class="mi">36</code><code class="p">,</code>   <code class="mi">37</code><code class="p">,</code>   <code class="mi">38</code><code class="p">,</code>   <code class="mi">39</code><code class="p">,</code>
    <code class="mi">40</code><code class="p">,</code>   <code class="mi">41</code><code class="p">,</code>   <code class="mi">42</code><code class="p">,</code>   <code class="mi">43</code><code class="p">,</code>   <code class="mi">44</code><code class="p">,</code>   <code class="mi">45</code><code class="p">,</code>   <code class="mi">46</code><code class="p">,</code>   <code class="mi">47</code><code class="p">,</code>   <code class="mi">48</code><code class="p">,</code>   <code class="mi">49</code><code class="p">,</code>
    <code class="mi">50</code><code class="p">,</code>   <code class="mi">51</code><code class="p">,</code>   <code class="mi">52</code><code class="p">,</code>   <code class="mi">53</code><code class="p">,</code>   <code class="mi">54</code><code class="p">,</code>   <code class="mi">55</code><code class="p">,</code>   <code class="mi">56</code><code class="p">,</code>   <code class="mi">57</code><code class="p">,</code>   <code class="mi">58</code><code class="p">,</code>   <code class="mi">59</code><code class="p">,</code>
    <code class="mi">60</code><code class="p">,</code>   <code class="mi">61</code><code class="p">,</code>   <code class="mi">62</code><code class="p">,</code>   <code class="mi">63</code><code class="p">,</code>   <code class="mi">64</code><code class="p">,</code>   <code class="mi">65</code><code class="p">,</code>   <code class="mi">66</code><code class="p">,</code>   <code class="mi">67</code><code class="p">,</code>   <code class="mi">68</code><code class="p">,</code>   <code class="mi">69</code><code class="p">,</code>
    <code class="mi">70</code><code class="p">,</code>   <code class="mi">71</code><code class="p">,</code>   <code class="mi">72</code><code class="p">,</code>   <code class="mi">73</code><code class="p">,</code>   <code class="mi">74</code><code class="p">,</code>   <code class="mi">75</code><code class="p">,</code>   <code class="mi">76</code><code class="p">,</code>   <code class="mi">77</code><code class="p">,</code>   <code class="mi">78</code><code class="p">,</code>   <code class="mi">79</code><code class="p">,</code>
    <code class="mi">80</code><code class="p">,</code>   <code class="mi">81</code><code class="p">,</code>   <code class="mi">82</code><code class="p">,</code>   <code class="mi">83</code><code class="p">,</code>   <code class="mi">84</code><code class="p">,</code>   <code class="mi">85</code><code class="p">,</code>   <code class="mi">86</code><code class="p">,</code>   <code class="mi">87</code><code class="p">,</code>   <code class="mi">88</code><code class="p">,</code>   <code class="mi">89</code><code class="p">,</code>
    <code class="mi">90</code><code class="p">,</code>   <code class="mi">91</code><code class="p">,</code>   <code class="mi">92</code><code class="p">,</code>   <code class="mi">93</code><code class="p">,</code>   <code class="mi">94</code><code class="p">,</code>   <code class="mi">95</code><code class="p">,</code>   <code class="mi">96</code><code class="p">,</code>   <code class="mi">97</code><code class="p">,</code>   <code class="mi">98</code><code class="p">,</code>   <code class="mi">99</code><code class="p">,</code>

  <code class="c1">// ...</code>

  <code class="mi">2980</code><code class="p">,</code> <code class="mi">2981</code><code class="p">,</code> <code class="mi">2982</code><code class="p">,</code> <code class="mi">2983</code><code class="p">,</code> <code class="mi">2984</code><code class="p">,</code> <code class="mi">2985</code><code class="p">,</code> <code class="mi">2986</code><code class="p">,</code> <code class="mi">2987</code><code class="p">,</code> <code class="mi">2988</code><code class="p">,</code> <code class="mi">2989</code><code class="p">,</code>
  <code class="mi">2990</code><code class="p">,</code> <code class="mi">2991</code><code class="p">,</code> <code class="mi">2992</code><code class="p">,</code> <code class="mi">2993</code><code class="p">,</code> <code class="mi">2994</code><code class="p">,</code> <code class="mi">2995</code><code class="p">,</code> <code class="mi">2996</code><code class="p">,</code> <code class="mi">2997</code><code class="p">,</code> <code class="mi">2998</code><code class="p">,</code> <code class="mi">2999</code> <code class="p">])</code>

  <code class="c1">//=&gt; [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196, ...</code>
</pre></div>

</figure>

<p>Brilliant! We can map over large arrays without incurring all the memory and performance overhead of non-tail-calls. And this basic transformation from a recursive function that does not make a tail call, into a recursive function that calls itself in tail position, is a bread-and-butter pattern for programmers using a language that incorporates tail-call optimization.</p>

<h4 id="leanpub-auto-factorials">factorials</h4>

<p>Introductions to recursion often mention calculating factorials:</p>

<blockquote>
  <p>In mathematics, the factorial of a non-negative integer <code>n</code>, denoted by <code>n!</code>, is the product of all positive integers less than or equal to <code>n</code>. For example:</p>
</blockquote>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mi">5</code><code class="o">!</code> <code class="o">=</code> <code class="mi">5</code>  <code class="nx">x</code>  <code class="mi">4</code>  <code class="nx">x</code>  <code class="mi">3</code>  <code class="nx">x</code>  <code class="mi">2</code>  <code class="nx">x</code>  <code class="mi">1</code> <code class="o">=</code> <code class="mi">120</code><code class="p">.</code>
</pre></div>

</figure>

<p>The naïve function for calcuating the factorial of a positive integer follows directly from the definition:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">n</code> <code class="o">==</code> <code class="mi">1</code>
  <code class="o">?</code> <code class="nx">n</code>
  <code class="o">:</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>
</pre></div>

</figure>

<p>While this is mathematically elegant, it is computational <a href="https://en.wikipedia.org/wiki/Filigree">filigree</a>.</p>

<p>Once again, it is not tail-recursive, it needs to save the stack with each invocation so that it can take the result returned and compute <code>n * factorial(n - 1)</code>. We can do the same conversion, pass in the work to be done:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorialWithDelayedWork</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="nx">work</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code>
  <code class="o">?</code> <code class="nx">work</code>
  <code class="o">:</code> <code class="nx">factorialWithDelayedWork</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">work</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">factorialWithDelayedWork</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or we could use partial application:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callLast</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="nx">callLast</code><code class="p">(</code><code class="nx">factorialWithDelayedWork</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>
</pre></div>

</figure>

<p>As before, we wrote a <code>factorialWithDelayedWork</code> function, then used partial application (<code>callLast</code>) to make a <code>factorial</code> function that took just the one argument and supplied the initial work value.</p>

<h4 id="leanpub-auto-default-arguments">default arguments</h4>

<p>Our problem is that we can directly write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="nx">work</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code>
  <code class="o">?</code> <code class="nx">work</code>
  <code class="o">:</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">work</code><code class="p">);</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>
</pre></div>

</figure>

<p>But it is hideous to have to always add a <code>1</code> parameter, we’d be demanding that everyone using the <code>factorial</code> function know that we are using a tail-recursive implementation.</p>

<p>What we really want is this: We want to write something like <code>factorial(6)</code>, and have JavaScript automatically know that we really mean <code>factorial(6, 1)</code>. But when it calls itself, it will call <code>factorial(5, 6)</code> and that will not mean <code>factorial(5, 1)</code>.</p>

<p>JavaScript provides this exact syntax, it’s called a <em>default argument</em>, and it looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="nx">work</code> <code class="o">=</code> <code class="mi">1</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code>
  <code class="o">?</code> <code class="nx">work</code>
  <code class="o">:</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">work</code><code class="p">);</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>
  <code class="c1">//=&gt; 720</code>
</pre></div>

</figure>

<p>By writing our parameter list as <code>(n, work = 1) =&gt;</code>, we’re stating that if a second parameter is not provided, <code>work</code> is to be bound to <code>1</code>. We can do similar things with our other tail-recursive functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">numberToBeAdded</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">numberToBeAdded</code>
    <code class="o">:</code> <code class="nx">length</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">numberToBeAdded</code><code class="p">)</code>

<code class="nx">length</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">,</code> <code class="s2">"baz"</code><code class="p">])</code>
  <code class="c1">//=&gt; 3</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">prepend</code> <code class="o">=</code> <code class="p">[])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">prepend</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">,</code> <code class="p">[...</code><code class="nx">prepend</code><code class="p">,</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">)]);</code>

<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>Now we don’t need to use two functions. A default argument is concise and readable.</p>

<h4 id="leanpub-auto-defaults-and-destructuring">defaults and destructuring</h4>

<p>We saw earlier that destructuring parameters works the same way as destructuring assignment. Now we learn that we can create a default parameter argument. Can we create a default destructuring assignment?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code> <code class="o">=</code> <code class="s2">"two"</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"one"</code><code class="p">];</code>

<code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> . </code><code class="si">${</code><code class="nx">second</code><code class="si">}</code><code class="sb">`</code>
  <code class="c1">//=&gt; "one . two"</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code> <code class="o">=</code> <code class="s2">"two"</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"primus"</code><code class="p">,</code> <code class="s2">"secundus"</code><code class="p">];</code>

<code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> . </code><code class="si">${</code><code class="nx">second</code><code class="si">}</code><code class="sb">`</code>
  <code class="c1">//=&gt; "primus . secundus"</code>
</pre></div>

</figure>

<p>How very useful: defaults can be supplied for destructuring assignments, just like defaults for parameters.</p>

<h3 id="garbage">Garbage, Garbage Everywhere</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/garbage.jpg" alt="Garbage Day">
  <figcaption>Garbage Day</figcaption>
</figure>


<p>We have now seen how to use <a href="https://leanpub.com/javascriptallongesix/read#tail">Tail Calls</a> to execute <code>mapWith</code> in constant space:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">prepend</code> <code class="o">=</code> <code class="p">[])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">prepend</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">,</code> <code class="p">[...</code><code class="nx">prepend</code><code class="p">,</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">)]);</code>
                                                  
<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,4,9,16,25]</code>
</pre></div>

</figure>

<p>But when we try it on very large arrays, we discover that it is <em>still</em> very slow. Much slower than the built-in <code>.map</code> method for arrays. The right tool to discover why it’s still slow is a memory profiler, but a simple inspection of the program will reveal the following:</p>

<p>Every time we call <code>mapWith</code>, we’re calling <code>[...prepend, fn(first)]</code>. To do that, we take the array in <code>prepend</code> and push <code>fn(first)</code> onto the end, creating a new array that will be passed to the next invocation of <code>mapWith</code>.</p>

<p>Worse, the JavaScript Engine actually copies the elements from <code>prepend</code> into the new array one at a time. That is very laborious.<sup id="fnref-cow"><a href="https://leanpub.com/javascriptallongesix/read#fn-cow" rel="footnote">5</a></sup></p>

<p>The array we had in <code>prepend</code> is no longer used. In GC environments, it is marked as no longer being used, and eventually the garbage collector recycles the memory it is using. Lather, rinse, repeat: Ever time we call <code>mapWith</code>, we’re creating a new array, copying all the elements from <code>prepend</code> into the new array, and then we no longer use <code>prepend</code>.</p>

<p>We may not be creating 3,000 stack frames, but we are creating three thousand new arrays and copying elements into each and every one of them. Although the maximum amount of memory does not grow, the thrashing as we create short-lived arrays is very bad, and we do a lot of work copying elements from one array to another.</p>

<blockquote>
  <p><strong>Key Point</strong>: Our <code>[first, ...rest]</code> approach to recursion is slow because that it creates a lot of temporary arrays, and it spends an enormous amount of time copying elements into arrays that end up being discarded. </p>
</blockquote>

<p>So here’s a question: If this is such a slow approach, why do some examples of “functional” algorithms work this exact way?</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/IBM704b.jpg" alt="The IBM 704">
  <figcaption>The IBM 704</figcaption>
</figure>


<h4 id="leanpub-auto-some-history">some history</h4>

<p>Once upon a time, there was a programming language called <a href="https://en.wikipedia.org/wiki/Lisp_" title="programming_language">Lisp</a>, an acronym for LISt Processing.<sup id="fnref-lisp"><a href="https://leanpub.com/javascriptallongesix/read#fn-lisp" rel="footnote">6</a></sup> Lisp was one of the very first high-level languages, the very first implementation was written for the <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a> computer. (The very first FORTRAN implementation was also written for the 704).</p>

<p>The 704 had a 36-bit word, meaning that it was very fast to store and retrieve 36-bit values. The CPU’s instruction set featured two important macros: <code>CAR</code> would fetch 15 bits representing the Contents of the Address part of the Register, while <code>CDR</code> would fetch the Contents of the Decrement part of the Register.</p>

<p>In broad terms, this means that a single 36-bit word could store two separate 15-bit values and it was very fast to save and retrieve pairs of values. If you had two 15-bit values and wished to write them to the register, the <code>CONS</code> macro would take the values and write them to a 36-bit word.</p>

<p>Thus, <code>CONS</code> put two values together, <code>CAR</code> extracted one, and <code>CDR</code> extracted the other. Lisp’s basic data type is often said to be the list, but in actuality it was the “cons cell,” the term used to describe two 15-bit values stored in one word. The 15-bit values were used as pointers that could refer to a location in memory, so in effect, a cons cell was a little data structure with two pointers to other cons cells.</p>

<p>Lists were represented as linked lists of cons cells, with each cell’s head pointing to an element and the tail pointing to another cons cell.</p>

<blockquote>
  <p>Having these instructions be very fast was important to those early designers: They were working on one of the first high-level languages (COBOL and FORTRAN being the others), and computers in the late 1950s were extremely small and slow by today’s standards. Although the 704 used core memory, it still used vacuum tubes for its logic. Thus, the design of programming languages and algorithms was driven by what could be accomplished with limited memory and performance.</p>
</blockquote>

<p>Here’s the scheme in JavaScript, using two-element arrays to represent cons cells:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">cons</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">],</code>
      <code class="nx">car</code>  <code class="o">=</code> <code class="p">([</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">,</code>
      <code class="nx">cdr</code>  <code class="o">=</code> <code class="p">([</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">d</code><code class="p">;</code>
</pre></div>

</figure>

<p>We can make a list by calling <code>cons</code> repeatedly, and terminating it with <code>null</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneToFive</code> <code class="o">=</code> <code class="nx">cons</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="nx">cons</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="nx">cons</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="nx">cons</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="nx">cons</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="kc">null</code><code class="p">)))));</code>

<code class="nx">oneToFive</code>
  <code class="c1">//=&gt; [1,[2,[3,[4,[5,null]]]]]</code>
</pre></div>

</figure>

<p>Notice that though JavaScript displays our list as if it is composed of arrays nested within each other like Russian Dolls, in reality the arrays refer to each other with references, so <code>[1,[2,[3,[4,[5,null]]]]]</code> is actually more like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">node5</code> <code class="o">=</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code><code class="kc">null</code><code class="p">],</code>
      <code class="nx">node4</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="nx">node5</code><code class="p">],</code>
      <code class="nx">node3</code> <code class="o">=</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="nx">node4</code><code class="p">],</code>
      <code class="nx">node2</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="nx">node3</code><code class="p">],</code>
      <code class="nx">node1</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="nx">node2</code><code class="p">];</code>
    
<code class="kr">const</code> <code class="nx">oneToFive</code> <code class="o">=</code> <code class="nx">node1</code><code class="p">;</code>
</pre></div>

</figure>

<p>This is a <a href="https://en.wikipedia.org/wiki/Linked_list">Linked List</a>, it’s just that those early Lispers used the names <code>car</code> and <code>cdr</code> after the hardware instructions, whereas today we use words like <code>data</code> and <code>reference</code>. But it works the same way: If we want the head of a list, we call <code>car</code> on it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">car</code><code class="p">(</code><code class="nx">oneToFive</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>
</pre></div>

</figure>

<p><code>car</code> is very fast, it simply extracts the first element of the cons cell.</p>

<p>But what about the rest of the list? <code>cdr</code> does the trick:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">cdr</code><code class="p">(</code><code class="nx">oneToFive</code><code class="p">)</code>
  <code class="c1">//=&gt; [2,[3,[4,[5,null]]]]</code>
</pre></div>

</figure>

<p>Again, it’s just extracting a reference from a cons cell, it’s very fast. In Lisp, it’s blazingly fast because it happens in hardware. There’s no making copies of arrays, the time to <code>cdr</code> a list with five elements is the same as the time to <code>cdr</code> a list with 5,000 elements, and no temporary arrays are needed. In JavaScript, it’s still much, much, much faster to get all the elements except the head from a linked list than from an array. Getting one reference to a structure that already exists is faster than copying a bunch of elements.</p>

<p>So now we understand that in Lisp, a lot of things use linked lists, and they do that in part because it was what the hardware made possible.</p>

<p>Getting back to JavaScript now, when we write <code>[first, ...rest]</code> to gather or spread arrays, we’re emulating the semantics of <code>car</code> and <code>cdr</code>, but not the implementation. We’re doing something laborious and memory-inefficient compared to using a linked list as Lisp did and as we can still do if we choose.</p>

<p>That being said, it is easy to understand and helps us grasp how literals and destructuring works, and how recursive algorithms ought to mirror the self-similarity of the data structures they manipulate. And so it is today that languages like JavaScript have arrays that are slow to split into the equivalent of a <code>car</code>/<code>cdr</code> pair, but instructional examples of recursive programs still have echoes of their Lisp origins.</p>

<p>We’ll look at linked lists again when we look at <a href="https://leanpub.com/javascriptallongesix/read#pojos">Plain Old JavaScript Objects</a>.</p>

<h4 id="leanpub-auto-so-why-arrays">so why arrays</h4>

<p>If <code>[first, ...rest]</code> is so slow, why does JavaScript use arrays instead of making everything a linked list?</p>

<p>Well, linked lists are fast for a few things, like taking the front element off a list, and taking the remainder of a list. But not for iterating over a list: Pointer chasing through memory is quite a bit slower than incrementing an index. In addition to the extra fetches to dereference pointers, pointer chasing suffers from cache misses. And if you want an arbitrary item from a list, you have to iterate through the list element by element, whereas with the indexed array you just fetch it.</p>

<p>We have avoided discussing rebinding and mutating values, but if we want to change elements of our lists, the naïve linked list implementation suffers as well: When we take the <code>cdr</code> of a linked list, we are sharing the elements. If we make any change other than cons-ing a new element to the front, we are changing both the new list and the old list.</p>

<p>Arrays avoid this problem by pessimistically copying all the references whenever we extract an element or sequence of elements from them (We’ll see this explained later in <a href="https://leanpub.com/javascriptallongesix/read#mutation">Mutation</a>).</p>

<p>For these and other reasons, almost all languages today make it possible to use a fast array or vector type that is optimized for iteration, and even Lisp now has a variety of data structures that are optimized for specific use cases.</p>

<h4 id="leanpub-auto-summary-3">summary</h4>

<p>Although we showed how to use tail calls to map and fold over arrays with <code>[first, ...rest]</code>, in reality this is not how it ought to be done. But it is an extremely simple illustration of how recursion works when you have a self-similar means of constructing a data structure.</p>

<h3 id="pojos">Plain Old JavaScript Objects</h3>

<p>Lists are not the only way to represent collections of things, but they are the “oldest” data structure in the history of high level languages, because they map very closely to the way the hardware is organized in a computer. Lists are obviously very handy for homogeneous collections of things, like a shopping list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">remember</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"the milk"</code><code class="p">,</code> <code class="s2">"the coffee beans"</code><code class="p">,</code> <code class="s2">"the biscotti"</code><code class="p">];</code>
</pre></div>

</figure>

<p>And they can be used to store heterogeneous things in various levels of structure:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">[[</code><code class="s2">"Reginald"</code><code class="p">,</code> <code class="s2">"Braithwaite"</code><code class="p">],[</code> <code class="s2">"author"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"JavaScript Allongé"</code><code class="p">,</code> <code class="s2">"Ja\</code>
<code class="s2">vaScript Spessore"</code><code class="p">,</code> <code class="s2">"CoffeeScript Ristretto"</code><code class="p">]]];</code>
</pre></div>

</figure>

<p>Remembering that the name is the first item is error-prone, and being expected to look at <code>user[0][1]</code> and know that we are talking about a surname is unreasonable. So back when lists were the only things available, programmers would introduce constants to make things easier on themselves:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">NAME</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">FIRST</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">LAST</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
      <code class="nx">OCCUPATION</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
      <code class="nx">TITLE</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">RESPONSIBILITIES</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">[[</code><code class="s2">"Reginald"</code><code class="p">,</code> <code class="s2">"Braithwaite"</code><code class="p">],[</code> <code class="s2">"author"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"JavaScript Allongé"</code><code class="p">,</code> <code class="s2">"Ja\</code>
<code class="s2">vaScript Spessore"</code><code class="p">,</code> <code class="s2">"CoffeeScript Ristretto"</code><code class="p">]]];</code>
</pre></div>

</figure>

<p>Now they could write <code>user[NAME][LAST]</code> or <code>user[OCCUPATION][TITLE]</code> instead of <code>user[0][1]</code> or <code>user[1][0]</code>. Over time, this need to build heterogeneous data structures with access to members by name evolved into the <a href="https://en.wikipedia.org/wiki/Associative_array">Dictionary</a> data type, a mapping from a unique set of objects to another set of objects.</p>

<p>Dictionaries store key-value pairs, so instead of binding <code>NAME</code> to <code>0</code> and then storing a name in an array at index <code>0</code>, we can bind a name directly to <code>name</code> in a dictionary, and we let JavaScript sort out whether the implementation is a list of key-value pairs, a hashed collection, a tree of some sort, or anything else.</p>

<p>JavaScript has dictionaries, and it calls them “objects.” The word “object” is loaded in programming circles, due to the widespread use of the term “object-oriented programming” that was coined by Alan Kay but has since come to mean many, many things to many different people.</p>

<p>In JavaScript, an object is a map from string keys to values.</p>

<h4 id="leanpub-auto-literal-object-syntax">literal object syntax</h4>

<p>JavaScript has a literal syntax for creating objects. This object maps values to the keys <code>year</code>, <code>month</code>, and <code>day</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="nx">year</code><code class="o">:</code> <code class="mi">2012</code><code class="p">,</code> <code class="nx">month</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">day</code><code class="o">:</code> <code class="mi">14</code> <code class="p">}</code>
</pre></div>

</figure>

<p>Two objects created with separate evaluations have differing identities, just like arrays:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="nx">year</code><code class="o">:</code> <code class="mi">2012</code><code class="p">,</code> <code class="nx">month</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">day</code><code class="o">:</code> <code class="mi">14</code> <code class="p">}</code> <code class="o">===</code> <code class="p">{</code> <code class="nx">year</code><code class="o">:</code> <code class="mi">2012</code><code class="p">,</code> <code class="nx">month</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">day</code><code class="o">:</code> <code class="mi">14</code> <code class="p">}</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Objects use <code>[]</code> to access the values by name, using a string:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="nx">year</code><code class="o">:</code> <code class="mi">2012</code><code class="p">,</code> <code class="nx">month</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">day</code><code class="o">:</code> <code class="mi">14</code> <code class="p">}[</code><code class="s1">'day'</code><code class="p">]</code>
  <code class="c1">//=&gt; 14</code>
</pre></div>

</figure>

<p>Values contained within an object work just like values contained within an array, we access them by reference to the original:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">unique</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[],</code>
      <code class="nx">x</code> <code class="o">=</code> <code class="nx">unique</code><code class="p">(),</code>
      <code class="nx">y</code> <code class="o">=</code> <code class="nx">unique</code><code class="p">(),</code>
      <code class="nx">z</code> <code class="o">=</code> <code class="nx">unique</code><code class="p">(),</code>
      <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="nx">z</code> <code class="p">};</code>

<code class="nx">o</code><code class="p">[</code><code class="s1">'a'</code><code class="p">]</code> <code class="o">===</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">o</code><code class="p">[</code><code class="s1">'b'</code><code class="p">]</code> <code class="o">===</code> <code class="nx">y</code> <code class="o">&amp;&amp;</code> <code class="nx">o</code><code class="p">[</code><code class="s1">'c'</code><code class="p">]</code> <code class="o">===</code> <code class="nx">z</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Names needn’t be alphanumeric strings. For anything else, enclose the label in quotes:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code> <code class="s1">'first name'</code><code class="o">:</code> <code class="s1">'reginald'</code><code class="p">,</code> <code class="s1">'last name'</code><code class="o">:</code> <code class="s1">'lewis'</code> <code class="p">}[</code><code class="s1">'first name'</code><code class="p">]</code>
  <code class="c1">//=&gt; 'reginald'</code>
</pre></div>

</figure>

<p>If the name is an alphanumeric string conforming to the same rules as names of variables, there’s a simplified syntax for accessing the values:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">date</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">year</code><code class="o">:</code> <code class="mi">2012</code><code class="p">,</code> <code class="nx">month</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">day</code><code class="o">:</code> <code class="mi">14</code> <code class="p">};</code>

<code class="nx">date</code><code class="p">[</code><code class="s1">'day'</code><code class="p">]</code> <code class="o">===</code> <code class="nx">date</code><code class="p">.</code><code class="nx">day</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Expressions can be used for keys as well. The syntax is to enclose the key’s expression in <code>[</code> and <code>]</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code>
  <code class="p">[</code><code class="s2">"p"</code> <code class="o">+</code> <code class="s2">"i"</code><code class="p">]</code><code class="o">:</code> <code class="mf">3.14159265</code>
<code class="p">}</code>
  <code class="c1">//=&gt; {"pi":3.14159265}</code>
</pre></div>

</figure>

<p>All containers can contain any value, including functions or other containers, like a fat arrow function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Mathematics</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">abs</code><code class="o">:</code> <code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="o">-</code><code class="nx">a</code> <code class="o">:</code> <code class="nx">a</code>
<code class="p">};</code>

<code class="nx">Mathematics</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="o">-</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<p>Or proper functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SecretDecoderRing</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">encode</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">plaintext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">plaintext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">decode</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">cyphertext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">cyphertext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Or named function expressions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SecretDecoderRing</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">encode</code><code class="o">:</code> <code class="kd">function</code> <code class="nx">encode</code> <code class="p">(</code><code class="nx">plaintext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">plaintext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">decode</code><code class="o">:</code> <code class="kd">function</code> <code class="nx">decode</code> <code class="p">(</code><code class="nx">cyphertext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">cyphertext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>It is very common to associate named function expressions with keys in objects, and there is a “compact method syntax” for binding named function expressions to keywords:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SecretDecoderRing</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">encode</code> <code class="p">(</code><code class="nx">plaintext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">plaintext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">decode</code> <code class="p">(</code><code class="nx">cyphertext</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">cyphertext</code>
      <code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kr">char</code> <code class="o">=&gt;</code> <code class="kr">char</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">()</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nx">code</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">code</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">.</code><code class="nx">fromCharCode</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">)</code>
      <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>(There are some other technical differences between binding a named function expression and using compact method syntax, but they are not relevant here. We will generally prefer compact method syntax whenever we can.)</p>

<h4 id="leanpub-auto-destructuring-objects">destructuring objects</h4>

<p>Just as we saw with arrays, we can write destructuring assignments with literal object syntax. So, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="s2">"Reginald"</code><code class="p">,</code>
          <code class="nx">last</code><code class="o">:</code> <code class="s2">"Braithwaite"</code>
        <code class="p">},</code>
  <code class="nx">occupation</code><code class="o">:</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Author"</code><code class="p">,</code>
                <code class="nx">responsibilities</code><code class="o">:</code> <code class="p">[</code> <code class="s2">"JavaScript Allongé"</code><code class="p">,</code>
                                    <code class="s2">"JavaScript Spessore"</code><code class="p">,</code>
                                    <code class="s2">"CoffeeScript Ristretto"</code>
                                  <code class="p">]</code>
              <code class="p">}</code>
<code class="p">};</code>

<code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">last</code>
  <code class="c1">//=&gt; "Braithwaite"</code>

<code class="nx">user</code><code class="p">.</code><code class="nx">occupation</code><code class="p">.</code><code class="nx">title</code>
  <code class="c1">//=&gt; "Author"</code>
</pre></div>

</figure>

<p>And we can also write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">given</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="nx">surname</code><code class="p">},</code> <code class="nx">occupation</code><code class="o">:</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="nx">title</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">us</code><code class="o">\</code>
<code class="nx">er</code><code class="p">;</code>

<code class="nx">surname</code>
  <code class="c1">//=&gt; "Braithwaite"</code>

<code class="nx">title</code>
  <code class="c1">//=&gt; "Author"</code>
</pre></div>

</figure>

<p>And of course, we destructure parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">description</code> <code class="o">=</code> <code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">given</code> <code class="p">},</code> <code class="nx">occupation</code><code class="o">:</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="nx">title</code> <code class="p">}</code> <code class="p">})</code> <code class="o">=&gt;</code>
  <code class="sb">`</code><code class="si">${</code><code class="nx">given</code><code class="si">}</code><code class="sb"> is a </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>

<code class="nx">description</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code>
  <code class="c1">//=&gt; "Reginald is a Author"</code>
</pre></div>

</figure>

<p>Terrible grammar and capitalization, but let’s move on. It is very common to write things like <code>title: title</code> when destructuring objects. When the label is a valid variable name, it’s often the most obvious variable name as well. So JavaScript supports a further syntactic optimization:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">description</code> <code class="o">=</code> <code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code> <code class="p">},</code> <code class="nx">occupation</code><code class="o">:</code> <code class="p">{</code> <code class="nx">title</code> <code class="p">}</code> <code class="p">})</code> <code class="o">=&gt;</code>
  <code class="sb">`</code><code class="si">${</code><code class="nx">first</code><code class="si">}</code><code class="sb"> is a </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>

<code class="nx">description</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code>
  <code class="c1">//=&gt; "Reginald is a Author"</code>
</pre></div>

</figure>

<p>And that same syntax works for literals:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">abbrev</code> <code class="o">=</code> <code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code> <code class="p">},</code> <code class="nx">occupation</code><code class="o">:</code> <code class="p">{</code> <code class="nx">title</code> <code class="p">}</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">,</code> <code class="nx">title</code><code class="p">};</code>
<code class="p">}</code>

<code class="nx">abbrev</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":"Reginald","last":"Braithwaite","title":"Author"}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-revisiting-linked-lists">revisiting linked lists</h4>

<p>Earlier, we used two-element arrays as nodes in a linked list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">cons</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">],</code>
      <code class="nx">car</code>  <code class="o">=</code> <code class="p">([</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">,</code>
      <code class="nx">cdr</code>  <code class="o">=</code> <code class="p">([</code><code class="nx">a</code><code class="p">,</code> <code class="nx">d</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">d</code><code class="p">;</code>
</pre></div>

</figure>

<p>In essence, this simple implementation used functions to create an abstraction with named elements. But now that we’ve looked at objects, we can use an object instead of a two-element array. While we’re at it, let’s use contemporary names. So our linked list nodes will be formed from <code>{ first, rest }</code></p>

<p>In that case, a linked list of the numbers <code>1</code>, <code>2</code>, and <code>3</code> will look like this: <code>{ first: 1, rest: { first: 2, rest: { first: 3, rest: EMPTY } } }</code>.</p>

<p>We can then perform the equivalent of <code>[first, ...rest]</code> with direct property accessors:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">OneTwoThree</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="o">\</code>
<code class="p">}</code> <code class="p">}</code> <code class="p">};</code>

<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">first</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">rest</code>
  <code class="c1">//=&gt; {"first":2,"rest":{"first":3,"rest":{}}}</code>

<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">first</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>Taking the length of a linked list is easy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">length</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">length</code><code class="p">(</code><code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>What about mapping? Well, let’s start with the simplest possible thing, making a <em>copy</em> of a list. As we saw above, and discussed in <a href="https://leanpub.com/javascriptallongesix/read#garbage">Garbage, Garbage Everywhere</a>, it is fast to iterate forward through a linked list. What isn’t fast is naïvely copying a list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">slowcopy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">EMPTY</code>
    <code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">slowcopy</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">)};</code>

<code class="nx">slowcopy</code><code class="p">(</code><code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":2,"rest":{"first":3,"rest":{}}}}</code>
</pre></div>

</figure>

<p>The problem here is that linked lists are constructed back-to-front, but we iterate over them front-to-back. So to copy a list, we have to save all the bits on the call stack and then construct the list from back-to-front as all the recursive calls return.</p>

<p>We could follow the strategy of delaying the work. Let’s write that naively:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">copy2</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">copy2</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="nx">copy2</code><code class="p">(</code><code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":3,"rest":{"first":2,"rest":{"first":1,"rest":{}}}}</code>
</pre></div>

</figure>

<p>Well, well, well. We have unwittingly <em>reversed</em> the list. This makes sense, if lists are constructed from back to front, and we make a linked list out of items as we iterate through it, we’re going to get a backwards copy of the list. This isn’t a bad thing by any stretch of the imagination. Let’s call it what it is:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>
</pre></div>

</figure>

<p>And now, we can make a reversing map:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverseMapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverseMapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">),</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="nx">reverseMapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":9,"rest":{"first":4,"rest":{"first":1,"rest":{}}}}</code>
</pre></div>

</figure>

<p>And a regular <code>mapWith</code> follows:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">delayed</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">),</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":4,"rest":{"first":9,"rest":{}}}}</code>
</pre></div>

</figure>

<p>Our <code>mapWith</code> function takes twice as long as a straight iteration, because it iterates over the entire list twice, once to map, and once to reverse the list. Likewise, it takes twice as much memory, because it constructs a reverse of the desired result before throwing it away.</p>

<p>Mind you, this is still much, much faster than making partial copies of arrays. For a list of length <em>n</em>, we created <em>n</em> superfluous nodes and copied <em>n</em> superfluous values. Whereas our naïve array algorithm created 2<em>n</em> superfluous arrays and copied <em>n</em><sup>2</sup> superfluous values.</p>

<h3 id="mutation">Mutation</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/cupping.jpg" alt="Cupping Grinds">
  <figcaption>Cupping Grinds</figcaption>
</figure>


<p>In JavaScript, almost every type of value can <em>mutate</em>. Their identities stay the same, but not their structure. Specifically, arrays and objects can mutate. Recall that you can access a value from within an array or an object using <code>[]</code>. You can reassign a value using <code>[] =</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="nx">oneTwoThree</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'one'</code><code class="p">;</code>
<code class="nx">oneTwoThree</code>
  <code class="c1">//=&gt; [ 'one', 2, 3 ]</code>
</pre></div>

</figure>

<p>You can even add a value:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="nx">oneTwoThree</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'four'</code><code class="p">;</code>
<code class="nx">oneTwoThree</code>
  <code class="c1">//=&gt; [ 1, 2, 3, 'four' ]</code>
</pre></div>

</figure>

<p>You can do the same thing with both syntaxes for accessing objects:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Leonard'</code><code class="p">,</code> <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Braithwaite'</code><code class="p">};</code>
<code class="nx">name</code><code class="p">.</code><code class="nx">middleName</code> <code class="o">=</code> <code class="s1">'Austin'</code>
<code class="nx">name</code>
  <code class="c1">//=&gt; { firstName: 'Leonard',</code>
  <code class="err">#</code>     <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Braithwaite'</code><code class="p">,</code>
  <code class="err">#</code>     <code class="nx">middleName</code><code class="o">:</code> <code class="s1">'Austin'</code> <code class="p">}</code>
</pre></div>

</figure>

<p>We have established that JavaScript’s semantics allow for two different bindings to refer to the same value. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">allHallowsEve</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2012</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">31</code><code class="p">]</code>
<code class="kr">const</code> <code class="nx">halloween</code> <code class="o">=</code> <code class="nx">allHallowsEve</code><code class="p">;</code>  
</pre></div>

</figure>

<p>Both <code>halloween</code> and <code>allHallowsEve</code> are bound to the same array value within the local environment. And also:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">allHallowsEve</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2012</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">31</code><code class="p">];</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">halloween</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">})(</code><code class="nx">allHallowsEve</code><code class="p">);</code>
</pre></div>

</figure>

<p>There are two nested environments, and each one binds a name to the exact same array value. In each of these examples, we have created two <em>aliases</em> for the same value. Before we could reassign things, the most important point about this is that the identities were the same, because they were the same value.</p>

<p>This is vital. Consider what we already know about shadowing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">allHallowsEve</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2012</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">31</code><code class="p">];</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">halloween</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">halloween</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2013</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">31</code><code class="p">];</code>
<code class="p">})(</code><code class="nx">allHallowsEve</code><code class="p">);</code>
<code class="nx">allHallowsEve</code>
  <code class="c1">//=&gt; [2012, 10, 31]</code>
</pre></div>

</figure>

<p>The outer value of <code>allHallowsEve</code> was not changed because all we did was rebind the name <code>halloween</code> within the inner environment. However, what happens if we <em>mutate</em> the value in the inner environment?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">allHallowsEve</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2012</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">31</code><code class="p">];</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">halloween</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">halloween</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2013</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">allHallowsEve</code><code class="p">);</code>
<code class="nx">allHallowsEve</code>
  <code class="c1">//=&gt; [2013, 10, 31]</code>
</pre></div>

</figure>

<p>This is different. We haven’t rebound the inner name to a different variable, we’ve mutated the value that both bindings share. Now that we’ve finished with mutation and aliases, let’s have a look at it.</p>

<aside class="tip blurb">
    <p>JavaScript permits the reassignment of new values to existing bindings, as well as the reassignment and assignment of new values to elements of containers such as arrays and objects. Mutating existing objects has special implications when two bindings are aliases of the same value.</p>

</aside>

<aside class="tip blurb">
    <p>Note well: Declaring a variable <code>const</code> does not prevent us from mutating its value, only from rebinding its name. This is an important distinction.</p>

</aside>

<h4 id="leanpub-auto-mutation-and-data-structures">mutation and data structures</h4>

<p>Mutation is a surprisingly complex subject. It is possible to compute anything without ever mutating an existing entity. Languages like <a href="https://en.wikipedia.org/wiki/Haskell_" title="programming_language">Haskell</a> don’t permit mutation at all. In general, mutation makes some algorithms shorter to write and possibly faster, but harder to reason about.</p>

<p>One pattern many people follow is to be liberal with mutation when constructing data, but conservative with mutation when consuming data. Let’s recall linked lists from <a href="https://leanpub.com/javascriptallongesix/read#pojos">Plain Old JavaScript Objects</a>. While we’re executing the <code>mapWith</code> function, we’re constructing a new linked list. By this pattern, we would be happy to use mutation to construct the list while running <code>mapWith</code>.</p>

<p>But after returning the new list, we then become conservative about mutation. This also makes sense: Linked lists often use structure sharing. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">OneToFive</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> 
                    <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code>
                      <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
                      <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code>
                        <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
                        <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code>
                          <code class="nx">first</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
                          <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code>
                            <code class="nx">first</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>
                            <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="p">}</code> <code class="p">}</code> <code class="p">}</code> <code class="p">}</code> <code class="p">};</code>

<code class="nx">OneToFive</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":2,"rest":{"first":"three","rest":{"first":"fou\</code>
<code class="nx">r</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">five</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{}}}}}}</code>
<code class="s2">                            </code>
<code class="s2">const ThreeToFive = OneToFive.rest.rest;</code>

<code class="s2">ThreeToFive</code>
<code class="s2">  //=&gt; {"</code><code class="nx">first</code><code class="s2">":3,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":4,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":5,"</code><code class="nx">rest</code><code class="s2">":{}}}}</code>
<code class="s2">  </code>
<code class="s2">ThreeToFive.first = "</code><code class="nx">three</code><code class="s2">";</code>
<code class="s2">ThreeToFive.rest.first = "</code><code class="nx">four</code><code class="s2">";</code>
<code class="s2">ThreeToFive.rest.rest.first = "</code><code class="nx">five</code><code class="s2">";</code>

<code class="s2">ThreeToFive</code>
<code class="s2">  //=&gt; {"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">three</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">four</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">five</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{}}\</code>
<code class="s2">}}</code>

<code class="s2">OneToFive</code>
<code class="s2">  //=&gt; {"</code><code class="nx">first</code><code class="s2">":1,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":2,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">three</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">fou</code><code class="o">\</code>
<code class="nx">r</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">five</code><code class="s2">","</code><code class="nx">rest</code><code class="err">"</code><code class="o">:</code><code class="p">{}}}}}}</code>
</pre></div>

</figure>

<p>Changes made to <code>ThreeToFive</code> affect <code>OneToFive</code>, because they share the same structure. When we wrote <code>ThreeToFive = OneToFive.rest.rest;</code>, we weren’t making a brand new copy of <code>{"first":3,"rest":{"first":4,"rest":{"first":5,"rest":{}}}}</code>, we were getting a reference to the same chain of nodes.</p>

<p>Structure sharing like this is what makes linked lists so fast for taking everything but the first item of a list: We aren’t making a new list, we’re using some of the old list. Whereas destructuring an array with <code>[first, ...rest]</code> does make a copy, so:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">OneToFive</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">];</code>

<code class="nx">OneToFive</code>
  <code class="c1">//=&gt; [1,2,3,4,5]</code>

<code class="kr">const</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="p">...</code><code class="nx">ThreeToFive</code><code class="p">]</code> <code class="o">=</code> <code class="nx">OneToFive</code><code class="p">;</code>

<code class="nx">ThreeToFive</code>
  <code class="c1">//=&gt; [3, 4, 5]</code>

<code class="nx">ThreeToFive</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"three"</code><code class="p">;</code>
<code class="nx">ThreeToFive</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"four"</code><code class="p">;</code>
<code class="nx">ThreeToFive</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"five"</code><code class="p">;</code>

<code class="nx">ThreeToFive</code>
  <code class="c1">//=&gt; ["three","four","five"]</code>
  
<code class="nx">OneToFive</code>
  <code class="c1">//=&gt; [1,2,3,4,5]</code>
</pre></div>

</figure>

<p>The gathering operation <code>[a, b, ...ThreeToFive]</code> is slower, but “safer.”</p>

<p>So back to avoiding mutation. In general, it’s easier to reason about data that doesn’t change. We don’t have to remember to use copying operations when we pass it as a value to a function, or extract some data from it. We just use the data, and the less we mutate it, the fewer the times we have to think about whether making changes will be “safe.”</p>

<h4 id="leanpub-auto-building-with-mutation">building with mutation</h4>

<p>As noted, one pattern is to be more liberal about mutation when building a data structure. Consider our <code>copy</code> algorithm. Without mutation, a copy of a linked list can be made in constant space by reversing a reverse of the list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="kr">const</code> <code class="nx">copy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">reverse</code><code class="p">(</code><code class="nx">node</code><code class="p">));</code>
</pre></div>

</figure>

<p>If we want to make a copy of a linked list without iterating over it twice and making a copy we discard later, we can use mutation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">copy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">head</code> <code class="o">=</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">tail</code> <code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">head</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">tail</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="k">return</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="nx">tail</code><code class="p">.</code><code class="nx">rest</code> <code class="o">=</code> <code class="nx">newNode</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">head</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This algorithm makes copies of nodes as it goes, and mutates the last node in the list so that it can splice the next one on. Adding a node to an existing list is risky, as we saw when considering the fact that <code>OneToFive</code> and <code>ThreeToFive</code> share the same nodes. But when we’re in the midst of creating a brand new list, we aren’t sharing any nodes with any other lists, and we can afford to be more liberal about using mutation to save space and/or time.</p>

<p>Armed with this basic copy implementation, we can write <code>mapWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">,</code> <code class="nx">head</code> <code class="o">=</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">tail</code> <code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">head</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">tail</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="k">return</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">),</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="nx">tail</code><code class="p">.</code><code class="nx">rest</code> <code class="o">=</code> <code class="nx">newNode</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">head</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mf">1.0</code> <code class="o">/</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">OneToFive</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":0.5,"rest":{"first":0.3333333333333333,"rest":\</code>
<code class="p">{</code><code class="s2">"first"</code><code class="o">:</code><code class="mf">0.25</code><code class="p">,</code><code class="s2">"rest"</code><code class="o">:</code><code class="p">{</code><code class="s2">"first"</code><code class="o">:</code><code class="mf">0.2</code><code class="p">,</code><code class="s2">"rest"</code><code class="o">:</code><code class="p">{}}}}}}</code>
</pre></div>

</figure>

<h3 id="reassignment">Reassignment</h3>

<p>Like some imperative programming languages, JavaScript allows you to re-assign the value bound to parameters. We saw this earlier in <a href="https://leanpub.com/javascriptallongesix/read#rebinding-peek">rebinding</a>:</p>

<p>By default, JavaScript permits us to <em>rebind</em> new values to names bound with a parameter. For example, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">evenStevens</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="nx">n</code> <code class="o">=</code> <code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">evenStevens</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">evenStevens</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>The line <code>n = n - 2;</code> <em>rebinds</em> a new value to the name <code>n</code>. We will discuss this at much greater length in <a href="https://leanpub.com/javascriptallongesix/read#reassignment">Reassignment</a>, but long before we do, let’s try a similar thing with a name bound using <code>const</code>. We’ve already bound <code>evenStevens</code> using <code>const</code>, let’s try rebinding it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">evenStevens</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">evenStevens</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
  <code class="c1">//=&gt; ERROR, evenStevens is read-only</code>
</pre></div>

</figure>

<p>JavaScript does not permit us to rebind a name that has been bound with <code>const</code>. We can <em>shadow</em> it by using <code>const</code> to declare a new binding with a new function or block scope, but we cannot rebind a name that was bound with <code>const</code> in an existing scope.</p>

<p>Rebinding parameters is usually avoided, but what about rebinding names we declare within a function? What we want is a statement that works like <code>const</code>, but permits us to rebind variables. JavaScript has such a thing, it’s called <code>let</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">52</code><code class="p">;</code>

<code class="nx">age</code> <code class="o">=</code> <code class="mi">53</code><code class="p">;</code>
<code class="nx">age</code>
  <code class="c1">//=&gt; 53</code>
</pre></div>

</figure>

<p>We took the time to carefully examine what happens with bindings in environments. Let’s take the time to explore what happens with reassigning values to variables. The key is to understand that we are rebinding a different value to the same name in the same environment.</p>

<p>So let’s consider what happens with a shadowed variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">49</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; 49</code>
</pre></div>

</figure>

<p>Using <code>let</code> to bind <code>50</code> to age within the block does not change the binding of <code>age</code> in the outer environment because the binding of <code>age</code> in the block shadows the binding of <code>age</code> in the outer environment, just like <code>const</code>. We go from:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code><code class="nx">age</code><code class="o">:</code> <code class="mi">49</code><code class="p">,</code> <code class="s1">'..'</code><code class="o">:</code> <code class="nx">global</code><code class="o">-</code><code class="nx">environment</code><code class="p">}</code>
</pre></div>

</figure>

<p>To:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code><code class="nx">age</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="s1">'..'</code><code class="o">:</code> <code class="p">{</code><code class="nx">age</code><code class="o">:</code> <code class="mi">49</code><code class="p">,</code> <code class="s1">'..'</code><code class="o">:</code> <code class="nx">global</code><code class="o">-</code><code class="nx">environment</code><code class="p">}}</code>
</pre></div>

</figure>

<p>Then back to:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code><code class="nx">age</code><code class="o">:</code> <code class="mi">49</code><code class="p">,</code> <code class="s1">'..'</code><code class="o">:</code> <code class="nx">global</code><code class="o">-</code><code class="nx">environment</code><code class="p">}</code>
</pre></div>

</figure>

<p>However, if we don’t shadow <code>age</code> with <code>let</code>, reassigning within the block changes the original:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">49</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">age</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; 50</code>
</pre></div>

</figure>

<p>Like evaluating variable labels, when a binding is rebound, JavaScript searches for the binding in the current environment and then each ancestor in turn until it finds one. It then rebinds the name in that environment.</p>

<h4 id="leanpub-auto-mixing-let-and-const">mixing <code>let</code> and <code>const</code>
</h4>

<p>Some programmers dislike deliberately shadowing variables. The suggestion is that shadowing a variable is confusing code. If you buy that argument, the way that shadowing works in JavaScript exists to protect us from accidentally shadowing a variable when we move code around.</p>

<p>If you dislike deliberately shadowing variables, you’ll probably take an even more opprobrious view of mixing <code>const</code> and <code>let</code> semantics with a shadowed variable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">49</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">age</code> <code class="o">=</code> <code class="mi">51</code><code class="p">;</code>
  <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; 51</code>
</pre></div>

</figure>

<p>Shadowing a <code>let</code> with a <code>const</code> does not change our ability to rebind the variable in its original scope. And:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">49</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">age</code> <code class="o">=</code> <code class="mi">52</code><code class="p">;</code>
  <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; ERROR: age is read-only</code>
</pre></div>

</figure>

<p>Shadowing a <code>const</code> with a <code>let</code> does not permit it to be rebound in its original scope.</p>

<h4 id="leanpub-auto-var"><code>var</code></h4>

<p>JavaScript has one <em>more</em> way to bind a name to a value, <code>var</code>.<sup id="fnref-namecount"><a href="https://leanpub.com/javascriptallongesix/read#fn-namecount" rel="footnote">7</a></sup></p>

<p><code>var</code> looks a lot like <code>let</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="o">--</code><code class="nx">x</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>

<code class="kr">const</code> <code class="nx">factorial2</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="o">--</code><code class="nx">x</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial2</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">factorial2</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>
</pre></div>

</figure>

<p>But of course, it’s not exactly like <code>let</code>. It’s just different enough to present a source of confusion. First, <code>var</code> is not block scoped, it’s function scoped, just like <a href="https://leanpub.com/javascriptallongesix/read#function-declarations">function declarations</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">49</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">age</code> <code class="o">=</code> <code class="mi">50</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>
<code class="p">})()</code>
  <code class="c1">//=&gt; 50</code>
</pre></div>

</figure>

<p>Declaring <code>age</code> twice does not cause an error(!), and the inner declaration does not shadow the outer declaration. All <code>var</code> declarations behave as if they were hoisted to the top of the function, a little like function declarations.</p>

<p>But, again, it is unwise to expect consistency. A function declaration can appear anywhere within a function, but the declaration <em>and</em> the definition are hoisted. Note this example of a function that uses a helper:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">innerFactorial</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
  <code class="c1">//=&gt; 24</code>
</pre></div>

</figure>

<p>JavaScript interprets this code as if we had written:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">innerFactorial</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">innerFactorial</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">y</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">);</code>
      <code class="p">}</code>
    <code class="p">}</code>

  <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>JavaScript hoists the <code>let</code> and the assignment. But not so with <code>var</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>

  <code class="kd">var</code> <code class="nx">innerFactorial</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">innerFactorial</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined is not a function (evaluating 'innerFactorial(n, 1)')</code>
</pre></div>

</figure>

<p>JavaScript hoists the declaration, but not the assignment. It is as if we’d written:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="kd">let</code> <code class="nx">innerFactorial</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">n</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>

  <code class="nx">innerFactorial</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">innerFactorial</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">y</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">innerFactorial</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">factorial</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined is not a function (evaluating 'innerFactorial(n, 1)')</code>
</pre></div>

</figure>

<p>In that way, <code>var</code> is a little like <code>const</code> and <code>let</code>, we should always declare and bind names before using them. But it’s not like <code>const</code> and <code>let</code> in that it’s function scoped, not block scoped.</p>

<h4 id="leanpub-auto-why-const-and-let-were-invented">why <code>const</code> and <code>let</code> were invented</h4>

<p><code>const</code> and <code>let</code> are recent additions to JavaScript. For nearly twenty years, variables were declared with <code>var</code> (not counting parameters and function declarations, of course). However, its functional scope was a problem.</p>

<p>We haven’t looked at it yet, but JavaScript provides a <code>for</code> loop for your iterating pleasure and convenience. It looks a lot like the <code>for</code> loop in C. Here it is with <code>var</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="mi">100</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">sum</code> <code class="o">=</code> <code class="nx">sum</code> <code class="o">+</code> <code class="nx">i</code>
<code class="p">}</code>
<code class="nx">sum</code>
  <code class="err">#</code><code class="o">=&gt;</code> <code class="mi">5050</code>
</pre></div>

</figure>

<p>Hopefully, you can think of a faster way to calculate this sum.<sup id="fnref-gauss"><a href="https://leanpub.com/javascriptallongesix/read#fn-gauss" rel="footnote">8</a></sup> And perhaps you have noticed that <code>var i = 1</code> is tucked away instead of being at the top as we prefer. But is this ever a problem?</p>

<p>Yes. Consider this variation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">introductions</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Karl'</code><code class="p">,</code> <code class="s1">'Friedrich'</code><code class="p">,</code> <code class="s1">'Gauss'</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">introductions</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Hello, my name is "</code> <code class="o">+</code> <code class="nx">names</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
<code class="p">}</code>
<code class="nx">introductions</code>
  <code class="c1">//=&gt; [ 'Hello, my name is Karl',</code>
  <code class="c1">//     'Hello, my name is Friedrich',</code>
  <code class="c1">//     'Hello, my name is Gauss' ]</code>
</pre></div>

</figure>

<p>So far, so good. Hey, remember that functions in JavaScript are values? Let’s get fancy!</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">introductions</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Karl'</code><code class="p">,</code> <code class="s1">'Friedrich'</code><code class="p">,</code> <code class="s1">'Gauss'</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">introductions</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="nx">soAndSo</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="sb">`Hello, </code><code class="si">${</code><code class="nx">soAndSo</code><code class="si">}</code><code class="sb">, my name is </code><code class="si">${</code><code class="nx">names</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code>
<code class="p">}</code>
<code class="nx">introductions</code>
  <code class="c1">//=&gt; [ [Function],</code>
  <code class="c1">//     [Function],</code>
  <code class="c1">//     [Function] ]</code>
</pre></div>

</figure>

<p>Again, so far, so good. Let’s try one of our functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">introductions</code><code class="p">[</code><code class="mi">1</code><code class="p">](</code><code class="s1">'Raganwald'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello, Raganwald, my name is undefined'</code>
</pre></div>

</figure>

<p>What went wrong? Why didn’t it give us ‘Hello, Raganwald, my name is Friedrich’? The answer is that pesky <code>var i</code>. Remember that <code>i</code> is bound in the surrounding environment, so it’s as if we wrote:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">introductions</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Karl'</code><code class="p">,</code> <code class="s1">'Friedrich'</code><code class="p">,</code> <code class="s1">'Gauss'</code><code class="p">],</code>
    <code class="nx">i</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">introductions</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">soAndSo</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Hello, "</code> <code class="o">+</code> <code class="nx">soAndSo</code> <code class="o">+</code> <code class="s2">", my name is "</code> <code class="o">+</code> <code class="nx">names</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nx">introductions</code>
</pre></div>

</figure>

<p>Now, at the time we created each function, <code>i</code> had a sensible value, like <code>0</code>, <code>1</code>, or <code>2</code>. But at the time we <em>call</em> one of the functions, <code>i</code> has the value <code>3</code>, which is why the loop terminated. So when the function is called, JavaScript looks <code>i</code> up in its enclosing environment (its  closure, obviously), and gets the value <code>3</code>. That’s not what we want at all.</p>

<p>The error wouldn’t exist at all if we’d used <code>let</code> in the first place</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">introductions</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Karl'</code><code class="p">,</code> <code class="s1">'Friedrich'</code><code class="p">,</code> <code class="s1">'Gauss'</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">introductions</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="nx">soAndSo</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="sb">`Hello, </code><code class="si">${</code><code class="nx">soAndSo</code><code class="si">}</code><code class="sb">, my name is </code><code class="si">${</code><code class="nx">names</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code>
<code class="p">}</code>
<code class="nx">introductions</code><code class="p">[</code><code class="mi">1</code><code class="p">](</code><code class="s1">'Raganwald'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello, Raganwald, my name is Friedrich'</code>
</pre></div>

</figure>

<p>This small error was a frequent cause of confusion, and in the days when there was no block-scoped <code>let</code>, programmers would need to know how to fake it, usually with an IIFE:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">introductions</code> <code class="o">=</code> <code class="p">[],</code>
    <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Karl'</code><code class="p">,</code> <code class="s1">'Friedrich'</code><code class="p">,</code> <code class="s1">'Gauss'</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="p">((</code><code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">introductions</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="nx">soAndSo</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="sb">`Hello, </code><code class="si">${</code><code class="nx">soAndSo</code><code class="si">}</code><code class="sb">, my name is </code><code class="si">${</code><code class="nx">names</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code>
    <code class="p">}</code>
  <code class="p">})(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
<code class="nx">introductions</code><code class="p">[</code><code class="mi">1</code><code class="p">](</code><code class="s1">'Raganwald'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello, Raganwald, my name is Friedrich'</code>
</pre></div>

</figure>

<p>Now we’re creating a new inner parameter, <code>i</code> and binding it to the value of the outer <code>i</code>. This works, but <code>let</code> is so much simpler and cleaner that it was added to the language in the ECMAScript 2015 specification.</p>

<p>In this book, we will use function declarations sparingly, and not use <code>var</code> at all. That does not mean that you should follow the exact same practice in your own code: The purpose of this book is to illustrate certain principles of programming. The purpose of your own code is to get things done. The two goals are often, but not always, aligned.</p>

<h3 id="cow">Copy on Write</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/coffee-cow.jpg" alt="The Coffee Cow">
  <figcaption>The Coffee Cow</figcaption>
</figure>


<p>We’ve seen how to build lists with arrays and with linked lists. We’ve touched on an important difference between them:</p>

<ul>
  <li>When you take the rest of an array with destructuring (<code>[first, ...rest]</code>), you are given a <em>copy</em> of the elements of the array.</li>
  <li>When you take the rest of a linked list with its reference, you are given the exact same nodes of the elements of the original list.</li>
</ul>

<p>The consequence of this is that if you have an array, and you take it’s “rest,” your “child” array is a copy of the elements of the parent array. And therefore, modifications to the parent do not affect the child, and modifications to the child do not affect the parent.</p>

<p>Whereas if you have a linked list, and you take it’s “rest,” your “child” list shares its nodes with the “parent” list. And therefore, modifications to the parent also modify the child, and modifications to the child also modify the parent.</p>

<p>Let’s confirm our understanding:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">parentArray</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kr">const</code> <code class="p">[</code><code class="nx">aFirst</code><code class="p">,</code> <code class="p">...</code><code class="nx">childArray</code><code class="p">]</code> <code class="o">=</code> <code class="nx">parentArray</code><code class="p">;</code>

<code class="nx">parentArray</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"three"</code><code class="p">;</code>
<code class="nx">childArray</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"two"</code><code class="p">;</code>

<code class="nx">parentArray</code>
  <code class="c1">//=&gt; [1,2,"three"]</code>
<code class="nx">childArray</code>
  <code class="c1">//=&gt; ["two",3]</code>

<code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="p">{},</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{}</code> <code class="p">};</code>
<code class="kr">const</code> <code class="nx">parentList</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="p">}</code><code class="o">\</code>
<code class="p">}};</code>
<code class="kr">const</code> <code class="nx">childList</code> <code class="o">=</code> <code class="nx">parentList</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>

<code class="nx">parentList</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="s2">"three"</code><code class="p">;</code>
<code class="nx">childList</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="s2">"two"</code><code class="p">;</code>

<code class="nx">parentList</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":"two","rest":{"first":"three","rest":{"first":\</code>
<code class="p">{},</code><code class="s2">"rest"</code><code class="o">:</code><code class="p">{}}}}}</code>
<code class="nx">childList</code>
  <code class="c1">//=&gt; {"first":"two","rest":{"first":"three","rest":{"first":{},"rest":{}}}}</code>
</pre></div>

</figure>

<p>This is remarkably unsafe. If we <em>know</em> that a list doesn’t share any elements with another list, we can safely modify it. But how do we keep track of that? Add a bunch of bookkeeping to track references? We’ll end up reinventing reference counting and garbage collection.</p>

<h4 id="leanpub-auto-a-few-utilities">a few utilities</h4>

<p>before we go any further, let’s write a few naïve list utilities so that we can work at a slightly higher level of abstraction:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">copy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">head</code> <code class="o">=</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">tail</code> <code class="o">=</code> <code class="kc">null</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">head</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">tail</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="k">return</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">node</code><code class="p">;</code>
    <code class="kr">const</code> <code class="nx">newNode</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="p">};</code>
    <code class="nx">tail</code><code class="p">.</code><code class="nx">rest</code> <code class="o">=</code> <code class="nx">newNode</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">head</code><code class="p">,</code> <code class="nx">newNode</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">first</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">rest</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">rest</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">node</code><code class="p">),</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">first</code><code class="p">(</code><code class="nx">node</code><code class="p">),</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">delayed</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">node</code><code class="p">),</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">(</code><code class="nx">node</code><code class="p">)),</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">delayed</code> <code class="p">});</code>

<code class="kr">const</code> <code class="nx">at</code> <code class="o">=</code> <code class="p">(</code><code class="nx">index</code><code class="p">,</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">index</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">first</code><code class="p">(</code><code class="nx">list</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">at</code><code class="p">(</code><code class="nx">index</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">list</code><code class="p">));</code>
    
<code class="kr">const</code> <code class="nx">set</code> <code class="o">=</code> <code class="p">(</code><code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">list</code><code class="p">,</code> <code class="nx">originalList</code> <code class="o">=</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">index</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="p">(</code><code class="nx">list</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">originalList</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">set</code><code class="p">(</code><code class="nx">index</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">list</code><code class="p">),</code> <code class="nx">originalList</code><code class="p">)</code>
    
<code class="kr">const</code> <code class="nx">parentList</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="p">}</code><code class="o">\</code>
<code class="p">}};</code>
<code class="kr">const</code> <code class="nx">childList</code> <code class="o">=</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">parentList</code><code class="p">);</code>

<code class="nx">set</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">,</code> <code class="nx">parentList</code><code class="p">);</code>
<code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="nx">childList</code><code class="p">);</code>

<code class="nx">parentList</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":"two","rest":{"first":"three","rest":{"first":\</code>
<code class="p">{},</code><code class="s2">"rest"</code><code class="o">:</code><code class="p">{}}}}}</code>
<code class="nx">childList</code>
  <code class="c1">//=&gt; {"first":"two","rest":{"first":"three","rest":{"first":{},"rest":{}}}}</code>
</pre></div>

</figure>

<p>Our new <code>at</code> and <code>set</code> functions behave similarly to <code>array[index]</code> and <code>array[index] = value</code>. The main difference is that <code>array[index] = value</code> evaluates to <code>value</code>, while <code>set(index, value, list)</code> evaluates to the modified <code>list</code>.</p>

<h4 id="leanpub-auto-copy-on-read">copy-on-read</h4>

<p>So back to the problem of structure sharing. One strategy for avoiding problems is to be <em>pessimistic</em>. Whenever we take the rest of a list, make a copy.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">rest</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">rest</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">parentList</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="p">}</code><code class="o">\</code>
<code class="p">}};</code>
<code class="kr">const</code> <code class="nx">childList</code> <code class="o">=</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">parentList</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">newParentList</code> <code class="o">=</code> <code class="nx">set</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">,</code> <code class="nx">parentList</code><code class="p">);</code>
<code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="nx">childList</code><code class="p">);</code>

<code class="nx">parentList</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":2,"rest":{"first":"three","rest":{"first":{},"\</code>
<code class="nx">rest</code><code class="s2">":{}}}}}</code>
<code class="s2">childList</code>
<code class="s2">  //=&gt; {"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">two</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":3,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":{},"</code><code class="nx">rest</code><code class="err">"</code><code class="o">:</code><code class="p">{}}}}</code>
</pre></div>

</figure>

<p>This strategy is called “copy-on-read”, because when we attempt the parent  to “read” the value of a child of the list, we make a copy and read the copy of the child. Thereafter, we can write to the parent or the copy of the child freely.</p>

<p>As we expected, making a copy lets us modify the copy without interfering with the original. This is, however, expensive. Sometimes we don’t need to make a copy because we won’t be modifying the list. Our <code>mapWith</code> function would be very expensive if we make a copy every time we call <code>rest(node)</code>.</p>

<p>There’s also a bug: What happens when we modify the first element of a list? But before we fix that, let’s try being lazy about copying.</p>

<h4 id="leanpub-auto-copy-on-write">copy-on-write</h4>

<p>Why are we copying? In case we modify a child list. Ok, what if we do this: Make the copy when we know we are modifying the list. When do we know that? When we call <code>set</code>. We’ll restore our original definition for <code>rest</code>, but change <code>set</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">rest</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">rest</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">set</code> <code class="o">=</code> <code class="p">(</code><code class="nx">index</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">index</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">list</code><code class="p">.</code><code class="nx">rest</code> <code class="p">}</code>
    <code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="nx">list</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">set</code><code class="p">(</code><code class="nx">index</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">list</code><code class="p">.</code><code class="nx">rest</code><code class="p">)</code> <code class="p">};</code>

<code class="kr">const</code> <code class="nx">parentList</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="p">}</code><code class="o">\</code>
<code class="p">}};</code>
<code class="kr">const</code> <code class="nx">childList</code> <code class="o">=</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">parentList</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">newParentList</code> <code class="o">=</code> <code class="nx">set</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">,</code> <code class="nx">parentList</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">newChildList</code> <code class="o">=</code> <code class="nx">set</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="nx">childList</code><code class="p">);</code>
</pre></div>

</figure>

<p>Our original parent and child lists remain unmodified:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">parentList</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":2,"rest":{"first":3,"rest":{"first":{},"rest":\</code>
<code class="p">{}}}}}</code>
<code class="nx">childList</code>
  <code class="c1">//=&gt; {"first":2,"rest":{"first":3,"rest":{"first":{},"rest":{}}}}</code>
</pre></div>

</figure>

<p>But our new parent and child lists are copies that contain the desired modifications, without interfering with each other:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">newParentList</code>
  <code class="c1">//=&gt; {"first":1,"rest":{"first":2,"rest":{"first":"three","rest":{"first":{},"\</code>
<code class="nx">rest</code><code class="s2">":{}}}}}</code>
<code class="s2">newChildList</code>
<code class="s2">  //=&gt; {"</code><code class="nx">first</code><code class="s2">":"</code><code class="nx">two</code><code class="s2">","</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":3,"</code><code class="nx">rest</code><code class="s2">":{"</code><code class="nx">first</code><code class="s2">":{},"</code><code class="nx">rest</code><code class="err">"</code><code class="o">:</code><code class="p">{}}}}</code>
</pre></div>

</figure>

<p>And now functions like <code>mapWith</code> that make copies without modifying anything, work at full speed.</p>

<p>This strategy of waiting to copy until you are writing is called copy-on-write, or “COW:”</p>

<blockquote>
  <p>Copy-on-write is the name given to the policy that whenever a task attempts to make a change to the shared information, it should first create a separate (private) copy of that information to prevent its changes from becoming visible to all the other tasks.—<a href="https://en.wikipedia.org/wiki/Copy-on-write">Wikipedia</a></p>
</blockquote>

<p>Like all strategies, it makes a tradeoff: It’s much cheaper than pessimistically copying structures when you make an infrequent number of small changes, but if you tend to make a lot of changes to some that you aren’t sharing, it’s more expensive.</p>

<p>Looking at the code again, you see that the <code>copy</code> function doesn’t copy on write: It follows the pattern that while constructing something, we own it and can be liberal with mutation. Once we’re done with it and give it to someone else, we need to be conservative and use a strategy like copy-on-read or copy-on-write.</p>

<h3 id="tortoises">Tortoises, Hares, and Teleporting Turtles</h3>

<p>A good long while ago (The First Age of Internet Startups), someone asked me one of those pet algorithm questions. It was, “Write an algorithm to detect a loop in a linked list, in constant space.”</p>

<p>I’m not particularly surprised that I couldn’t think up an answer in a few minutes at the time. And to the interviewer’s credit, he didn’t terminate the interview on the spot, he asked me to describe the kinds of things going through my head.</p>

<p>I think I told him that I was trying to figure out if I could adapt a hashing algorithm such as XORing everything together. This is the “trick answer” to a question about finding a missing integer from a list, so I was trying the old, “Transform this into <a href="http://www-users.cs.york.ac.uk/susan/joke/3.htm#boil">a problem you’ve already solved</a>” meta-algorithm. We moved on from there, and he didn’t reveal the “solution.”</p>

<p>I went home and pondered the problem. I wanted to solve it. Eventually, I came up with something and tried it (In Java!) on my home PC. I sent him an email sharing my result, to demonstrate my ability to follow through. I then forgot about it for a while. Some time later, I was told that the correct solution was:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">});</code>

<code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">elements</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="nx">elements</code><code class="p">;</code>
  
  <code class="k">return</code> <code class="nx">elements</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">EMPTY</code>
    <code class="o">:</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">list</code><code class="p">(...</code><code class="nx">rest</code><code class="p">))</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">forceAppend</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list1</code><code class="p">,</code> <code class="nx">list2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">isEmpty</code><code class="p">(</code><code class="nx">list1</code><code class="p">))</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"FAIL!"</code>
  <code class="p">}</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">isEmpty</code><code class="p">(</code><code class="nx">list1</code><code class="p">.</code><code class="nx">rest</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">list1</code><code class="p">.</code><code class="nx">rest</code> <code class="o">=</code> <code class="nx">list2</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="nx">forceAppend</code><code class="p">(</code><code class="nx">list1</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">list2</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">tortoiseAndHare</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">tortoisePair</code> <code class="o">=</code> <code class="nx">aPair</code><code class="p">,</code>
      <code class="nx">harePair</code> <code class="o">=</code> <code class="nx">aPair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
  
  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isEmpty</code><code class="p">(</code><code class="nx">tortoisePair</code><code class="p">)</code> <code class="o">||</code> <code class="nx">isEmpty</code><code class="p">(</code><code class="nx">harePair</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">tortoisePair</code><code class="p">.</code><code class="nx">first</code> <code class="o">===</code> <code class="nx">harePair</code><code class="p">.</code><code class="nx">first</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
    
    <code class="nx">harePair</code> <code class="o">=</code> <code class="nx">harePair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
    
    <code class="k">if</code> <code class="p">(</code><code class="nx">isEmpty</code><code class="p">(</code><code class="nx">harePair</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">tortoisePair</code><code class="p">.</code><code class="nx">first</code> <code class="o">===</code> <code class="nx">harePair</code><code class="p">.</code><code class="nx">first</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
    
    <code class="nx">tortoisePair</code> <code class="o">=</code> <code class="nx">tortoisePair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
    <code class="nx">harePair</code> <code class="o">=</code> <code class="nx">harePair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">aList</code> <code class="o">=</code> <code class="nx">list</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>

<code class="nx">tortoiseAndHare</code><code class="p">(</code><code class="nx">aList</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>

<code class="nx">forceAppend</code><code class="p">(</code><code class="nx">aList</code><code class="p">,</code> <code class="nx">aList</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">rest</code><code class="p">);</code>

<code class="nx">tortoiseAndHare</code><code class="p">(</code><code class="nx">aList</code><code class="p">);</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>This algorithm is called “The Tortoise and the Hare,” and was discovered by Robert Floyd in the 1960s. You have two node references, and one traverses the list at twice the speed of the other. No matter how large it is, you will eventually have the fast reference equal to the slow reference, and thus you’ll detect the loop.</p>

<p>At the time, I couldn’t think of any way to use hashing to solve the problem, so I gave up and tried to fit this into a powers-of-two algorithm. My first pass at it was clumsy, but it was roughly equivalent to this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">teleportingTurtle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">speed</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
      <code class="nx">rabbit</code> <code class="o">=</code> <code class="nx">list</code><code class="p">,</code>
      <code class="nx">turtle</code> <code class="o">=</code> <code class="nx">rabbit</code><code class="p">;</code>
  
  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="nx">speed</code><code class="p">;</code> <code class="nx">i</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">rabbit</code> <code class="o">=</code> <code class="nx">rabbit</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">rabbit</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">rabbit</code> <code class="o">===</code> <code class="nx">turtle</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
    <code class="nx">turtle</code> <code class="o">=</code> <code class="nx">rabbit</code><code class="p">;</code>
    <code class="nx">speed</code> <code class="o">*=</code> <code class="mi">2</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">aList</code> <code class="o">=</code> <code class="nx">list</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>

<code class="nx">teleportingTurtle</code><code class="p">(</code><code class="nx">aList</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>

<code class="nx">forceAppend</code><code class="p">(</code><code class="nx">aList</code><code class="p">,</code> <code class="nx">aList</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">rest</code><code class="p">);</code>

<code class="nx">teleportingTurtle</code><code class="p">(</code><code class="nx">aList</code><code class="p">);</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Years later, I came across a discussion of this algorithm, <a href="http://www.penzba.co.uk/Writings/TheTeleportingTurtle.html">The Tale of the Teleporting Turtle</a>. It seems to be faster under certain circumstances, depending on the size of the loop and the relative costs of certain operations.</p>

<p>What’s interesting about these two algorithms is that they both <em>tangle</em> two separate concerns: How to traverse a data structure, and what to do with the elements that you encounter. In <a href="https://leanpub.com/javascriptallongesix/read#functional-iterators">Functional Iterators</a>, we’ll investigate one pattern for separating these concerns.</p>

<h3 id="functional-iterators">Functional Iterators</h3>

<p>Let’s consider a remarkably simple problem: Finding the sum of the elements of an array. In tail-recursive style, it looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arraySum</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">],</code> <code class="nx">accumulator</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">accumulator</code>
    <code class="o">:</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">first</code> <code class="o">+</code> <code class="nx">accumulator</code><code class="p">)</code>

<code class="nx">arraySum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>As we saw earlier, this entangles the mechanism of traversing the array with the business of summing the bits. So we can separate them using <code>fold</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callLeft</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">,</code> <code class="p">...</code><code class="nx">remainingArgs</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">foldArrayWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">terminalValue</code>
    <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">foldArrayWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="nx">rest</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">arraySum</code> <code class="o">=</code> <code class="nx">callLeft</code><code class="p">(</code><code class="nx">foldArrayWith</code><code class="p">,</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>

<code class="nx">arraySum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>The nice thing about this is that the definition for <code>arraySum</code> mostly concerns itself with summing, and not with traversing over a collection of data. But it still relies on <code>foldArrayWith</code>, so it can only sum arrays.</p>

<p>What happens when we want to sum a tree of numbers? Or a linked list of numbers?</p>

<p>Well, we call <code>arraySum</code> with an array, and it has baked into it a method for traversing the array. Perhaps we could extract both of those things. Let’s rearrange our code a bit:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callRight</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">foldArrayWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">terminalValue</code>
    <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">foldArrayWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="nx">rest</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">foldArray</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">callRight</code><code class="p">(</code><code class="nx">foldArrayWith</code><code class="p">,</code> <code class="nx">array</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">sumFoldable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">folder</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">folder</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>

<code class="nx">sumFoldable</code><code class="p">(</code><code class="nx">foldArray</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">]))</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>What we’ve done is turn an array into a function that folds an array with <code>const foldArray = (array) =&gt; callRight(foldArrayWith, array);</code>. The <code>sumFoldable</code> function doesn’t care what kind of data structure we have, as long as it’s foldable.</p>

<p>Here it is summing a tree of numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">callRight</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">fn</code><code class="p">(...</code><code class="nx">remainingArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">foldTreeWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">])</code> <code class="o">=&gt;</code>
  <code class="nx">first</code> <code class="o">===</code> <code class="kc">undefined</code>
    <code class="o">?</code> <code class="nx">terminalValue</code>
    <code class="o">:</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
      <code class="o">?</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">foldTreeWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="nx">first</code><code class="p">),</code> <code class="nx">foldTreeWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValu</code><code class="o">\</code>
<code class="nx">e</code><code class="p">,</code> <code class="nx">rest</code><code class="p">))</code>
      <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">foldTreeWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">terminalValue</code><code class="p">,</code> <code class="nx">rest</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">foldTree</code> <code class="o">=</code> <code class="p">(</code><code class="nx">tree</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">callRight</code><code class="p">(</code><code class="nx">foldTreeWith</code><code class="p">,</code> <code class="nx">tree</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">sumFoldable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">folder</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">folder</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>

<code class="nx">sumFoldable</code><code class="p">(</code><code class="nx">foldTree</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="p">[</code><code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">]],</code> <code class="mi">25</code><code class="p">]))</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>We’ve found another way to express the principle of separating traversing a data structure from the operation we want to perform on that data structure, we’ve completely separated the knowledge of how to sum from the knowledge of how to fold an array or tree (or anything else, really).</p>

<h4 id="leanpub-auto-iterating">iterating</h4>

<p>Folding is a universal operation, and with care we can accomplish any task with folds that could be accomplished with that stalwart of structured programming, the <code>for</code> loop. Nevertheless, there is some value in being able to express some algorithms as iteration.</p>

<p>JavaScript has a particularly low-level version of <code>for</code> loop that mimics the semantics of the <code>C</code> language. Summing the elements of an array can be accomplished with:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arraySum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">arraySum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>Once again, we’re mixing the code for iterating over an array with the code for calculating a sum. And worst of all, we’re getting really low-level with details like knowing that the elements of an array are indexed with consecutive integers that begin with <code>0</code>.</p>

<p>We can write this a slightly different way, using a <code>while</code> loop:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arraySum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">done</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">done</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">==</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code> <code class="o">!</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">];</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">arraySum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>Notice that buried inside our loop, we have bound the names <code>done</code> and <code>value</code>. We can put those into a POJO (a <a href="https://leanpub.com/javascriptallongesix/read#pojos">Plain Old JavaScript Object</a>). It’ll be a little awkward, but we’ll be patient:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arraySum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">iter</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">index</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">(</code>
    <code class="p">(</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">done</code><code class="o">:</code> <code class="nx">index</code> <code class="o">===</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code>
        <code class="nx">value</code><code class="o">:</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code> <code class="o">?</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">:</code> <code class="kc">undefined</code>
      <code class="p">},</code>
      <code class="o">++</code><code class="nx">index</code><code class="p">,</code>
      <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code>
    <code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">arraySum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">])</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>With this code, we make a POJO that has <code>done</code> and <code>value</code> keys. All the summing code needs to know is to add <code>eachIteration.value</code>. Now we can extract the ickiness into a separate function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arrayIterator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">done</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">===</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">done</code><code class="p">,</code>
      <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">iteratorSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">iteratorSum</code><code class="p">(</code><code class="nx">arrayIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">]))</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>Now this is something else. The <code>arrayIterator</code> function takes an array and returns a function we can call repeatedly to obtain the elements of the array. The <code>iteratorSum</code> function iterates over the elements by calling the <code>iterator</code> function repeatedly until it returns <code>{ done: true }</code>.</p>

<p>We can write a different iterator for a different data structure. Here’s one for linked lists:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">});</code>

<code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">elements</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="nx">elements</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">elements</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">EMPTY</code>
    <code class="o">:</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">list</code><code class="p">(...</code><code class="nx">rest</code><code class="p">))</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">print</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">isEmpty</code><code class="p">(</code><code class="nx">aPair</code><code class="p">)</code>
    <code class="o">?</code> <code class="s2">""</code>
    <code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">aPair</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="sb"> </code><code class="si">${</code><code class="nx">print</code><code class="p">(</code><code class="nx">aPair</code><code class="p">.</code><code class="nx">rest</code><code class="p">)</code><code class="si">}</code><code class="sb">`</code>

<code class="kr">const</code> <code class="nx">listIterator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">done</code> <code class="o">=</code> <code class="nx">isEmpty</code><code class="p">(</code><code class="nx">aPair</code><code class="p">);</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="p">};</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="p">{</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">}</code> <code class="o">=</code> <code class="nx">aPair</code><code class="p">;</code>

      <code class="nx">aPair</code> <code class="o">=</code> <code class="nx">aPair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
      <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">first</code> <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">iteratorSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">aListIterator</code> <code class="o">=</code> <code class="nx">listIterator</code><code class="p">(</code><code class="nx">list</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">));</code>

<code class="nx">iteratorSum</code><code class="p">(</code><code class="nx">aListIterator</code><code class="p">)</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-unfolding-and-laziness">unfolding and laziness</h4>

<p>Iterators are functions. When they iterate over an array or linked list, they are traversing something that is already there. But they could just as easily manufacture the data as they go. Let’s consider the simplest example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">NumberIterator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">number</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">({</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">number</code><code class="o">++</code> <code class="p">})</code>

<code class="nx">fromOne</code> <code class="o">=</code> <code class="nx">NumberIterator</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>

<code class="nx">fromOne</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">fromOne</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="c1">//=&gt; 2</code>
<code class="nx">fromOne</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="c1">//=&gt; 3</code>
<code class="nx">fromOne</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="c1">//=&gt; 4</code>
<code class="nx">fromOne</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<p>And here’s another one:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">FibonacciIterator</code>  <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">previous</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">current</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">current</code><code class="p">;</code>

    <code class="p">[</code><code class="nx">previous</code><code class="p">,</code> <code class="nx">current</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">current</code><code class="p">,</code> <code class="nx">current</code> <code class="o">+</code> <code class="nx">previous</code><code class="p">];</code>
    <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="p">};</code>
  <code class="p">};</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">fib</code> <code class="o">=</code> <code class="nx">FibonacciIterator</code><code class="p">()</code>

<code class="nx">fib</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">fib</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">fib</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 2</code>
<code class="nx">fib</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 3</code>
<code class="nx">fib</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 5</code>
</pre></div>

</figure>

<p>A function that starts with a seed and expands it into a data structure is called an <em>unfold</em>. It’s the opposite of a fold. It’s possible to write a generic unfold mechanism, but let’s pass on to what we can do with unfolded iterators.</p>

<p>For starters, we can <code>map</code> an iterator, just like we map a collection:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapIteratorWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">();</code>

    <code class="k">return</code> <code class="p">({</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">)});</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">squares</code> <code class="o">=</code> <code class="nx">mapIteratorWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">NumberIterator</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>

<code class="nx">squares</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">squares</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 4</code>
<code class="nx">squares</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 9</code>
</pre></div>

</figure>

<p>This business of going on forever has some drawbacks. Let’s introduce an idea: A function that takes an iterator and returns another iterator. We can start with <code>take</code>, an easy function that returns an iterator that only returns a fixed number of elements:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">take</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterator</code><code class="p">,</code> <code class="nx">numberToTake</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">++</code><code class="nx">count</code> <code class="o">&lt;=</code> <code class="nx">numberToTake</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">iterator</code><code class="p">();</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">toArray</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">array</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">array</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">toArray</code><code class="p">(</code><code class="nx">take</code><code class="p">(</code><code class="nx">FibonacciIterator</code><code class="p">(),</code> <code class="mi">5</code><code class="p">))</code>
  <code class="c1">//=&gt; [1, 1, 2, 3, 5]</code>

<code class="nx">toArray</code><code class="p">(</code><code class="nx">take</code><code class="p">(</code><code class="nx">squares</code><code class="p">,</code> <code class="mi">5</code><code class="p">))</code>
  <code class="c1">//=&gt; [1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>How about the squares of the first five odd numbers? We’ll need an iterator that produces odd numbers. We can write that directly:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">odds</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">number</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">number</code><code class="p">;</code>

    <code class="nx">number</code> <code class="o">+=</code> <code class="mi">2</code><code class="p">;</code>
    <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="p">};</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">squareOf</code> <code class="o">=</code> <code class="nx">callLeft</code><code class="p">(</code><code class="nx">mapIteratorWith</code><code class="p">,</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>

<code class="nx">toArray</code><code class="p">(</code><code class="nx">take</code><code class="p">(</code><code class="nx">squareOf</code><code class="p">(</code><code class="nx">odds</code><code class="p">()),</code> <code class="mi">5</code><code class="p">))</code>
  <code class="c1">//=&gt; [1, 9, 25, 49, 81]</code>
</pre></div>

</figure>

<p>We could also write a filter for iterators to accompany our mapping function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">filterIteratorWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">do</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">();</code>
    <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">));</code>
    <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">};</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">oddsOf</code> <code class="o">=</code> <code class="nx">callLeft</code><code class="p">(</code><code class="nx">filterIteratorWith</code><code class="p">,</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">toArray</code><code class="p">(</code><code class="nx">take</code><code class="p">(</code><code class="nx">squareOf</code><code class="p">(</code><code class="nx">oddsOf</code><code class="p">(</code><code class="nx">NumberIterator</code><code class="p">(</code><code class="mi">1</code><code class="p">))),</code> <code class="mi">5</code><code class="p">))</code>
  <code class="c1">//=&gt; [1, 9, 25, 49, 81]</code>
</pre></div>

</figure>

<p>Mapping and filtering iterators allows us to compose the parts we already have, rather than writing a tricky bit of code with ifs and whiles and boundary conditions.</p>

<h4 id="leanpub-auto-bonus">bonus</h4>

<p>Many programmers coming to JavaScript from other languages are familiar with three “canonical” operations on collections: folding, filtering, and finding. In Smalltalk, for example, they are known as <code>collect</code>, <code>select</code>, and <code>detect</code>.</p>

<p>We haven’t written anything that finds the first element of an iteration that meets a certain criteria. Or have we?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstInIteration</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">take</code><code class="p">(</code><code class="nx">filterIteratorWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterator</code><code class="p">),</code> <code class="mi">1</code><code class="p">);</code>
</pre></div>

</figure>

<p>This is interesting, because it is lazy: It doesn’t apply <code>fn</code> to every element in an iteration, just enough to find the first that passes the test. Whereas if we wrote something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstInArray</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">fn</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>
</pre></div>

</figure>

<p>JavaScript would apply <code>fn</code> to every element. If <code>array</code> was very large, and <code>fn</code> very slow, this would consume a lot of unnecessary time. And if <code>fn</code> had some sort of side-effect, the program could be buggy.</p>

<h4 id="leanpub-auto-caveat">caveat</h4>

<p>Please note that unlike most of the other functions discussed in this book, iterators are <em>stateful</em>. There are some important implications of stateful functions. One is that while functions like <code>take(...)</code> appear to create an entirely new iterator, in reality they return a decorated reference to the original iterator. So as you traverse the new decorator, you’re changing the state of the original!</p>

<p>For all intents and purposes, once you pass an iterator to a function, you can expect that you no longer “own” that iterator, and that its state either has changed or will change.</p>

<h3 id="leanpub-auto-making-data-out-of-functions">Making Data Out Of Functions</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/cern-coffee.jpg" alt="Coffee served at the CERN particle accelerator">
  <figcaption>Coffee served at the CERN particle accelerator</figcaption>
</figure>


<p>In our code so far, we have used arrays and objects to represent the structure of data, and we have extensively used the ternary operator to write algorithms that terminate when we reach a base case.</p>

<p>For example, this <code>length</code> function uses a functions to bind values to names, POJOs to structure nodes, and the ternary function to detect the base case, the empty list.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kr">const</code> <code class="nx">OneTwoThree</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">rest</code><code class="o">:</code> <code class="nx">EMPTY</code> <code class="o">\</code>
<code class="p">}</code> <code class="p">}</code> <code class="p">};</code>

<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">first</code>
  <code class="c1">//=&gt; 1</code>
  
<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">first</code>
  <code class="c1">//=&gt; 2</code>
  
<code class="nx">OneTwoThree</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">rest</code><code class="p">.</code><code class="nx">first</code>
  <code class="c1">//=&gt; 3</code>
  
<code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">length</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">length</code><code class="p">(</code><code class="nx">OneTwoThree</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>A very long time ago, mathematicians like Alonzo Church, Moses Schönfinkel, Alan Turning, and Haskell Curry and asked themselves if we really needed all these features to perform computations. They searched for a radically simpler set of tools that could accomplish all of the same things.</p>

<p>They established that arbitrary computations could be represented a small set of axiomatic components. For example, we don’t need arrays to represent lists, or even POJOs to represent nodes in a linked list. We can model lists just using functions.</p>

<blockquote>
  <p><a href="http://www.amazon.com/gp/product/0192801422/ref=as_li_ss_tl?ie=UTF8&amp;tag=raganwald001-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0192801422">To Mock a Mockingbird</a> established the metaphor of songbirds for the combinators, and ever since then logicians have called the K combinator a “kestrel,” the B combinator a “bluebird,” and so forth. </p>
</blockquote>

<blockquote>
  <p>The <a href="http://oscin.es/">oscin.es</a> library contains code for all of the standard combinators and for experimenting using the standard notation.</p>
</blockquote>

<p>Let’s start with some of the building blocks of combinatory logic, the K, I, and V combinators, nicknamed the “Kestrel”, the “Idiot Bird”, and the “Vireo:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">K</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">I</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">V</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">z</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">z</code><code class="p">(</code><code class="nx">x</code><code class="p">)(</code><code class="nx">y</code><code class="p">);</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-the-kestrel-and-the-idiot">the kestrel and the idiot</h4>

<p>A <em>constant function</em> is a function that always returns the same thing, no matter what you give it. For example, <code>(x) =&gt; 42</code> is a constant function that always evaluates to 42. The kestrel, or <code>K</code>, is a function that makes constant functions. You give it a value, and it returns a constant function that gives that value.</p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">K</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">fortyTwo</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>

<code class="nx">fortyTwo</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>
  <code class="c1">//=&gt; 42</code>

<code class="nx">fortyTwo</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">)</code>
  <code class="c1">//=&gt; 42</code>
</pre></div>

</figure>

<p>The <em>identity function</em> is a function that evaluates to whatever parameter you pass it. So <code>I(42) =&gt; 42</code>. Very simple, but useful. Now we’ll take it one more step forward: Passing a value to <code>K</code> gets a function back, and passing a value to that function gets us a value.</p>

<p>Like so:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">K</code><code class="p">(</code><code class="mi">6</code><code class="p">)(</code><code class="mi">7</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>
  
<code class="nx">K</code><code class="p">(</code><code class="mi">12</code><code class="p">)(</code><code class="mi">24</code><code class="p">)</code>
  <code class="c1">//=&gt; 12</code>
</pre></div>

</figure>

<p>This is very interesting. Given two values, we can say that <code>K</code> always returns the <em>first</em> value: <code>K(x)(y) =&gt; x</code> (that’s not valid JavaScript, but it’s essentially how it works).</p>

<p>Now, an interesting thing happens when we pass functions to each other. Consider <code>K(I)</code>. From what we just wrote, <code>K(x)(y) =&gt; x</code> So <code>K(I)(x) =&gt; I</code>. Makes sense. Now let’s tack one more invocation on: What is <code>K(I)(x)(y)</code>? If <code>K(I)(x) =&gt; I</code>, then <code>K(I)(x)(y) === I(y)</code> which is <code>y</code>.</p>

<p>Therefore, <code>K(I)(x)(y) =&gt; y</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">)(</code><code class="mi">6</code><code class="p">)(</code><code class="mi">7</code><code class="p">)</code>
  <code class="c1">//=&gt; 7</code>
  
<code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">)(</code><code class="mi">12</code><code class="p">)(</code><code class="mi">24</code><code class="p">)</code>
  <code class="c1">//=&gt; 24</code>
</pre></div>

</figure>

<p>Aha! Given two values, <code>K(I)</code> always returns the <em>second</em> value.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">K</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">)(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>If we are not feeling particularly academic, we can name our functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">);</code>
      
<code class="nx">first</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">second</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<blockquote>
  <p>This is very interesting. Given two values, we can say that <code>K</code> always returns the <em>first</em> value, and given two values, <code>K(I)</code> always returns the <em>second</em> value.</p>
</blockquote>

<h4 id="leanpub-auto-backwardness">backwardness</h4>

<p>Our <code>first</code> and <code>second</code> functions are a little different than what most people are used to when we talk about functions that access data. If we represented a pair of values as an array, we’d write them like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">first</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="p">([</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">second</code><code class="p">;</code>
      
<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"primus"</code><code class="p">,</code> <code class="s2">"secundus"</code><code class="p">];</code>
      
<code class="nx">first</code><code class="p">(</code><code class="nx">latin</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">second</code><code class="p">(</code><code class="nx">latin</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>Or if we were using a POJO, we’d write them like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">first</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">second</code><code class="p">;</code>
      
<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s2">"primus"</code><code class="p">,</code> <code class="nx">second</code><code class="o">:</code> <code class="s2">"secundus"</code><code class="p">};</code>
      
<code class="nx">first</code><code class="p">(</code><code class="nx">latin</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">second</code><code class="p">(</code><code class="nx">latin</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>In both cases, the functions <code>first</code> and <code>second</code> know how the data is represented, whether it be an array or an object. You pass the data to these functions, and they extract it.</p>

<p>But the <code>first</code> and <code>second</code> we built out of <code>K</code> and <code>I</code> don’t work that way. You call them and pass them the bits, and they choose what to return. So if we wanted to use them with a two-element array, we’d need to have a piece of code that calls some code.</p>

<p>Here’s the first cut:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">);</code>
      
<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="p">(</code><code class="nx">selector</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">selector</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">);</code>

<code class="nx">latin</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">latin</code><code class="p">(</code><code class="nx">second</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>Our <code>latin</code> data structure is no longer a dumb data structure, it’s a function. And instead of passing <code>latin</code> to <code>first</code> or <code>second</code>, we pass <code>first</code> or <code>second</code> to <code>latin</code>. It’s <em>exactly backwards</em> of the way we write functions that operate on data.</p>

<h4 id="leanpub-auto-the-vireo">the vireo</h4>

<p>Given that our <code>latin</code> data is represented as the function <code>(selector) =&gt; selector("primus")("secundus")</code>, our obvious next step is to make a function that makes data. For arrays, we’d write <code>cons = (first, second) =&gt; [first, second]</code>. For objects we’d write: <code>cons = (first, second) =&gt; {first, second}</code>. In both cases, we take two parameters, and return the form of the data.</p>

<p>For “data” we access with <code>K</code> and <code>K(I)</code>, our “structure” is the function <code>(selector) =&gt; selector("primus")("secundus")</code>. Let’s extract those into parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">selector</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">selector</code><code class="p">(</code><code class="nx">first</code><code class="p">)(</code><code class="nx">second</code><code class="p">)</code>
</pre></div>

</figure>

<p>For consistency with the way combinators are written as functions taking just one parameter, we’ll <a href="https://en.wikipedia.org/wiki/Currying">curry</a> the function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">selector</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">selector</code><code class="p">(</code><code class="nx">first</code><code class="p">)(</code><code class="nx">second</code><code class="p">)</code>
</pre></div>

</figure>

<p>Let’s try it, we’ll use the word <code>pair</code> for the function that makes data (When we need to refer to a specific pair, we’ll use the name <code>aPair</code> by default):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">),</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">selector</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">selector</code><code class="p">(</code><code class="nx">first</code><code class="p">)(</code><code class="nx">second</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="nx">pair</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">);</code>

<code class="nx">latin</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">latin</code><code class="p">(</code><code class="nx">second</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>It works! Now what is this <code>pair</code> function? If we change the names to <code>x</code>, <code>y</code>, and <code>z</code>, we get: <code>(x) =&gt; (y) =&gt; (z) =&gt; z(x)(y)</code>. That’s the V combinator, the Vireo! So we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">),</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="nx">V</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="nx">pair</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">);</code>

<code class="nx">latin</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">latin</code><code class="p">(</code><code class="nx">second</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<blockquote>
  <p>As an aside, the Vireo is a little like JavaScript’s <code>.apply</code> function. It says, “take these two values and apply them to this function.” There are other, similar combinators that apply values to functions. One notable example is the “thrush” or T combinator: It takes one value and applies it to a function. It is known to most programmers as <code>.tap</code>.</p>
</blockquote>

<p>Armed with nothing more than <code>K</code>, <code>I</code>, and <code>V</code>, we can make a little data structure that holds two values, the <code>cons</code> cell of Lisp and the node of a linked list. Without arrays, and without objects, just with functions. We’d better try it out to check.</p>

<h4 id="leanpub-auto-lists-with-functions-as-data">lists with functions as data</h4>

<p>Here’s another look at linked lists using POJOs. We use the term <code>rest</code> instead of <code>second</code>, but it’s otherwise identical to what we have above:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">first</code><code class="p">,</code>
      <code class="nx">rest</code>  <code class="o">=</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="nx">rest</code><code class="p">,</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code><code class="p">}),</code>
      <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">({});</code>
      
<code class="kr">const</code> <code class="nx">l123</code> <code class="o">=</code> <code class="nx">pair</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="nx">pair</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="nx">pair</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="nx">EMPTY</code><code class="p">)));</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">l123</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">l123</code><code class="p">))</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">l123</code><code class="p">)))</code>
  <code class="c1">//=3</code>
</pre></div>

</figure>

<p>We can write <code>length</code> and <code>mapWith</code> functions over it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">aPair</code><code class="p">));</code>

<code class="nx">length</code><code class="p">(</code><code class="nx">l123</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>

<code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">aPair</code><code class="p">),</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">first</code><code class="p">(</code><code class="nx">aPair</code><code class="p">),</code> <code class="nx">delayed</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">aPair</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">delayed</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">rest</code><code class="p">(</code><code class="nx">aPair</code><code class="p">),</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">first</code><code class="p">(</code><code class="nx">aPair</code><code class="p">)),</code> <code class="nx">delayed</code><code class="p">));</code>
    
<code class="kr">const</code> <code class="nx">doubled</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">l123</code><code class="p">);</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">doubled</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">doubled</code><code class="p">))</code>
  <code class="c1">//=&gt; 4</code>

<code class="nx">first</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">rest</code><code class="p">(</code><code class="nx">doubled</code><code class="p">)))</code>
  <code class="c1">//=&gt; 6</code>
</pre></div>

</figure>

<p>Can we do the same with the linked lists we build out of functions? Yes:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">rest</code>  <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">),</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="nx">V</code><code class="p">,</code>
      <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{});</code>
      
<code class="kr">const</code> <code class="nx">l123</code> <code class="o">=</code> <code class="nx">pair</code><code class="p">(</code><code class="mi">1</code><code class="p">)(</code><code class="nx">pair</code><code class="p">(</code><code class="mi">2</code><code class="p">)(</code><code class="nx">pair</code><code class="p">(</code><code class="mi">3</code><code class="p">)(</code><code class="nx">EMPTY</code><code class="p">)));</code>

<code class="nx">l123</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>

<code class="nx">l123</code><code class="p">(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="k">return</code> <code class="nx">l123</code><code class="p">(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>We write them in a backwards way, but they seem to work. How about <code>length</code>?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">rest</code><code class="p">));</code>
    
<code class="nx">length</code><code class="p">(</code><code class="nx">l123</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>And <code>mapWith</code>?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">rest</code><code class="p">),</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">first</code><code class="p">))(</code><code class="nx">delayed</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">aPair</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">delayed</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">aPair</code><code class="p">(</code><code class="nx">rest</code><code class="p">),</code> <code class="nx">pair</code><code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">first</code><code class="p">)))(</code><code class="nx">delayed</code><code class="p">));</code>
    
<code class="kr">const</code> <code class="nx">doubled</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">l123</code><code class="p">)</code>

<code class="nx">doubled</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">doubled</code><code class="p">(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 4</code>

<code class="nx">doubled</code><code class="p">(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">rest</code><code class="p">)(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>
</pre></div>

</figure>

<p>Presto, <strong>we can use pure functions to represent a linked list</strong>. And with care, we can do amazing things like use functions to represent numbers, build more complex data structures like trees, and in fact, anything that can be computed can be computed using just functions and nothing else.</p>

<p>But without building our way up to something insane like writing a JavaScript interpreter using JavaScript functions and no other data structures, let’s take things another step in a slightly different direction.</p>

<p>We used functions to replace arrays and POJOs, but we still use JavaScript’s built-in operators to test for equality (<code>===</code>) and to branch <code>?:</code>.</p>

<h4 id="leanpub-auto-say-please">say “please”</h4>

<p>We keep using the same pattern in our functions: <code>aPair === EMPTY ? doSomething : doSomethingElse</code>. This follows the philosophy we used with data structures: The function doing the work inspects the data structure.</p>

<p>We can reverse this: Instead of asking a pair if it is empty and then deciding what to do, we can ask the pair to do it for us. Here’s <code>length</code> again:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">aPair</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">rest</code><code class="p">));</code>
</pre></div>

</figure>

<p>Let’s presume we are working with a slightly higher abstraction, we’ll call it a <code>list</code>. Instead of writing <code>length(list)</code> and examining a list, we’ll write something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">,</code>
  <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">rest</code><code class="p">)))</code>
<code class="p">);</code>
</pre></div>

</figure>

<p>Now we’ll need to write <code>first</code> and <code>rest</code> functions for a list, and those names will collide with the <code>first</code> and <code>rest</code> we wrote for pairs. So let’s disambiguate our names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">pairFirst</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">pairRest</code>  <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">),</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="nx">V</code><code class="p">;</code>
      
<code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"ERROR: Can't take first of an empty list"</code><code class="p">,</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">aPair</code><code class="p">(</code><code class="nx">pairFirst</code><code class="p">)</code>
  <code class="p">);</code>
      
<code class="kr">const</code> <code class="nx">rest</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"ERROR: Can't take first of an empty list"</code><code class="p">,</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">)</code>
  <code class="p">);</code>

<code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">,</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">)))</code>
  <code class="p">);</code>
</pre></div>

</figure>

<p>We’ll also write a handy list printer:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">print</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">""</code><code class="p">,</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="sb">`</code><code class="si">${</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairFirst</code><code class="p">)</code><code class="si">}</code><code class="sb"> </code><code class="si">${</code><code class="nx">print</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">))</code><code class="si">}</code><code class="sb">`</code>
  <code class="p">);</code>
</pre></div>

</figure>

<p>How would all this work? Let’s start with the obvious. What is an empty list?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTYLIST</code> <code class="o">=</code> <code class="p">(</code><code class="nx">whenEmpty</code><code class="p">,</code> <code class="nx">unlessEmpty</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">whenEmpty</code><code class="p">()</code>
</pre></div>

</figure>

<p>And what is a node of a list?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">node</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">whenEmpty</code><code class="p">,</code> <code class="nx">unlessEmpty</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">unlessEmpty</code><code class="p">(</code><code class="nx">pair</code><code class="p">(</code><code class="nx">x</code><code class="p">)(</code><code class="nx">y</code><code class="p">));</code>
</pre></div>

</figure>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">l123</code> <code class="o">=</code> <code class="nx">node</code><code class="p">(</code><code class="mi">1</code><code class="p">)(</code><code class="nx">node</code><code class="p">(</code><code class="mi">2</code><code class="p">)(</code><code class="nx">node</code><code class="p">(</code><code class="mi">3</code><code class="p">)(</code><code class="nx">EMPTYLIST</code><code class="p">)));</code>

<code class="nx">print</code><code class="p">(</code><code class="nx">l123</code><code class="p">)</code>
  <code class="c1">//=&gt; 1 2 3</code>
</pre></div>

</figure>

<p>We can write <code>reverse</code> and <code>mapWith</code> as well. We aren’t being super-strict about emulating combinatory logic, we’ll use default parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reverse</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTYLIST</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
  <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">delayed</code><code class="p">,</code>
  <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">),</code> <code class="nx">node</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairFirst</code><code class="p">))(</code><code class="nx">delayed</code><code class="p">))</code>
<code class="p">);</code>

<code class="nx">print</code><code class="p">(</code><code class="nx">reverse</code><code class="p">(</code><code class="nx">l123</code><code class="p">));</code>
  <code class="c1">//=&gt; 3 2 1</code>
  
<code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">list</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="nx">EMPTYLIST</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">delayed</code><code class="p">),</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">),</code> <code class="nx">node</code><code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairFirst</code><code class="p">)))(</code><code class="nx">delayed</code><code class="p">))</code>
  <code class="p">);</code>
  
<code class="nx">print</code><code class="p">(</code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">reverse</code><code class="p">(</code><code class="nx">l123</code><code class="p">)))</code>
  <code class="c1">//=&gt; 941</code>
</pre></div>

</figure>

<p>We have managed to provide the exact same functionality that <code>===</code> and <code>?:</code> provided, but using functions and nothing else.</p>

<h4 id="leanpub-auto-functions-are-not-the-real-point">functions are not the real point</h4>

<p>There are lots of similar texts explaining how to construct complex semantics out of functions. You can establish that <code>K</code> and <code>K(I)</code> can represent <code>true</code> and <code>false</code>, model magnitudes with <a href="https://en.wikipedia.org/wiki/Church_encoding">Church Numerals</a> or <a href="https://en.wikipedia.org/wiki/Surreal_number">Surreal Numbers</a>, and build your way up to printing FizzBuzz.</p>

<p>The superficial conclusion reads something like this:</p>

<blockquote>
  <p>Functions are a fundamental building block of computation. They are “axioms” of combinatory logic, and can be used to compute anything that JavaScript can compute.</p>
</blockquote>

<p>However, that is not the interesting thing to note here. Practically speaking, languages like JavaScript already provide arrays with mapping and folding methods, choice operations, and other rich constructs. Knowing how to make a linked list out of functions is not really necessary for the working programmer. (Knowing that it can be done, on the other hand, is very important to understanding computer science.)</p>

<p>Knowing how to make a list out of just functions is a little like knowing that photons are the <a href="https://en.wikipedia.org/wiki/Gauge_boson">Gauge Bosons</a> of the electromagnetic force. It’s the QED of physics that underpins the Maxwell’s Equations of programming. Deeply important, but not practical when you’re building a bridge.</p>

<p>So what <em>is</em> interesting about this? What nags at our brain as we’re falling asleep after working our way through this?</p>

<h4 id="leanpub-auto-a-return-to-backward-thinking">a return to backward thinking</h4>

<p>To make pairs work, we did things <em>backwards</em>, we passed the <code>first</code> and <code>rest</code> functions to the pair, and the pair called our function. As it happened, the pair was composed by the vireo (or V combinator): <code>(x) =&gt; (y) =&gt; (z) =&gt; z(x)(y)</code>.</p>

<p>But we could have done something completely different. We could have written a pair that stored its elements in an array, or a pair that stored its elements in a POJO. All we know is that we can pass the pair function a function of our own, at it will be called with the elements of the pair.</p>

<p>The exact implementation of a pair is hidden from the code that uses a pair. Here, we’ll prove it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="nx">K</code><code class="p">,</code>
      <code class="nx">second</code> <code class="o">=</code> <code class="nx">K</code><code class="p">(</code><code class="nx">I</code><code class="p">),</code>
      <code class="nx">pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">pojo</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">};</code>
        
        <code class="k">return</code> <code class="p">(</code><code class="nx">selector</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">selector</code><code class="p">(</code><code class="nx">pojo</code><code class="p">.</code><code class="nx">first</code><code class="p">)(</code><code class="nx">pojo</code><code class="p">.</code><code class="nx">second</code><code class="p">);</code>
      <code class="p">};</code>

<code class="kr">const</code> <code class="nx">latin</code> <code class="o">=</code> <code class="nx">pair</code><code class="p">(</code><code class="s2">"primus"</code><code class="p">)(</code><code class="s2">"secundus"</code><code class="p">);</code>

<code class="nx">latin</code><code class="p">(</code><code class="nx">first</code><code class="p">)</code>
  <code class="c1">//=&gt; "primus"</code>
  
<code class="nx">latin</code><code class="p">(</code><code class="nx">second</code><code class="p">)</code>
  <code class="c1">//=&gt; "secundus"</code>
</pre></div>

</figure>

<p>This is a little gratuitous, but it makes the point: The code that uses the data doesn’t reach in and touch it: The code that uses the data provides some code and asks the data to do something with it.</p>

<p>The same thing happens with our lists. Here’s <code>length</code> for lists:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">(</code>
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">,</code>
    <code class="p">(</code><code class="nx">aPair</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">1</code> <code class="o">+</code> <code class="nx">length</code><code class="p">(</code><code class="nx">aPair</code><code class="p">(</code><code class="nx">pairRest</code><code class="p">)))</code>
  <code class="p">);</code>
</pre></div>

</figure>

<p>We’re passing <code>list</code> what we want done with an empty list, and what we want done with a list that has at least one element. We then ask <code>list</code> to do it, and provide a way for <code>list</code> to call the code we pass in.</p>

<p>We won’t bother here, but it’s easy to see how to swap our functions out and replace them with an array. Or a column in a database. This is fundamentally <em>not</em> the same thing as this code for the length of a linked list:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code>
    <code class="o">?</code> <code class="nx">delayed</code>
    <code class="o">:</code> <code class="nx">length</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">rest</code><code class="p">,</code> <code class="nx">delayed</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>
</pre></div>

</figure>

<p>The line <code>node === EMPTY</code> presumes a lot of things. It presumes there is one canonical empty list value. It presumes you can compare these things with the <code>===</code> operator. We can fix this with an <code>isEmpty</code> function, but now we’re pushing even more knowledge about the structure of lists into the code that uses them.</p>

<p>Having a list know itself whether it is empty hides implementation information from the code that uses lists. This is a fundamental principle of good design. It is a tenet of Object-Oriented Programming, but it is <strong>not</strong> exclusive to OOP: We can and should design data structures to hide implementation information from the code that use them, whether we are working with functions, objects, or both.</p>

<p>There are many tools for hiding implementation information, and we have now seen two particularly powerful patterns:</p>

<ul>
  <li>Instead of directly manipulating part of an entity, pass it a function and have it call our function with the part we want.</li>
  <li>And instead of testing some property of an entity and making a choice of our own with <code>?:</code> (or <code>if</code>), pass the entity the work we want done for each case and let it test itself.</li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn-getify">Kyle Simpson is the author of <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/README.md#you-dont-know-js-book-series">You Don’t Know JS</a>, available <a href="http://search.oreilly.com/?q=you+don%27t+know+js+kyle+simpson">here</a><a href="https://leanpub.com/javascriptallongesix/read#fnref-getify" rel="rev-footnote">↩</a>
</li>
    <li id="fn-rest">Gathering in parameters has a long history, and the usual terms are to call gathering “pattern matching” and to call a name that is bound to gathered values a “rest parameter.” The term “rest” is perfectly compatible with gather: “Rest” is the noun, and “gather” is the verb. We <em>gather</em> the <em>rest</em> of the parameters.<a href="https://leanpub.com/javascriptallongesix/read#fnref-rest" rel="rev-footnote">↩</a>
</li>
    <li id="fn-wellactually">Well, <em>actually</em>, the difference between prototypes and classes is like the difference between model homes and blueprints. But prototypes are not like model homes. In actual fact, the relationship between an object and its prototype is one of <em>delegation</em>. So if a model home had a kitchen, and you asked the builder to make you a home using the model as a prototype, you could customize your own kitchen. But if you didn’t want to have your own custom kitchen, you would just use the model home’s kitchen to do all your own cooking. The relationship between a model home and a house is sometimes described as <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">concatenative inheritance</a>, and JavaScript lets you do that too.<a href="https://leanpub.com/javascriptallongesix/read#fnref-wellactually" rel="rev-footnote">↩</a>
</li>
    <li id="fn-unfold">
<code>flatten</code> is a very simple <a href="https://en.wikipedia.org/wiki/Anamorphism">unfold</a>, a function that takes a seed value and turns it into an array. Unfolds can be thought of a “path” through a data structure, and flattening a tree is equivalent to a depth-first traverse.<a href="https://leanpub.com/javascriptallongesix/read#fnref-unfold" rel="rev-footnote">↩</a>
</li>
    <li id="fn-cow">It needn’t always be so: Programmers have developed specialized data structures that make operations like this cheap, often by arranging for structures to share common elements by default, and only making copies when changes are made. But this is not how JavaScript’s built-in arrays work.<a href="https://leanpub.com/javascriptallongesix/read#fnref-cow" rel="rev-footnote">↩</a>
</li>
    <li id="fn-lisp">Lisp is still very much alive, and one of the most interesting and exciting programming languages in use today is <a href="http://clojure.org/">Clojure</a>, a Lisp dialect that runs on the JVM, along with its sibling <a href="https://github.com/clojure/clojurescript">ClojureScript</a>, Clojure that transpiles to JavaScript.<a href="https://leanpub.com/javascriptallongesix/read#fnref-lisp" rel="rev-footnote">↩</a>
</li>
    <li id="fn-namecount">How many have we seen so far? Well, parameters bind names. Function declarations bind names. Named function expressions bind names. <code>const</code> and <code>let</code> bind names. So that’s five different ways so far. And there are more!<a href="https://leanpub.com/javascriptallongesix/read#fnref-namecount" rel="rev-footnote">↩</a>
</li>
    <li id="fn-gauss">There is a well known story about Karl Friedrich Gauss when he was in elementary school. His teacher got mad at the class and told them to add the numbers 1 to 100 and give him the answer by the end of the class. About 30 seconds later Gauss gave him the answer. The other kids were adding the numbers like this: <code>1 + 2 + 3 + . . . . + 99 + 100 = ?</code> But Gauss rearranged the numbers to add them like this: <code>(1 + 100) + (2 + 99) + (3 + 98) + . . . . + (50 + 51) = ?</code> If you notice every pair of numbers adds up to 101. There are 50 pairs of numbers, so the answer is 50*101 = 5050. Of course Gauss came up with the answer about 20 times faster than the other kids.<a href="https://leanpub.com/javascriptallongesix/read#fnref-gauss" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-recipes-with-data">Recipes with Data</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/diplomatico.jpg" alt="Café Diplomatico in Toronto&#39;s Little Italy">
  <figcaption>Café Diplomatico in Toronto’s Little Italy</figcaption>
</figure>


<h4 id="leanpub-auto-disclaimer-1">Disclaimer</h4>

<p>The recipes are written for practicality, and their implementation may introduce JavaScript features that haven’t been discussed in the text to this point, such as methods and/or prototypes. The overall <em>use</em> of each recipe will fit within the spirit of the language discussed so far, even if the implementations may not.</p>

<h3 id="mapWith">mapWith</h3>

<p>In JavaScript, arrays have a <code>.map</code> method. Map takes a function as an argument, and applies it to each of the elements of the array, then returns the results in another array. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="c1">//=&gt; [1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>We could write a function that behaves like the <code>.map</code> method if we wanted:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">map</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">list</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>This recipe isn’t for <code>map</code>: It’s for <code>mapWith</code>, a function that wraps around <code>map</code> and turns any other function into a mapper. <code>mapWith</code> is very simple:<sup id="fnref-mapWith"><a href="https://leanpub.com/javascriptallongesix/read#fn-mapWith" rel="footnote">1</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p><code>mapWith</code> differs from <code>map</code> in two ways. It reverses the arguments, taking the function first and the list second. It also “curries” the function: Instead of taking two arguments, it takes one argument and returns a function that takes another argument.</p>

<p>That means that you can pass a function to <code>mapWith</code> and get back a function that applies that mapping to any array. For example, we might need a function to return the squares of an array. Instead of writing a a wrapper around <code>.map</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squaresOf</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">list</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">);</code>

<code class="nx">squaresOf</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>We can call <code>mapWith</code> in one step:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squaresOf</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>

<code class="nx">squaresOf</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>If we didn’t use <code>mapWith</code>, we’d could have also used <code>callRight</code> with <code>map</code> to accomplish the same result:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">squaresOf</code> <code class="o">=</code> <code class="nx">callRight</code><code class="p">(</code><code class="nx">map</code><code class="p">,</code> <code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">n</code><code class="p">);</code>

<code class="nx">squaresOf</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; [1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>Both patterns take us to the same destination: Composing functions out of common pieces, rather than building them entirely from scratch. <code>mapWith</code> is a very convenient abstraction for a very common pattern.</p>

<p><em><code>mapWith</code> was suggested by <a href="http://github.com/ludicast">ludicast</a></em></p>

<h3 id="flip">Flip</h3>

<p>We wrote <a href="https://leanpub.com/javascriptallongesix/read#mapWith">mapWith</a> like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>Let’s consider the case whether we have a <code>map</code> function of our own, perhaps from the <a href="http://allong.es/">allong.es</a> library, perhaps from <a href="http://underscorejs.org/">Underscore</a>. We could write our function something like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>Looking at this, we see we’re conflating two separate transformations. First, we’re reversing the order of arguments. You can see that if we simplify it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>Second, we’re “currying” the function so that instead of defining a function that takes two arguments, it returns a function that takes the first argument and returns a function that takes the second argument and applies them both, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>Let’s return to the implementation of <code>mapWith</code> that relies on a <code>map</code> function rather than a method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">list</code><code class="p">,</code> <code class="nx">fn</code><code class="p">);</code>
</pre></div>

</figure>

<p>We’re going to extract these two operations by refactoring our function to paramaterize <code>map</code>. The first step is to give our parameters generic names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
</pre></div>

</figure>

<p>Then we wrap the entire thing in a function and extract <code>map</code></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
</pre></div>

</figure>

<p>What we have now is a function that takes a function and “flips” the order of arguments around, then curries it. So let’s call it <code>flipAndCurry</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">flipAndCurry</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
</pre></div>

</figure>

<p>Sometimes you want to flip, but not curry:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">flip</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
</pre></div>

</figure>

<p>This is gold. Consider how we define <a href="https://leanpub.com/javascriptallongesix/read#mapWith">mapWith</a> now:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="nx">flipAndCurry</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code>
</pre></div>

</figure>

<p>Much nicer!</p>

<h4 id="leanpub-auto-self-currying-flip">self-currying flip</h4>

<p>Sometimes we’ll want to flip a function, but retain the flexibility to call it in its curried form (pass one parameter) or non-curried form (pass both). We <em>could</em> make that into <code>flip</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">flip</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
      <code class="p">};</code>
    <code class="p">};</code>
  <code class="p">};</code>
</pre></div>

</figure>

<p>Now if we write <code>mapWith = flip(map)</code>, we can call <code>mapWith(fn, list)</code> or <code>mapWith(fn)(list)</code>, our choice.</p>

<h4 id="leanpub-auto-flipping-methods">flipping methods</h4>

<p>When we learn about context and methods, we’ll see that <code>flip</code> throws the current context away, so it can’t be used to flip methods. A small alteration gets the job done:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">flipAndCurry</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">first</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="kd">function</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
    <code class="p">}</code>

<code class="kr">const</code> <code class="nx">flip</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">flip</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">second</code><code class="p">,</code> <code class="nx">first</code><code class="p">);</code>
      <code class="p">};</code>
    <code class="p">};</code>
  <code class="p">};</code>
</pre></div>

</figure>

<h3 id="leanpub-auto-objectassign">Object.assign</h3>

<p>It’s very common to want to “extend” an object by assigning properties to it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">inventory</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">apples</code><code class="o">:</code> <code class="mi">12</code><code class="p">,</code>
  <code class="nx">oranges</code><code class="o">:</code> <code class="mi">12</code>
<code class="p">};</code>

<code class="nx">inventory</code><code class="p">.</code><code class="nx">bananas</code> <code class="o">=</code> <code class="mi">54</code><code class="p">;</code>
<code class="nx">inventory</code><code class="p">.</code><code class="nx">pears</code> <code class="o">=</code> <code class="mi">24</code><code class="p">;</code>
</pre></div>

</figure>

<p>It’s also common to want to assign the properties of one object to another:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">fruit</code> <code class="k">in</code> <code class="nx">shipment</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">inventory</code><code class="p">[</code><code class="nx">fruit</code><code class="p">]</code> <code class="o">=</code> <code class="nx">shipment</code><code class="p">[</code><code class="nx">fruit</code><code class="p">]</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>Both needs can be met with <code>Object.assign</code>, a standard function. You can copy an object by extending an empty object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="p">{</code>
  <code class="nx">apples</code><code class="o">:</code> <code class="mi">12</code><code class="p">,</code>
  <code class="nx">oranges</code><code class="o">:</code> <code class="mi">12</code>
<code class="p">})</code>
  <code class="c1">//=&gt; { apples: 12, oranges: 12 }</code>
</pre></div>

</figure>

<p>You can extend one object with another:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">inventory</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">apples</code><code class="o">:</code> <code class="mi">12</code><code class="p">,</code>
  <code class="nx">oranges</code><code class="o">:</code> <code class="mi">12</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">shipment</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">bananas</code><code class="o">:</code> <code class="mi">54</code><code class="p">,</code>
  <code class="nx">pears</code><code class="o">:</code> <code class="mi">24</code>
<code class="p">}</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">inventory</code><code class="p">,</code> <code class="nx">shipment</code><code class="p">)</code>
  <code class="c1">//=&gt; { apples: 12,</code>
  <code class="c1">//     oranges: 12,</code>
  <code class="c1">//     bananas: 54,</code>
  <code class="c1">//     pears: 24 }</code>
</pre></div>

</figure>

<p>And when we discuss prototypes, we will use <code>Object.assign</code> to turn this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code>
<code class="p">};</code>
  
<code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">pushTail</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">};</code>
<code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">pullHead</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">};</code>
<code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isEmpty</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Into this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
  <code class="p">})</code>
<code class="p">};</code>
  
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">},</code>
  <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">},</code>
  <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>      
<code class="p">});</code>
</pre></div>

</figure>

<p>Assigning properties from one object to another (also called “cloning” or “shallow copying”) is a basic building block that we will later use to implement more advanced paradigms like mixins.</p>

<h3 id="y">Why?</h3>

<p>This is the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Example_in_JavaScript" title="Call-by-value fixed-point combinator in JavaScript">canonical Y Combinator</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Y</code> <code class="o">=</code> <code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(</code><code class="nx">v</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">(</code><code class="nx">x</code><code class="p">)(</code><code class="nx">v</code><code class="p">))</code> <code class="p">)(</code>
    <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(</code><code class="nx">v</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">(</code><code class="nx">x</code><code class="p">)(</code><code class="nx">v</code><code class="p">))</code>
  <code class="p">);</code>
</pre></div>

</figure>

<p>You use it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="nx">Y</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">fac</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="mi">0</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">fac</code><code class="p">(</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">});</code>
 
<code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 120</code>
</pre></div>

</figure>

<p>Why? It enables you to make recursive functions without needing to bind a function to a name in an environment. This has little practical utility in JavaScript, but in combinatory logic it’s essential: With fixed-point combinators it’s possible to compute everything computable without binding names.</p>

<p>So again, why include the recipe? Well, besides all of the practical applications that combinators provide, there is this little thing called <em>The joy of working things out.</em></p>

<p>There are many explanations of the Y Combinator’s mechanism on the internet, but resist the temptation to read any of them: Work it out for yourself. Use it as an excuse to get familiar with your environment’s debugging facility.</p>

<p>One tip is to use JavaScript to name things. For example, you could start by writing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Y</code> <code class="o">=</code> <code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">something</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(</code><code class="nx">v</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">(</code><code class="nx">x</code><code class="p">)(</code><code class="nx">v</code><code class="p">));</code>
  
  <code class="k">return</code> <code class="nx">something</code><code class="p">(</code><code class="nx">something</code><code class="p">);</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>What is this <code>something</code> and how does it work? Another friendly tip: Change some of the fat arrow functions inside of it into named function expressions to help you decipher stack traces.</p>

<p>Work things out for yourself!</p>

<div class="footnotes">
  <ol>
    <li id="fn-mapWith">Yes, we also used the name <code>mapWith</code> for working with ordinary collections elsewhere. If we were writing a library of functions, we would have to disambiguate the two kinds of mapping functions with special names, namespaces, or modules. But for the purposes of discussing ideas, we can use the same name twice in two different contexts. It’s the same idea, after all.<a href="https://leanpub.com/javascriptallongesix/read#fnref-mapWith" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-a-warm-cup-basic-strings-and-quasi-literals">A Warm Cup: Basic Strings and Quasi-Literals</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/coffee-and-a-book.jpg" alt="Coffee and a Book">
  <figcaption>Coffee and a Book</figcaption>
</figure>


<blockquote>
  <p>An expression is any valid unit of code that resolves to a value.—<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">Mozilla Development Network: Expressions and operators</a></p>
</blockquote>

<p>Like most programming languages, JavaScript also has string literals, like <code>'fubar'</code> or <code>'fizzbuzz'</code>. Special characters can be included in a string literal by means of an <em>escape sequence</em>. For example, the escape sequence <code>\n</code> inserts a newline character in a string literal, like this: <code>'first line\nsecond line'</code>.</p>

<p>There are operators that can be used on strings. The most common is <code>+</code>, it <em>concatenates</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">'fu'</code> <code class="o">+</code> <code class="s1">'bar'</code>
  <code class="c1">//=&gt; 'fubar'</code>
</pre></div>

</figure>

<p>String manipulation is extremely common in programming. Writing is a big part of what makes us human, and strings are how JavaScript and most other languages represent writing. </p>

<h4 id="leanpub-auto-quasi-literals">quasi-literals</h4>

<p>JavaScript supports <em>quasi-literal strings</em>, a/k/a “Template Strings” or “String Interpolation Expressions.” A quasi-literal string is something that looks like a string literal, but is actually an expression. Quasi-literal strings are denoted with back quotes, and most strings that can be expressed as literals have the exact same meaning as quasi-literals, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="sb">`foobar`</code>
  <code class="c1">//=&gt; 'foobar'</code>
  
<code class="sb">`fizz`</code> <code class="o">+</code> <code class="sb">`buzz`</code>
  <code class="c1">//=&gt; 'fizzbuzz'</code>
</pre></div>

</figure>

<p>Quasi-literals go much further. A quasi-literal can contain an expression to be evaluated. Old-school lispers call this “unquoting,” the more contemporary term is “interpolation.” An unquoted expression is inserted in a quasi-literal with <code>${expression}</code>. The expression is evaluated, and the result is coerced to a string, then inserted in the quasi-string.</p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="sb">`A popular number for nerds is </code><code class="si">${</code><code class="mi">40</code> <code class="o">+</code> <code class="mi">2</code><code class="si">}</code><code class="sb">`</code>
  <code class="c1">//=&gt; 'A popular number for nerds is 42'</code>
</pre></div>

</figure>

<p>A quasi-literal is computationally equivalent to an expression using <code>+</code>. So the above expression could also be written:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">'A popular number for nerds is '</code> <code class="o">+</code> <code class="p">(</code><code class="mi">40</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 'A popular number for nerds is 42'</code>
</pre></div>

</figure>

<p>However, there is a big semantic difference between a quasi-literal and an expression. Quasi-literals are expressions that resemble their result. They’re easier to read and it’s easier to avid errors like the following:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">'A popular number for nerds is'</code> <code class="o">+</code> <code class="p">(</code><code class="mi">40</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; 'A popular number for nerds is42'</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-evaluation-time">evaluation time</h4>

<p>Like any other expression, quasi-literals are evaluated <em>late</em>, when that line or lines of code is evaluated.</p>

<p>So for example, </p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Harry"</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="sb">`Hello my name is </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>

<code class="nx">greeting</code><code class="p">(</code><code class="s1">'Arthur Dent'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello my name is Arthur Dent'</code>
</pre></div>

</figure>

<p>JavaScript evaluates the quasi-literal when the function is invoked and the quasi-literal inside the function’s body is evaluated. Thus, <code>name</code> is not bound to <code>"Harry"</code>, it is bound to <code>'Arthur Dent'</code>, the value of the parameter when the function is invoked.</p>

<p>This is exactly what we’d expect if we’d written it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s1">'Hello my name is '</code> <code class="o">+</code> <code class="nx">name</code><code class="p">;</code>

<code class="nx">greeting</code><code class="p">(</code><code class="s1">'Arthur Dent'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Hello my name is Arthur Dent'</code>
</pre></div>

</figure>

<h2 id="mutable">Stir the Allongé: Objects and State</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/coffee-spoons.jpg" alt="Life measured out by coffee spoons">
  <figcaption>Life measured out by coffee spoons</figcaption>
</figure>


<p>So far, we have discussed what many call “pure functional” programming, where every expression is necessarily <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a>, because we have no way of changing state within a program using the tools we have examined.</p>

<p>We’ve also explored functions that rebind names within themselves as part of performing their calculations. And we briefly touched upon the notion of mutating an object as part of building it. But we have avoided objects that are meant to be changed, objects that model <em>state</em>.</p>

<p>It’s time to change <em>everything</em>.</p>

<h3 id="encapsulation">Encapsulating State with Closures</h3>

<blockquote>
  <p>OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.–<a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">Alan Kay</a></p>
</blockquote>

<p>We’re going to look at encapsulation using JavaScript’s functions and objects. We’re not going to call it object-oriented programming, mind you, because that would start a long debate. This is just plain encapsulation,<sup id="fnref-encapsulation"><a href="https://leanpub.com/javascriptallongesix/read#fn-encapsulation" rel="footnote">1</a></sup> with a dash of information-hiding.</p>

<h4 id="leanpub-auto-what-is-hiding-of-state-process-and-why-does-it-matter">what is hiding of state-process, and why does it matter?</h4>

<blockquote>
  <p>In computer science, information hiding is the principle of segregation of the design decisions in a computer program that are most likely to change, thus protecting other parts of the program from extensive modification if the design decision is changed. The protection involves providing a stable interface which protects the remainder of the program from the implementation (the details that are most likely to change).</p>
</blockquote>

<blockquote>
  <p>Written another way, information hiding is the ability to prevent certain aspects of a class or software component from being accessible to its clients, using either programming language features (like private variables) or an explicit exporting policy.</p>
</blockquote>

<blockquote>
  <p>–<a href="https://en.wikipedia.org/wiki/Information_hiding" title="Information hiding">Wikipedia</a></p>
</blockquote>

<p>Consider a <a href="https://en.wikipedia.org/wiki/Stack_" title="data_structure">stack</a> data structure. There are three basic operations: Pushing a value onto the top (<code>push</code>), popping a value off the top (<code>pop</code>), and testing to see whether the stack is empty or not (<code>isEmpty</code>). These three operations are the stable interface.</p>

<p>Many stacks have an array for holding the contents of the stack. This is relatively stable. You could substitute a linked list, but in JavaScript, the array is highly efficient. You might need an index, you might not. You could grow and shrink the array, or you could allocate a fixed size and use an index to keep track of how much of the array is in use. The design choices for keeping track of the head of the list are often driven by performance considerations.</p>

<p>If you expose the implementation detail such as whether there is an index, sooner or later some programmer is going to find an advantage in using the index directly. For example, she may need to know the size of a stack. The ideal choice would be to add a <code>size</code> function that continues to hide the implementation. But she’s in a hurry, so she reads the <code>index</code> directly. Now her code is coupled to the existence of an index, so if we wish to change the implementation to grow and shrink the array, we will break her code.</p>

<p>The way to avoid this is to hide the array and index from other code and only expose the operations we have deemed stable. If and when someone needs to know the size of the stack, we’ll add a <code>size</code> function and expose it as well.</p>

<p>Hiding information (or “state”) is the design principle that allows us to limit the coupling between components of software.</p>

<h4 id="hiding-state">how do we hide state using javascript?</h4>

<p>We’ve been introduced to JavaScript’s objects, and it’s fairly easy to see that objects can be used to model what other programming languages call (variously) records, structs, frames, or what-have-you. And given that their elements are mutable, they can clearly model state.</p>

<p>Given an object that holds our state (an array and an index<sup id="fnref-length"><a href="https://leanpub.com/javascriptallongesix/read#fn-length" rel="footnote">2</a></sup>), we can easily implement our three operations as functions. Bundling the functions with the state does not require any special “magic” features. JavaScript objects can have elements of any type, including functions.</p>

<p>To make our stack work, we need a way for our functions to refer to our stack. We’ll do that by making sure it has a name. We can do that with an IIFE:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>

      <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">}</code>
  <code class="p">};</code>

  <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>
<code class="p">})();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; true</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'hello'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'hello'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'JavaScript'</code><code class="p">)</code>
 <code class="c1">//=&gt; 'JavaScript'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
 <code class="c1">//=&gt; 'JavaScript'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
 <code class="c1">//=&gt; 'hello'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-method-ology">method-ology</h4>

<p>In this text, we lurch from talking about “functions that belong to an object” to “methods.” Other languages may separate methods from functions very strictly, but in JavaScript every method is a function, but not all functions are methods.</p>

<p>The view taken in this book is that a function is a method of an object if it belongs to that object and interacts with that object in some way. So the functions implementing the operations on the stack are all absolutely methods of the stack.</p>

<p>But these two wouldn’t be methods. Although they “belong” to an object, they don’t interact with it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code>
  <code class="nx">min</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">y</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="nx">y</code>
  <code class="nx">max</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="nx">y</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-hiding-state">hiding state</h4>

<p>Our stack does bundle functions with data, but it doesn’t hide its state. “Foreign” code could interfere with its array or index. So how do we hide these? We already have a closure, let’s use it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[],</code>
      <code class="nx">index</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

  <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code> <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>

      <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="p">}</code>
  <code class="p">};</code>

  <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>
<code class="p">})();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; true</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'hello'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'hello'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'JavaScript'</code><code class="p">)</code>
 <code class="c1">//=&gt; 'JavaScript'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
 <code class="c1">//=&gt; 'JavaScript'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
 <code class="c1">//=&gt; 'hello'</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">()</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/coffee-trees-1200.jpg" alt="Coffee DOES grow on trees">
  <figcaption>Coffee DOES grow on trees</figcaption>
</figure>


<p>We don’t want to repeat this code every time we want a stack, so let’s make ourselves a “stack maker.” The temptation is to wrap what we have above in a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Stack</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[],</code>
        <code class="nx">index</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

    <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
      <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code> <code class="p">},</code>
      <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>

        <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
          <code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
        <code class="p">}</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">},</code>
      <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="p">}</code>
    <code class="p">};</code>

    <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>
  <code class="p">})();</code>
</pre></div>

</figure>

<p>But there’s an easier way :-)</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Stack</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">let</code> <code class="nx">index</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code> <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>

      <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="nx">Stack</code><code class="p">();</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"Good bye"</code><code class="p">);</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
  <code class="c1">//=&gt; "Good bye"</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
  <code class="c1">//=&gt; "Hello"</code>
</pre></div>

</figure>

<p>Now we can make stacks freely, and we’ve hidden their internal data elements. We have methods and encapsulation, and we’ve built them out of JavaScript’s fundamental functions and objects. In <a href="https://leanpub.com/javascriptallongesix/read#classes">Constructors and Classes</a>, we’ll look at JavaScript’s support for class-oriented programming and some of the idioms that functions bring to the party.</p>

<aside>
  <h4 id="leanpub-auto-is-encapsulation-object-oriented">is encapsulation “object-oriented?”</h4>

  <p>We’ve built something with hidden internal state and “methods,” all without needing special <code>def</code> or <code>private</code> keywords. Mind you, we haven’t included all sorts of complicated mechanisms to support inheritance, mixins, and other opportunities for debating the nature of the One True Object-Oriented Style on the Internet.</p>

  <p>Then again, the key lesson experienced programmers repeat–although it often falls on deaf ears–is <a href="http://www.c2.com/cgi/wiki?CompositionInsteadOfInheritance">Composition instead of Inheritance</a>. So maybe we aren’t missing much.</p>

</aside>

<h3 id="composition">Composition and Extension</h3>

<h4 id="leanpub-auto-composition-1">composition</h4>

<p>A deeply fundamental practice is to build components out of smaller components. The choice of how to divide a component into smaller components is called <em>factoring</em>, after the operation in number theory <sup id="fnref-refactoring"><a href="https://leanpub.com/javascriptallongesix/read#fn-refactoring" rel="footnote">3</a></sup>.</p>

<p>The simplest and easiest way to build components out of smaller components in JavaScript is also the most obvious: Each component is a value, and the components can be put together into a single object or encapsulated with a closure.</p>

<p>Here’s an abstract “model” that supports undo and redo composed from a pair of stacks (see <a href="https://leanpub.com/javascriptallongesix/read#encapsulation">Encapsulating State</a>), and a Plain Old JavaScript Object:</p>

<p>We can <code>set</code> and <code>get</code> attributes on a model</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// helper function</code>
<code class="c1">//</code>
<code class="c1">// For production use, consider what to do about</code>
<code class="c1">// deep copies and own keys</code>
<code class="kr">const</code> <code class="nx">shallowCopy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">source</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">dest</code> <code class="o">=</code> <code class="p">{};</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">source</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">dest</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">source</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">dest</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Stack</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">let</code> <code class="nx">index</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">array</code><code class="p">[</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">index</code><code class="p">];</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">Model</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">initialAttributes</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">redoStack</code> <code class="o">=</code> <code class="nx">Stack</code><code class="p">();</code>
  <code class="kd">let</code> <code class="nx">attributes</code> <code class="o">=</code> <code class="nx">shallowCopy</code><code class="p">(</code><code class="nx">initialAttributes</code> <code class="o">||</code> <code class="p">{});</code>

  <code class="kr">const</code> <code class="nx">undoStack</code> <code class="o">=</code> <code class="nx">Stack</code><code class="p">(),</code>
      <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
        <code class="nx">set</code><code class="o">:</code> <code class="p">(</code><code class="nx">attrsToSet</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="nx">undoStack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">shallowCopy</code><code class="p">(</code><code class="nx">attributes</code><code class="p">));</code>
          <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">redoStack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="nx">redoStack</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
          <code class="p">}</code>
          <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="p">(</code><code class="nx">attrsToSet</code> <code class="o">||</code> <code class="p">{}))</code> <code class="p">{</code>
            <code class="nx">attributes</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">attrsToSet</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>
          <code class="p">}</code>
          <code class="k">return</code> <code class="nx">obj</code>
        <code class="p">},</code>
        <code class="nx">undo</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">undoStack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="nx">redoStack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">shallowCopy</code><code class="p">(</code><code class="nx">attributes</code><code class="p">));</code>
            <code class="nx">attributes</code> <code class="o">=</code> <code class="nx">undoStack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
          <code class="p">}</code>
          <code class="k">return</code> <code class="nx">obj</code>
        <code class="p">},</code>
        <code class="nx">redo</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">redoStack</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="nx">undoStack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">shallowCopy</code><code class="p">(</code><code class="nx">attributes</code><code class="p">));</code>
            <code class="nx">attributes</code> <code class="o">=</code> <code class="nx">redoStack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>
          <code class="p">}</code>
          <code class="k">return</code> <code class="nx">obj</code>
        <code class="p">},</code>
        <code class="nx">get</code><code class="o">:</code> <code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">attributes</code><code class="p">[</code><code class="nx">key</code><code class="p">],</code>
        <code class="nx">has</code><code class="o">:</code> <code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">attributes</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">key</code><code class="p">),</code>
        <code class="nx">attributes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">shallowCopy</code><code class="p">(</code><code class="nx">attributes</code><code class="p">)</code>
      <code class="p">};</code>
    <code class="k">return</code> <code class="nx">obj</code>
  <code class="p">};</code>

<code class="kr">const</code> <code class="nx">model</code> <code class="o">=</code> <code class="nx">Model</code><code class="p">();</code>
<code class="nx">model</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code><code class="s2">"Doctor"</code><code class="o">:</code> <code class="s2">"de Grasse"</code><code class="p">});</code>
<code class="nx">model</code><code class="p">.</code><code class="nx">set</code><code class="p">({</code><code class="s2">"Doctor"</code><code class="o">:</code> <code class="s2">"Who"</code><code class="p">});</code>
<code class="nx">model</code><code class="p">.</code><code class="nx">undo</code><code class="p">()</code>
<code class="nx">model</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"Doctor"</code><code class="p">)</code>
  <code class="c1">//=&gt; "de Grasse"</code>
</pre></div>

</figure>

<p>The techniques used for encapsulation work well with composition. In this case, we have a “model” that hides its attribute store as well as its implementation that is composed of an undo stack and redo stack.</p>

<h4 id="extensible">extension</h4>

<p>Another practice that many people consider fundamental is to <em>extend</em> an implementation. Meaning, they wish to define a new data structure in terms of adding new operations and semantics to an existing data structure.</p>

<p>Consider a <a href="http://duckduckgo.com/Queue_" title="data_structure">queue</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[],</code>
      <code class="nx">head</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">tail</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">pushTail</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">array</code><code class="p">[</code><code class="o">++</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">,</code>
    <code class="nx">pullHead</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">head</code><code class="p">];</code>

        <code class="nx">array</code><code class="p">[</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="o">++</code><code class="nx">head</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">tail</code> <code class="o">&lt;</code> <code class="nx">head</code>
  <code class="p">}</code>
<code class="p">};</code>


<code class="kr">const</code> <code class="nx">queue</code> <code class="o">=</code> <code class="nx">Queue</code><code class="p">();</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">);</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s2">"JavaScript"</code><code class="p">);</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s2">"Allongé"</code><code class="p">);</code>

<code class="nx">queue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; "Hello"</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; "JavaScript"</code>
</pre></div>

</figure>

<p>Now we wish to create a <a href="https://en.wikipedia.org/wiki/Double-ended_queue" title="Double-ended queue">deque</a> by adding <code>pullTail</code> and <code>pushHead</code> operations to our queue.<sup id="fnref-wasa"><a href="https://leanpub.com/javascriptallongesix/read#fn-wasa" rel="footnote">4</a></sup> Unfortunately, encapsulation prevents us from adding operations that interact with the hidden data structures.</p>

<p>This isn’t really surprising: The entire point of encapsulation is to create an opaque data structure that can only be manipulated through its public interface. The design goals of encapsulation and extension are always going to exist in tension.</p>

<p>Let’s “de-encapsulate” our queue:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">queue</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="o">++</code><code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">,</code>
    <code class="nx">pullHead</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">];</code>

        <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
      <code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">};</code>
  <code class="k">return</code> <code class="nx">queue</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Now we can extend a queue into a deque:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">extend</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">consumer</code><code class="p">,</code> <code class="p">...</code><code class="nx">providers</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">providers</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">provider</code> <code class="o">=</code> <code class="nx">providers</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">provider</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">provider</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code> <code class="p">{</code>
        <code class="nx">consumer</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">provider</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">consumer</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Dequeue</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">deque</code> <code class="o">=</code> <code class="nx">Queue</code><code class="p">(),</code>
      <code class="nx">INCREMENT</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>

  <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">deque</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">size</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">head</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code>
    <code class="nx">pullTail</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">deque</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code><code class="p">];</code>

        <code class="nx">deque</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">pushHead</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">deque</code><code class="p">.</code><code class="nx">head</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">head</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
          <code class="nx">deque</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code> <code class="o">+</code> <code class="nx">INCREMENT</code><code class="p">]</code> <code class="o">=</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
        <code class="p">}</code>
        <code class="nx">deque</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="nx">INCREMENT</code>
        <code class="nx">deque</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="nx">INCREMENT</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">deque</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">deque</code><code class="p">.</code><code class="nx">head</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">})</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Presto, we have reuse through extension, at the cost of encapsulation.</p>

<aside class="tip blurb">
    <p>Encapsulation and Extension exist in a natural state of tension. A program with elaborate encapsulation resists breakage but can also be difficult to refactor in other ways. Be mindful of when it’s best to Compose and when it’s best to Extend.</p>

</aside>

<h3 id="this">This and That</h3>

<p>Let’s take another look at <a href="https://leanpub.com/javascriptallongesix/read#extensible">extensible objects</a>. Here’s a Queue:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">queue</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="o">++</code><code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">];</code>

        <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">head</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">};</code>
  <code class="k">return</code> <code class="nx">queue</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">queue</code> <code class="o">=</code> <code class="nx">Queue</code><code class="p">();</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'Hello'</code><code class="p">);</code>
<code class="nx">queue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'JavaScript'</code><code class="p">);</code>
</pre></div>

</figure>

<p>Let’s make a copy of our queue using <code>Object.assign</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">copyOfQueue</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">queue</code><code class="p">);</code>

<code class="nx">queue</code> <code class="o">!==</code> <code class="nx">copyOfQueue</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Wait a second. We know that array values are references. So it probably copied a reference to the original array. Let’s make a copy of the array as well:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">array</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">queue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Now let’s pull the head off the original:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">queue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Hello'</code>
</pre></div>

</figure>

<p>If we’ve copied everything properly, we should get the exact same result when we pull the head off the copy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'JavaScript'</code>
</pre></div>

</figure>

<p>What!? Even though we carefully made a copy of the array to prevent aliasing, it seems that our two queues behave like aliases of each other. The problem is that while we’ve carefully copied our array and other elements over, <em>the closures all share the same environment</em>, and therefore the functions in <code>copyOfQueue</code> all operate on the first queue’s private data, not on the copies.</p>

<aside>
  <p>This is a general issue with closures. Closures couple functions to environments, and that makes them very elegant in the small, and very handy for making opaque data structures. Alas, their strength in the small is their weakness in the large. When you’re trying to make reusable components, this coupling is sometimes a hindrance.</p>

</aside>

<p>Let’s take an impossibly optimistic flight of fancy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">AmnesiacQueue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">myself</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">myself</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">myself</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code> <code class="p">(</code><code class="nx">myself</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">myself</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="nx">myself</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">myself</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">myself</code><code class="p">.</code><code class="nx">head</code><code class="p">];</code>

        <code class="nx">myself</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">myself</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
        <code class="nx">myself</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">(</code><code class="nx">myself</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">myself</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="nx">myself</code><code class="p">.</code><code class="nx">head</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">queueWithAmnesia</code> <code class="o">=</code> <code class="nx">AmnesiacQueue</code><code class="p">();</code>

<code class="nx">queueWithAmnesia</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="nx">queueWithAmnesia</code><code class="p">,</code> <code class="s1">'Hello'</code><code class="p">);</code>
<code class="nx">queueWithAmnesia</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="nx">queueWithAmnesia</code><code class="p">,</code> <code class="s1">'JavaScript'</code><code class="p">);</code>
<code class="nx">queueWithAmnesia</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">(</code><code class="nx">queueWithAmnesia</code><code class="p">)</code>
  <code class="c1">//=&gt; "Hello"</code>
</pre></div>

</figure>

<p>The <code>AmnesiacQueue</code> makes queues with amnesia: They don’t know who they are, so every time we invoke one of their functions, we have to tell them who they are. You can work out the implications for copying queues as a thought experiment: We don’t have to worry about environments, because every function operates on the queue you pass in.</p>

<p>The killer drawback, of course, is making sure we are always passing the correct queue in every time we invoke a function. What to do?</p>

<h4 id="leanpub-auto-whats-all-this">what’s all <code>this</code>?</h4>

<p>Any time we must do the same repetitive thing over and over and over again, we industrial humans try to build a machine to do it for us. JavaScript is one such machine. When we write a function expression using the compact method syntax (or use the <code>function</code> keyword instead of the fat arrow), and then invoke that function using <code>.</code> notation, JavaScript binds the “receiver” of a “method invocation” to the special name <code>this</code>.</p>

<p>Our <code>AmnesiacQueue</code> already uses compact method notation. So, we’ll remove <code>myself</code> from the parameter list, and rename it to <code>this</code> within the body of each function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BetterQueue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">];</code>

        <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>Now we are relying on JavaScript to set the value of <code>this</code> whenever we invoke one of these functions using the <code>.</code> or <code>[</code> and <code>]</code> operators.</p>

<p>In other words, when we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">betterQueue</code> <code class="o">=</code> <code class="nx">BetterQueue</code><code class="p">();</code>

<code class="nx">betterQueue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'Hello'</code><code class="p">);</code>
<code class="nx">betterQueue</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'JavaScript'</code><code class="p">);</code>
<code class="nx">betterQueue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
</pre></div>

</figure>

<p>We expect that JavaScript will invoke the functions we’ve bound to <code>pushTail</code> and <code>pullHead</code>, and automatically bind <code>betterQueue</code> to the name <code>this</code> within them. And indeed it does: Every time you invoke a function that is a member of an object, JavaScript binds that object to the name <code>this</code> in the environment of the function just as if it was an argument.<sup id="fnref-this"><a href="https://leanpub.com/javascriptallongesix/read#fn-this" rel="footnote">5</a></sup></p>

<p>Now, does this solve our original problem? Can we make copies of an object? Recall that the problem was that when we used a closure for private data, copying references to an object’s functions meant that we were using functions that still referred to the original closure, and therefore shared the same private data.</p>

<p>Now our functions refer to members of the object, and use <code>this</code> to ensure  that they are referring to the object receiving a message. Let’s see if this does, indeed, allow us to copy objects:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">copyOfQueue</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">betterQueue</code><code class="p">)</code>
<code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">array</code> <code class="o">=</code> <code class="p">[]</code>
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">betterQueue</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
<code class="p">}</code>

<code class="nx">betterQueue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Hello'</code>

<code class="nx">copyOfQueue</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Hello'</code>
</pre></div>

</figure>

<p>Presto, we now have a way to copy arrays. By getting rid of the closure and taking advantage of <code>this</code>, we have functions that are more easily portable between objects, and the code is simpler as well. <strong>This is very important</strong>. Being able to copy objects is an example of a larger concern: Being able to share functions between objects. That’s how classes work. That’s how extending objects works. Being able to share functions means being able to compose and reuse functionality.</p>

<p>There is more to <code>this</code> than we’ve discussed here. We’ll explore things in more detail later, in <a href="https://leanpub.com/javascriptallongesix/read#context">What Context Applies When We Call a Function?</a>.</p>

<aside class="tip blurb">
    <p>Closures tightly couple functions to the environments where they are created limiting their flexibility. Using <code>this</code> alleviates the coupling. Copying objects is but one example of where that flexibility is needed.</p>

</aside>

<h3 id="context">What Context Applies When We Call a Function?</h3>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#this">This and That</a>, we learned that when a function is denoted using the <code>function</code> keyword, and is called as an object method, the name <code>this</code> is bound in its environment to the object acting as a “receiver.” For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">someObject</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">returnMyThis</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">someObject</code><code class="p">.</code><code class="nx">returnMyThis</code><code class="p">()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>We’ve constructed a method that returns whatever value is bound to <code>this</code> when it is called. It returns the object when called, just as described.</p>

<h4 id="leanpub-auto-its-all-about-the-way-the-function-is-called">it’s all about the way the function is called</h4>

<p>JavaScript programmers talk about functions having a “context” when being called. <code>this</code> is bound to the context.<sup id="fnref-toobad"><a href="https://leanpub.com/javascriptallongesix/read#fn-toobad" rel="footnote">6</a></sup> The important thing to understand is that the context for a function being called is set by the way the function is called, not the function itself.</p>

<p>This is an important distinction. Consider closures: As we discussed in <a href="https://leanpub.com/javascriptallongesix/read#closures">Closures and Scope</a>, a function’s free variables are resolved by looking them up in their enclosing functions’ environments. You can always determine the functions that define free variables by examining the source code of a JavaScript program, which is why this scheme is known as <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping">Lexical Scope</a>.</p>

<p>A function’s context cannot be determined by examining the source code of a JavaScript program. Let’s look at our example again:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">someObject</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">someFunction</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>What is the context of the function <code>someObject.someFunction</code>? Don’t say <code>someObject</code>! Watch this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">someFunction</code> <code class="o">=</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">;</code>

<code class="nx">someFunction</code> <code class="o">===</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code>
  <code class="c1">//=&gt; true</code>

<code class="nx">someFunction</code><code class="p">()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>It gets weirder:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">anotherObject</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">someFunction</code><code class="o">:</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code>
<code class="p">}</code>

<code class="nx">anotherObject</code><code class="p">.</code><code class="nx">someFunction</code> <code class="o">===</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">anotherObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">()</code> <code class="o">===</code> <code class="nx">anotherObject</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">anotherObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>So it amounts to this: The exact same function can be called in two different ways, and you end up with two different contexts. If you call it using <code>someObject.someFunction()</code> syntax, the context is set to the receiver. If you call it using any other expression for resolving the function’s value (such as <code>someFunction()</code>), you get something else.</p>

<p>Let’s investigate:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">)()</code> <code class="o">==</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">someObject</code><code class="p">[</code><code class="s1">'someFunction'</code><code class="p">]()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
  
<code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s1">'someFunction'</code><code class="p">;</code>

<code class="nx">someObject</code><code class="p">[</code><code class="nx">name</code><code class="p">]()</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Interesting!</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">baz</code><code class="p">;</code>

<code class="p">(</code><code class="nx">baz</code> <code class="o">=</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">)()</code> <code class="o">===</code> <code class="k">this</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>How about:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code> <code class="nx">someObject</code><code class="p">.</code><code class="nx">someFunction</code> <code class="p">];</code>

<code class="nx">arr</code><code class="p">[</code><code class="mi">0</code><code class="p">]()</code> <code class="o">==</code> <code class="nx">arr</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>It seems that whether you use <code>a.b()</code> or <code>a['b']()</code> or <code>a[n]()</code> or <code>(a.b)()</code>, you get context <code>a</code>. </p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">returnThis</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code> <code class="p">};</code>

<code class="kr">const</code> <code class="nx">aThirdObject</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">someFunction</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">returnThis</code><code class="p">()</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">returnThis</code><code class="p">()</code> <code class="o">===</code> <code class="k">this</code>
  <code class="c1">//=&gt; true</code>

<code class="nx">aThirdObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">()</code> <code class="o">===</code> <code class="k">this</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>And if you don’t use <code>a.b()</code> or <code>a['b']()</code> or <code>a[n]()</code> or <code>(a.b)()</code>, you get the global environment for a context, not the context of whatever function is doing the calling. To simplify things, when you call a function with <code>.</code> or <code>[]</code> access, you get an object as context, otherwise you get the global environment.</p>

<h4 id="leanpub-auto-setting-your-own-context">setting your own context</h4>

<p>There are actually two other ways to set the context of a function. And once again, both are determined by the caller. At the very end of <a href="https://leanpub.com/javascriptallongesix/read#pojoseverywhere">objects everywhere?</a>, we’ll see that everything in JavaScript behaves like an object, including functions. We’ll learn that functions have methods themselves, and one of them is <code>call</code>.</p>

<p>Here’s <code>call</code> in action:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">returnThis</code><code class="p">()</code> <code class="o">===</code> <code class="nx">aThirdObject</code>
  <code class="c1">//=&gt; false</code>

<code class="nx">returnThis</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">aThirdObject</code><code class="p">)</code> <code class="o">===</code> <code class="nx">aThirdObject</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">anotherObject</code><code class="p">.</code><code class="nx">someFunction</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">someObject</code><code class="p">)</code> <code class="o">===</code> <code class="nx">someObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>When You call a function with <code>call</code>, you set the context by passing it in as the first parameter. Other arguments are passed to the function in the normal manner. Much hilarity can result from <code>call</code> shenanigans like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">],</code>
    <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">];</code>
    
<code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">])</code>
  <code class="c1">//=&gt; [1,2,3,2,1]</code>
  
<code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">b</code><code class="p">,[</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">])</code>
  <code class="c1">//=&gt; [4,5,6,2,1]</code>
</pre></div>

</figure>

<p>But now we thoroughly understand what <code>a.b()</code> really means: It’s synonymous with <code>a.b.call(a)</code>. Whereas in a browser, <code>c()</code> is synonymous with <code>c.call(window)</code>.</p>

<h4 id="leanpub-auto-arguments">arguments</h4>

<p>JavaScript has another automagic binding in every function’s environment. <code>arguments</code> is a special object that behaves a little like an array.<sup id="fnref-little"><a href="https://leanpub.com/javascriptallongesix/read#fn-little" rel="footnote">7</a></sup></p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">third</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">arguments</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>
<code class="p">}</code>

<code class="nx">third</code><code class="p">(</code><code class="mi">77</code><code class="p">,</code> <code class="mi">76</code><code class="p">,</code> <code class="mi">75</code><code class="p">,</code> <code class="mi">74</code><code class="p">,</code> <code class="mi">73</code><code class="p">)</code>
  <code class="c1">//=&gt; 75</code>
</pre></div>

</figure>

<p>Gathering arguments with <code>...</code> accomplishes most of the use cases people have for using the <code>arguments</code> special binding, and in addition, gathering works with both fat arrows and with the <code>function</code> keyword, whereas <code>arguments</code> only works with the function keyword.</p>

<p>There are a few things that <code>arguments</code> can do that gathering cannot do, for example if you declare a function with <code>function (a, b, c) { ... }</code>, <code>arguments</code> holds the arguments passed to the function even though you haven’t declared a parameter to be gathered. It works alongside the declared parameters.</p>

<p>But by and large, we will gather parameters in this book.</p>

<h4 id="leanpub-auto-application-and-contextualization">application and contextualization</h4>

<p>Hold that thought for a moment. JavaScript also provides a fourth way to set the context for a function. <code>apply</code> is a method implemented by every function that takes a context as its first argument, and it takes an array or array-like thing of arguments as its second argument. That’s a mouthful, let’s look at an example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">third</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>

<code class="nx">third</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>Now let’s put the two together. Here’s another travesty:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">],</code>
      <code class="nx">accrete</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">;</code>
    
<code class="nx">accrete</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">])</code>
  <code class="c1">//=&gt; Gobbledygook!</code>
</pre></div>

</figure>

<p>We get the result of concatenating <code>[4,5]</code> onto an array containing the global environment. Not what we want! Behold:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">contextualize</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">accrete2</code> <code class="o">=</code> <code class="nx">contextualize</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">,</code> <code class="nx">a</code><code class="p">);</code>
<code class="nx">accrete2</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">]);</code>
  <code class="c1">//=&gt; [ 1, 2, 3, 4, 5 ]</code>
</pre></div>

</figure>

<p>Our <code>contextualize</code> function returns a new function that calls a function with a fixed context. It can be used to fix some of the unexpected results we had above. Consider:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">aFourthObject</code> <code class="o">=</code> <code class="p">{},</code>
    <code class="nx">returnThis</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">};</code>
    
<code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">uncontextualized</code> <code class="o">=</code> <code class="nx">returnThis</code><code class="p">;</code>
<code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">contextualized</code> <code class="o">=</code> <code class="nx">contextualize</code><code class="p">(</code><code class="nx">returnThis</code><code class="p">,</code> <code class="nx">aFourthObject</code><code class="p">);</code>

<code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">uncontextualized</code><code class="p">()</code> <code class="o">===</code> <code class="nx">aFourthObject</code>
  <code class="c1">//=&gt; true</code>
<code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">contextualized</code><code class="p">()</code> <code class="o">===</code> <code class="nx">aFourthObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Both are <code>true</code> because we are accessing them with <code>aFourthObject.</code> Now we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">uncontextualized</code> <code class="o">=</code> <code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">uncontextualized</code><code class="p">,</code>
    <code class="nx">contextualized</code> <code class="o">=</code> <code class="nx">aFourthObject</code><code class="p">.</code><code class="nx">contextualized</code><code class="p">;</code>
    
<code class="nx">uncontextualized</code><code class="p">()</code> <code class="o">===</code> <code class="nx">aFourthObject</code><code class="p">;</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">contextualized</code><code class="p">()</code> <code class="o">===</code> <code class="nx">aFourthObject</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>When we call these functions without using <code>aFourthObject.</code>, only the contextualized version maintains the context of <code>aFourthObject</code>.</p>

<p>We’ll return to contextualizing methods later, in <a href="https://leanpub.com/javascriptallongesix/read#binding">Binding</a>. But before we dive too deeply into special handling for methods, we need to spend a little more time looking at how functions and methods work.</p>

<h3 id="method-decorators">Method Decorators</h3>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#decorators">function decorators</a>, we learned that a decorator takes a function as an argument, returns a function, and there’s a semantic relationship between the two. If a function is a verb, a decorator is an adverb.</p>

<p>Decorators can be used to decorate methods provided that they carefully preserve the function’s context. For example, here is a naïve version of <code>maybe</code> for one argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">:</code> <code class="nx">x</code><code class="p">;</code>
</pre></div>

</figure>

<p>We use it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">plus1</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>

<code class="nx">plus1</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>
<code class="nx">plus1</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">plus1</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">plus1</code><code class="p">(</code><code class="kc">undefined</code><code class="p">)</code>
  <code class="c1">//=&gt; null</code>
  
<code class="kr">const</code> <code class="nx">maybePlus1</code> <code class="o">=</code> <code class="nx">maybe</code><code class="p">(</code><code class="nx">plus1</code><code class="p">);</code>

<code class="nx">maybePlus1</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>
<code class="nx">maybePlus1</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
  <code class="c1">//=&gt; 1</code>
<code class="nx">maybePlus1</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code>
  <code class="c1">//=&gt; null</code>
<code class="nx">maybePlus1</code><code class="p">(</code><code class="kc">undefined</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>This version doesn’t preserve the context, so it can’t be used as a method decorator. Instead, we have to convert the decoration from a fat arrow to a <code>function</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">:</code> <code class="nx">x</code><code class="p">;</code>
  <code class="p">};</code>
</pre></div>

</figure>

<p>And then use <code>.call</code> to preserve <code>this</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">x</code><code class="p">)</code> <code class="o">:</code> <code class="nx">x</code><code class="p">;</code>
  <code class="p">};</code>
</pre></div>

</figure>

<p>Now that we have a “proper function,” we can also handle variadic functions and methods. This variation only invokes the decorated function if none of the arguments are <code>null</code> or <code>undefined</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">in</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code> <code class="nx">args</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">};</code>
</pre></div>

</figure>

<p>But back to basics. As long as we are correctly preserving <code>this</code> by one, using a <code>function</code>, and two, invoking the decorated function with <code>.call(this, ...)</code> or <code>.apply(this, ...)</code>, we can decorate methods as well as functions.</p>

<p>Now we can write things like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">someObject</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">setSize</code><code class="o">:</code> <code class="nx">maybe</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">size</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">=</code> <code class="nx">size</code><code class="p">;</code>
  <code class="p">})</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And <code>this</code> is correctly set:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">someObject</code><code class="p">.</code><code class="nx">setSize</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code>
<code class="nx">someObject</code>
  <code class="c1">//=&gt; { setSize: [Function], size: 5 }</code>

<code class="nx">someObject</code><code class="p">.</code><code class="nx">setSize</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>
<code class="nx">someObject</code>
  <code class="c1">//=&gt; { setSize: [Function], size: 5 }</code>
</pre></div>

</figure>

<p>Using <code>.call</code> or <code>.apply</code> and <code>arguments</code> is substantially slower than writing function decorators that don’t set the context, so it might be right to sometimes write function decorators that aren’t usable as method decorators. However, in practice you’re far more likely to introduce a defect by failing to pass the context through a decorator than by introducing a performance pessimization, so the default choice should be to write all function decorators in such a way that they are “context agnostic.”</p>

<p>In some cases, there are other considerations to writing a method decorator. If the decorator introduces state of any kind (such as <code>once</code> and <code>memoize</code> do), this must be carefully managed for the case when several objects share the same method through the mechanism of the <a href="https://leanpub.com/javascriptallongesix/read#prototypes">prototype</a> or through sharing references to the same function.</p>

<h3 id="leanpub-auto-summary-4">Summary</h3>

<aside class="tip blurb">
    <h4 id="leanpub-auto-objects-mutation-and-state">Objects, Mutation, and State</h4>

  <ul>
    <li>State can be encapsulated/hidden with closures.</li>
    <li>Encapsulations can be aggregated with composition.</li>
    <li>Encapsulation resists extension.</li>
    <li>The automagic binding <code>this</code> facilitates sharing of functions.</li>
    <li>Functions can be named and declared with a name.</li>
  </ul>

</aside>

<div class="footnotes">
  <ol>
    <li id="fn-encapsulation">“A language construct that facilitates the bundling of data with the methods (or other functions) operating on that data.”–<a href="https://en.wikipedia.org/wiki/Encapsulation_" title="object-oriented_programming">Wikipedia</a><a href="https://leanpub.com/javascriptallongesix/read#fnref-encapsulation" rel="rev-footnote">↩</a>
</li>
    <li id="fn-length">Yes, there’s another way to track the size of the array, but we don’t need it to demonstrate encapsulation and hiding of state.<a href="https://leanpub.com/javascriptallongesix/read#fnref-length" rel="rev-footnote">↩</a>
</li>
    <li id="fn-refactoring">And when you take an already factored component and rearrange things so that it is factored into a different set of subcomponents without altering its behaviour, you are <em>refactoring</em>.<a href="https://leanpub.com/javascriptallongesix/read#fnref-refactoring" rel="rev-footnote">↩</a>
</li>
    <li id="fn-wasa">Before you start wondering whether a deque is-a queue, we said nothing about types and classes. This relationship is called was-a, or “implemented in terms of a.”<a href="https://leanpub.com/javascriptallongesix/read#fnref-wasa" rel="rev-footnote">↩</a>
</li>
    <li id="fn-this">JavaScript also does other things with <code>this</code> as well, but this is all we care about right now.<a href="https://leanpub.com/javascriptallongesix/read#fnref-this" rel="rev-footnote">↩</a>
</li>
    <li id="fn-toobad">Too bad the language binds the context to the name <code>this</code> instead of the name <code>context</code>!<a href="https://leanpub.com/javascriptallongesix/read#fnref-toobad" rel="rev-footnote">↩</a>
</li>
    <li id="fn-little">Just enough to be frustrating, to be perfectly candid!<a href="https://leanpub.com/javascriptallongesix/read#fnref-little" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-recipes-with-objects-mutations-and-state">Recipes with Objects, Mutations, and State</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/intestines.jpg" alt="The Intestines of an Espresso Machine">
  <figcaption>The Intestines of an Espresso Machine</figcaption>
</figure>


<h4 id="leanpub-auto-disclaimer-2">Disclaimer</h4>

<p>The recipes are written for practicality, and their implementation may introduce JavaScript features that haven’t been discussed in the text to this point, such as methods and/or prototypes. The overall <em>use</em> of each recipe will fit within the spirit of the language discussed so far, even if the implementations may not.</p>

<h3 id="memoize">Memoize</h3>

<p>Consider that age-old interview quiz, writing a recursive fibonacci function (there are other ways to derive a fibonacci number, of course). Here’s an implementation that doesn’t use a <a href="https://leanpub.com/javascriptallongesix/read#named-function-expressions">named function expression</a>. The reason for that omission will be explained later:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  <code class="kr">const</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">n</code> <code class="o">&lt;</code> <code class="mi">2</code>
      <code class="o">?</code> <code class="nx">n</code>
      <code class="o">:</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>
      
  <code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">,</code><code class="mi">7</code><code class="p">,</code><code class="mi">8</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">fibonacci</code><code class="p">)</code>
    <code class="c1">//=&gt; [0,1,1,2,3,5,8,13,21]</code>
</pre></div>

</figure>

<p>We’ll time it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">s</code> <code class="o">=</code> <code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">()).</code><code class="nx">getTime</code><code class="p">()</code>
<code class="nx">fibonacci</code><code class="p">(</code><code class="mi">45</code><code class="p">)</code>
<code class="p">(</code> <code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">()).</code><code class="nx">getTime</code><code class="p">()</code> <code class="o">-</code> <code class="nx">s</code> <code class="p">)</code> <code class="o">/</code> <code class="mi">1000</code>
  <code class="c1">//=&gt; 15.194</code>
</pre></div>

</figure>

<p>Why is it so slow? Well, it has a nasty habit of recalculating the same results over and over and over again. We could rearrange the computation to avoid this, but let’s be lazy and trade space for time. What we want to do is use a lookup table. Whenever we want a result, we look it up. If we don’t have it, we calculate it and write the result in the table to use in the future. If we do have it, we return the result without recalculating it.</p>

<p>Here’s our recipe:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">memoized</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">lookupTable</code> <code class="o">=</code> <code class="p">{};</code>
    
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  
    <code class="k">return</code> <code class="nx">lookupTable</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="nx">lookupTable</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We can apply <code>memoized</code> to a function and we will get back a new function that “memoizes” its results so that it never has to recalculate the same value twice. It only works for functions that are “idempotent,” meaning functions that always return the same result given the same argument(s). Like <code>fibonacci</code>:</p>

<p>Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fastFibonacci</code> <code class="o">=</code> <code class="nx">memoized</code><code class="p">(</code>
  <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">n</code> <code class="o">&lt;</code> <code class="mi">2</code>
      <code class="o">?</code> <code class="nx">n</code>
      <code class="o">:</code> <code class="nx">fastFibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nx">fastFibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
<code class="p">);</code>

<code class="nx">fastFibonacci</code><code class="p">(</code><code class="mi">45</code><code class="p">)</code>
  <code class="c1">//=&gt; 1134903170</code>
</pre></div>

</figure>

<p>We get the result back instantly. It works! You can use memoize with all sorts of “idempotent” pure functions. by default, it works with any function that takes arguments which can be transformed into JSON using JavaScript’s standard library function for this purpose.</p>

<p>If you have another strategy for turning the arguments into a string key, we’ll need to make a version that allows you to supply an optional <code>keymaker</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">memoized</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">keymaker</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">lookupTable</code> <code class="o">=</code> <code class="p">{};</code>
    
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">keymaker</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  
    <code class="k">return</code> <code class="nx">lookupTable</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="nx">lookupTable</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-memoizing-recursive-functions">memoizing recursive functions</h4>

<p>We deliberately picked a recursive function to memoize, because it demonstrates a pitfall when combining decorators with named functional expressions. Consider this implementation that uses a named functional expression:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fibonacci</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">n</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>If we try to memoize it, we don’t get the expected speedup:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="nx">memoized</code><code class="p">(</code> <code class="kd">function</code> <code class="nx">fibonacci</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">n</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>That’s because the function bound to the name <code>fibonacci</code> in the outer environment has been memoized, but the named functional expression binds the name <code>fibonacci</code> inside the unmemoized function, so none of the recursive calls to fibonacci are <em>ever</em> memoized. Therefore we must write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="nx">memoized</code><code class="p">(</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">n</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nx">fibonacci</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>If we need to prevent a rebinding from breaking the function, we’ll need to use the <a href="https://leanpub.com/javascriptallongesix/read#modules">module</a> pattern.</p>

<h3 id="getWith">getWith</h3>

<p><code>getWith</code> is a very simple function. It takes the name of an attribute and returns a function that extracts the value of that attribute from an object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">getWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">attr</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">object</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">object</code><code class="p">[</code><code class="nx">attr</code><code class="p">]</code>
</pre></div>

</figure>

<p>You can use it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">inventory</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">apples</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
  <code class="nx">oranges</code><code class="o">:</code> <code class="mi">144</code><code class="p">,</code>
  <code class="nx">eggs</code><code class="o">:</code> <code class="mi">36</code>
<code class="p">};</code>

<code class="nx">getWith</code><code class="p">(</code><code class="s1">'oranges'</code><code class="p">)(</code><code class="nx">inventory</code><code class="p">)</code>
  <code class="c1">//=&gt; 144</code>
</pre></div>

</figure>

<p>This isn’t much of a recipe yet. But let’s combine it with <a href="https://leanpub.com/javascriptallongesix/read#mapping">mapWith</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">inventories</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">144</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">36</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">240</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">54</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">12</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">24</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">12</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">42</code> <code class="p">}</code>
<code class="p">];</code>

<code class="nx">mapWith</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="s1">'oranges'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 144, 54, 12 ]</code>
</pre></div>

</figure>

<p>That’s nicer than writing things out “longhand:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">((</code><code class="nx">inventory</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">inventory</code><code class="p">.</code><code class="nx">oranges</code><code class="p">)(</code><code class="nx">inventories</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 144, 54, 12 ]</code>
</pre></div>

</figure>

<p><code>getWith</code> plays nicely with <a href="https://leanpub.com/javascriptallongesix/read#maybe">maybe</a> as well. Consider a sparse array. You can use:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">maybe</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="s1">'oranges'</code><code class="p">)))</code>
</pre></div>

</figure>

<p>To get the orange count from all the non-null inventories in a list.</p>

<h4 id="leanpub-auto-whats-in-a-name">what’s in a name?</h4>

<p>Why is this called <code>getWith</code>? Consider this function that is common in languages that have functions and dictionaries but not methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">get</code> <code class="o">=</code> <code class="p">(</code><code class="nx">object</code><code class="p">,</code> <code class="nx">attr</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">object</code><code class="p">[</code><code class="nx">attr</code><code class="p">];</code>
</pre></div>

</figure>

<p>You might ask, “Why use a function instead of just using <code>[]</code>?” The answer is, we can manipulate functions in ways that we can’t manipulate syntax. For example, do you remember from <a href="https://leanpub.com/javascriptallongesix/read#flip">flip</a> that we can define <code>mapWith</code> from <code>map</code>?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="nx">flip</code><code class="p">(</code><code class="nx">map</code><code class="p">);</code>
</pre></div>

</figure>

<p>We can do the same thing with <code>getWith</code>, and that’s why it’s named in this fashion:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">getWith</code> <code class="o">=</code> <code class="nx">flip</code><code class="p">(</code><code class="nx">get</code><code class="p">)</code>
</pre></div>

</figure>

<h3 id="pluck">pluckWith</h3>

<p>This pattern of combining <a href="https://leanpub.com/javascriptallongesix/read#mapping">mapWith</a> and <a href="https://leanpub.com/javascriptallongesix/read#getWith">getWith</a> is very frequent in JavaScript code. So much so, that we can take it up another level:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">pluckWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">attr</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="nx">attr</code><code class="p">));</code>
</pre></div>

</figure>

<p>Or even better:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">pluckWith</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">mapWith</code><code class="p">,</code> <code class="nx">getWith</code><code class="p">);</code>
</pre></div>

</figure>

<p>And now we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">inventories</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">144</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">36</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">240</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">54</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">12</code> <code class="p">},</code>
  <code class="p">{</code> <code class="nx">apples</code><code class="o">:</code> <code class="mi">24</code><code class="p">,</code> <code class="nx">oranges</code><code class="o">:</code> <code class="mi">12</code><code class="p">,</code> <code class="nx">eggs</code><code class="o">:</code> <code class="mi">42</code> <code class="p">}</code>
<code class="p">];</code>

<code class="nx">pluckWith</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">)(</code><code class="nx">inventories</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 36, 12, 42 ]</code>
</pre></div>

</figure>

<p>Libraries like <a href="http://underscorejs.org/">Underscore</a> provide <code>pluck</code>, the flipped version of <code>pluckWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">_</code><code class="p">.</code><code class="nx">pluck</code><code class="p">(</code><code class="nx">inventories</code><code class="p">,</code> <code class="s1">'eggs'</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 36, 12, 42 ]</code>
</pre></div>

</figure>

<p>Our recipe is terser when you want to name a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">eggsByStore</code> <code class="o">=</code> <code class="nx">pluckWith</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">);</code>
</pre></div>

</figure>

<p>vs.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">eggsByStore</code> <code class="o">=</code> <code class="p">(</code><code class="nx">inventories</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">_</code><code class="p">.</code><code class="nx">pluck</code><code class="p">(</code><code class="nx">inventories</code><code class="p">,</code> <code class="s1">'eggs'</code><code class="p">);</code>
</pre></div>

</figure>

<p>And of course, if we have <code>pluck</code> we can use <a href="https://leanpub.com/javascriptallongesix/read#flip">flip</a> to derive <code>pluckWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">pluckWith</code> <code class="o">=</code> <code class="nx">flip</code><code class="p">(</code><code class="nx">_</code><code class="p">.</code><code class="nx">pluck</code><code class="p">);</code>
</pre></div>

</figure>

<h3 id="deepMapWith">Deep Mapping</h3>

<p><a href="https://leanpub.com/javascriptallongesix/read#mapWith">mapWith</a> is an excellent tool, but from time to time you will find yourself working with arrays that represent trees rather than lists. For example, here is a partial list of sales extracted from a report of some kind. It’s grouped in some mysterious way, and we need to operate on each item in the report.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">report</code> <code class="o">=</code> 
  <code class="p">[</code> <code class="p">[</code> <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">1.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">1</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">4.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">7.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">3</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">1.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">4</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">2.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">5</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">6.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">6</code> <code class="p">}</code> <code class="p">],</code>
  <code class="p">[</code> <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">5.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">21</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">1.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">22</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">1.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">23</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">1.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">24</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">5.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">25</code> <code class="p">}</code> <code class="p">],</code>

  <code class="c1">// ...</code>

  <code class="p">[</code> <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">7.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">221</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">4.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">222</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">7.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">223</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">10.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">224</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">9.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">225</code> <code class="p">},</code>
    <code class="p">{</code> <code class="nx">price</code><code class="o">:</code> <code class="mf">9.99</code><code class="p">,</code> <code class="nx">id</code><code class="o">:</code> <code class="mi">226</code> <code class="p">}</code> <code class="p">]</code> <code class="p">];</code>
</pre></div>

</figure>

<p>We could nest some <code>mapWith</code>s, but we humans are tool users. If we can use a stick to extract tasty ants from a hole to eat, we can automate working with arrays:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">deepMapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="nx">innerdeepMapWith</code> <code class="p">(</code><code class="nx">tree</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">tree</code><code class="p">,</code> <code class="p">(</code><code class="nx">element</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code>
        <code class="o">?</code> <code class="nx">innerdeepMapWith</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code>
        <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code>
    <code class="p">);</code>
  <code class="p">};</code>
</pre></div>

</figure>

<p>And now we can use <code>deepMapWith</code> on a tree the way we use <code>mapWith</code> on a flat array:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">deepMapWith</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="s1">'price'</code><code class="p">))(</code><code class="nx">report</code><code class="p">)</code>
  <code class="c1">//=&gt;  [ [ 1.99,</code>
            <code class="mf">4.99</code><code class="p">,</code>
            <code class="mf">7.99</code><code class="p">,</code>
            <code class="mf">1.99</code><code class="p">,</code>
            <code class="mf">2.99</code><code class="p">,</code>
            <code class="mf">6.99</code> <code class="p">],</code>
          <code class="p">[</code> <code class="mf">5.99</code><code class="p">,</code>
            <code class="mf">1.99</code><code class="p">,</code>
            <code class="mf">1.99</code><code class="p">,</code>
            <code class="mf">1.99</code><code class="p">,</code>
            <code class="mf">5.99</code> <code class="p">],</code>
            
          <code class="c1">// ...</code>
          
          <code class="p">[</code> <code class="mf">7.99</code><code class="p">,</code>
            <code class="mf">4.99</code><code class="p">,</code>
            <code class="mf">7.99</code><code class="p">,</code>
            <code class="mf">10.99</code><code class="p">,</code>
            <code class="mf">9.99</code><code class="p">,</code>
            <code class="mf">9.99</code> <code class="p">]</code> <code class="p">]</code>
</pre></div>

</figure>

<p>We’ll have another look at trees of data when we look at TreeIterators for <a href="https://leanpub.com/javascriptallongesix/read#collections">Collections</a>.</p>

<h2 id="leanpub-auto-the-coffee-factory-object-oriented-programming">The Coffee Factory: “Object-Oriented Programming”</h2>

<p>Programming with objects and classes began in Norway in the late 1960s with the <a href="https://en.wikipedia.org/wiki/Simula">Simula</a> programming language. Its creators, Ole-Johan Dahl and Kristen Nygaard, did not use those words to describe what would eventually become the dominant paradigm in computing.</p>

<p>A decade later, Dr. Alan Kay coined the phrase “Object-Oriented Programming” along with co-creating the <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> programming language. He has famously said that to him, “OOP” was objects communicating with each other using messages, and that other languages copied the things that didn’t matter from Smalltalk, and ignored the things he thought did matter.</p>

<p>Since that time, languages have either bolted object-ish ideas on top of their existing paradigms (like <a href="https://en.wikipedia.org/wiki/Object_Pascal">Object Pascal</a> and <a href="https://en.wikipedia.org/wiki/OCaml">OCaml</a>), baked them in alongside other paradigms (like JavaScript), or embraced objects wholeheartedly.</p>

<p>That being said, there really is no one definition of “object-oriented.” For one thing, there is no one definition of “object.”</p>

<h4 id="leanpub-auto-objects">objects</h4>

<p>Some languages, like Smalltalk and <a href="https://en.wikipedia.org/wiki/Ruby_" title="programming_language">Ruby</a>, treat an object as a fully encapsulated entity. There is no access to an object’s private state, all you can do is invoke one of its methods. Other languages, like Java, permit objects to access each other’s  state.</p>

<p>Some languages (again, like Java) have very rigid objects and classes, it is impossible or awkward to add new methods or properties to objects at run time. Some are flexible about adding methods and properties at run time. And yet other languages treat objects as dictionaries, where properties and even methods can be added, modified, or removed with abandon.</p>

<p>So we can see that the concept of “object” is flexible across languages.</p>

<h4 id="leanpub-auto-classes">classes</h4>

<p>The concept of “class” is also flexible across languages. Object-oriented languages do not uniformly agree on whether classes are necessary, much less how they work. For example, The Common Lisp Object System defines behaviour with classes, and it also defines behaviour with generic functions. The <a href="https://en.wikipedia.org/wiki/Self_" title="programming_language">Self</a> and <a href="https://en.wikipedia.org/wiki/NewtonScript">NewtonScript</a> languages have prototypes instead of classes.</p>

<p>So some “OO” languages have objects, but not classes.</p>

<p>C++ has classes, but they are not “first-class entities.” You can’t assign a class to a variable or pass it to a function. You can, however, manipulate the constructors for classes, the functions that make new objects. But you can’t manipulate those constructors to change the behaviour of objects that have already been constructed, instance behaviour is early-bound by default.</p>

<p>Ruby has classes, and they’re first-class entities. You can ask an object for its class, you can put a class in a variable, pass it to a method, or return it from a method, just like every other entity in the language. Classes in Ruby and Smalltalk even have their own class, they are instances of <code>Class</code>!<sup id="fnref-meta"><a href="https://leanpub.com/javascriptallongesix/read#fn-meta" rel="footnote">1</a></sup> Instance behaviour is late-bound and open for extension.<sup id="fnref-mp"><a href="https://leanpub.com/javascriptallongesix/read#fn-mp" rel="footnote">2</a></sup></p>

<h4 id="leanpub-auto-constructors">constructors</h4>

<p>Some languages allow programs to construct objects independently, others (notably those that are heavily class-centric) require that objects always be constructed by their classes. Some languages allow any function or method to be used as a constructor, others require a special syntax or declaration for constructors.</p>

<h4 id="leanpub-auto-prototypes-are-not-classes">prototypes are not classes</h4>

<p>Prototypical languages like Self and NewtonScript eschew classes altogether, using <em>prototypes</em> to define common behaviour for a set of objects. The difference between a prototype and a class is similar to the difference between a model home and a blueprint for a home.</p>

<p>You can say to a builder, “make me a home just like that model home,” and the builder makes you a home that has a lot in common with the model home. You then decorate your home with additional personalization. But the model home is, itself, a home. Although you may choose to keep it empty, you could in principle move a family into it. This is different than asking a builder to make you a home based on a blueprint. The blueprint may specify the features of the home, but it isn’t a home. It could never be used as a home.</p>

<p>Prototypes are like model homes, and classes are like blueprints. Classes are not like the objects they describe.<sup id="fnref-wellactually"><a href="https://leanpub.com/javascriptallongesix/read#fn-wellactually" rel="footnote">3</a></sup></p>

<h4 id="leanpub-auto-object-oriented-programming-can-mean-almost-anything">“object-oriented programming” can mean almost anything</h4>

<p>From this whirlwind tour of “object-oriented programming,” we can see that the ideas behind “object-oriented programming” have some common roots in the history of programming languages, but each language implements its own particular flavour in its own particular way.</p>

<p>Thus, when we talk about “objects” and “prototypes” and “classes” in JavaScript, we’re talking about objects, prototypes, and classes <em>as implemented in JavaScript</em>. And we must keep in mind that other languages can have a radically different take on these ideas.</p>

<h4 id="leanpub-auto-the-javascript-approach">the javascript approach</h4>

<p>JavaScript has objects, and by default, those objects are dictionaries. By default, objects directly manipulate each other’s state. Methods can be added to, or removed from objects at run time. </p>

<p>JavaScript has optional prototypes. Prototypes are objects in the same sense that model homes are homes. </p>

<p>In JavaScript, object and array literals construct objects that delegate behaviour to the standard library’s object prototype and array prototype, respectively. JavaScript also supports using <code>Object.create</code> to construct objects with or without a prototype, and <code>new</code> to construct objects using a constructor function.</p>

<p>Using prototypes and constructor functions, JavaScript programs can emulate many of the features of classes in other languages. JavaScript also has a <code>class</code> keyword that provides syntactic sugar for writing constructor functions and prototypes in a declarative fashion.</p>

<p>By default, a JavaScript class is a constructor composed with an object as its associated prototype. This can be denoted with the <code>class</code> keyword, by working with a function’s default <code>.prototype</code> property, or by composing functions and objects independently.</p>

<p>JavaScript classes are constructors, but they are more than C++ constructors, in that manipulation of their prototype extends or modifies the behaviour of the instances they create. JavaScript classes take a minimalist approach to OO in the same sense that JavaScript objects take a minimal approach to OO. For example, behaviour can be mixed into an object, a prototype, or a class using the exact same mechanism, because objects, prototypes, and a constructor’s prototype are all objects that are open to extension.</p>

<p>In sum, JavaScript is not exactly like any other object-oriented programming language, and its classes aren’t like any other language that features classes, but then again, neither is any other object-oriented programming language, and neither are any other classes.</p>

<div class="footnotes">
  <ol>
    <li id="fn-meta">If the class of a class is <code>Class</code>, what class is the class of <code>Class</code>? In Ruby, <code>Class.class == Class</code>. In Smalltalk, it is <code>MetaClass</code>, which opens up the possibility for changing the way classes behave in a deep way.<a href="https://leanpub.com/javascriptallongesix/read#fnref-meta" rel="rev-footnote">↩</a>
</li>
    <li id="fn-mp">Abuse of this feature by extending the behaviour of built-in classes is a controversial topic.<a href="https://leanpub.com/javascriptallongesix/read#fnref-mp" rel="rev-footnote">↩</a>
</li>
    <li id="fn-wellactually">Well, <em>actually</em>, the difference between prototypes and classes is like the difference between model homes and blueprints. But prototypes are not like model homes. In actual fact, the relationship between an object and its prototype is one of <em>delegation</em>. So if a model home had a kitchen, and you asked the builder to make you a home using the model as a prototype, you could customize your own kitchen. But if you didn’t want to have your own custom kitchen, you would just use the model home’s kitchen to do all your own cooking. The relationship between a model home and a house is sometimes described as <a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">concatenative inheritance</a>, and JavaScript lets you do that too.<a href="https://leanpub.com/javascriptallongesix/read#fnref-wellactually" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="collections">Served by the Pot: Collections</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/pots.jpg" alt="Some different sized and coloured coffee pots by Antti Nurmesniemi, perhaps his most known design.">
  <figcaption>Some different sized and coloured coffee pots by Antti Nurmesniemi, perhaps his most known design.</figcaption>
</figure>


<h3 id="iterables">Iteration and Iterables</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/saltspring----coffee-labels.jpg" alt="Coffee Labels at the Saltspring Coffee Processing Facility">
  <figcaption>Coffee Labels at the Saltspring Coffee Processing Facility</figcaption>
</figure>


<p>Many objects in JavaScript can model collections of things. A collection is like a box containing stuff. Sometimes you just want to move the box around. But sometimes you want to open it up and do things with its contents.</p>

<p>Things like “put a label on every bag of coffee in this box,” Or, “Open the box, take out the bags of decaf, and make a new box with just the decaf.” Or, “go through the bags in this box, and take out the first one marked ‘Espresso’ that contains at least 454 grams of beans.”</p>

<p>All of these actions involve going through the contents one by one. Acting on the elements of a collection one at a time is called <em>iterating over the contents</em>, and JavaScript has a standard way to iterate over the contents of collections.</p>

<h4 id="leanpub-auto-a-look-back-at-functional-iterators">a look back at functional iterators</h4>

<p>When discussing functions, we looked at the benefits of writing <a href="https://leanpub.com/javascriptallongesix/read#functional-iterators">Functional Iterators</a>. We can do the same thing for objects. Here’s a stack that has its own functional iterator method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Stack1</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code><code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>

      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">},</code>
    <code class="nx">iterator</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>

      <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">)</code> <code class="p">{</code>
          <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">iterationIndex</code><code class="o">--</code><code class="p">]}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="nx">Stack1</code><code class="p">();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"Greetings"</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"to"</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"you!"</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">iter</code> <code class="o">=</code> <code class="nx">stack</code><code class="p">.</code><code class="nx">iterator</code><code class="p">();</code>
<code class="nx">iter</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; "you!"</code>
<code class="nx">iter</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; "to"</code>
</pre></div>

</figure>

<p>The way we’ve written <code>.iterator</code> as a method, each object knows how to return an iterator for itself.</p>

<aside>
  <p>The <code>.iterator()</code> method is defined with shorthand equivalent to <code>iterator: function iterator() { ... }</code>. Note that it uses the <code>function</code> keyword, so when we invoke it with <code>stack.iterator()</code>, JavaScript sets <code>this</code> to the value of <code>stack</code>. But what about the function <code>.iterator()</code> returns? It is defined with a fat arrow <code>() =&gt; { ... }</code>. What is the value of <code>this</code> within that function?</p>

  <p>Since JavaScript doesn’t bind <code>this</code> within a fat arrow function, we follow the same rules of variable scoping as any other variable name: We check in the environment enclosing the function. Although the <code>.iterator()</code> method has returned, its environment is the one that encloses our <code>() =&gt; { ... }</code> function, and that’s where <code>this</code> is bound to the value of <code>stack</code>.</p>

  <p>Therefore, the iterator function returned by the <code>.iterator()</code> method has <code>this</code> bound to the <code>stack</code> object, even though we call it with <code>iter()</code>.</p>

</aside>

<p>And here’s a <code>sum</code> function implemented as a fold over a functional iterator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">iteratorSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterator</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We can use it with our stack:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="nx">Stack1</code><code class="p">();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>

<code class="nx">iteratorSum</code><code class="p">(</code><code class="nx">stack</code><code class="p">.</code><code class="nx">iterator</code><code class="p">())</code>
  <code class="c1">//=&gt; 6</code>
</pre></div>

</figure>

<p>We could save a step and write <code>collectionSum</code>, a function that folds over any object, provided that the object implements an <code>.iterator</code> method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">collectionSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">collection</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">.</code><code class="nx">iterator</code><code class="p">();</code>

  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">collectionSum</code><code class="p">(</code><code class="nx">stack</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>
</pre></div>

</figure>

<p>If we write a program with the presumption that “everything is an object,” we can write maps, folds, and filters that work on objects. We just ask the object for an iterator, and work on the iterator. Our functions don’t need to know anything about how an object implements iteration, and we get the benefit of lazily traversing our objects.</p>

<p>This is a good thing.</p>

<h4 id="leanpub-auto-iterator-objects">iterator objects</h4>

<p>Iteration for functions and objects has been around for many, many decades. For simple linear collections like arrays, linked lists, stacks, and queues, functional iterators are the simplest and easiest way to implement iterators.</p>

<p>In programs involving large collections of objects, it can be handy to implement iterators as objects, rather than functions. The mechanics of iterating can then be factored using the same tools that are used to factor the mechanics of all other objects in the system.</p>

<p>Fortunately, an iterator object is almost as simple as an iterator function. Instead of having a function that you call to get the next element, you have an object with a <code>.next()</code> method.</p>

<p>Like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Stack2</code> <code class="o">=</code> <code class="p">())</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>

      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">},</code>
    <code class="nx">iterator</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>
          <code class="p">}</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">iterationIndex</code><code class="o">--</code><code class="p">]}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="nx">Stack2</code><code class="p">();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2000</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">collectionSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">collection</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">.</code><code class="nx">iterator</code><code class="p">();</code>

  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">collectionSum</code><code class="p">(</code><code class="nx">stack</code><code class="p">)</code>
  <code class="c1">//=&gt; 2015</code>
</pre></div>

</figure>

<p>Now our <code>.iterator()</code> method is returning an iterator object. When working with objects, we do things the object way. But having started by building functional iterators, we understand what is happening underneath the object’s scaffolding.</p>

<h4 id="leanpub-auto-iterables">iterables</h4>

<p>People have been writing iterators since JavaScript was first released in the late 1990s. Since there was no particular standard way to do it, people used all sorts of methods, and their methods returned all sorts of things: Objects with various interfaces, functional iterators, you name it.</p>

<p>So, when a standard way to write iterators was added to the JavaScript language, it didn’t make sense to use a method like <code>.iterator()</code> for it: That would conflict with existing code. Instead, the language encourages new code to be written with a different name for the method that a collection object uses to return its iterator.</p>

<p>To ensure that the method would not conflict with any existing code, JavaScript provides a <em>symbol</em>. Symbols are unique constants that are guaranteed not to conflict with existing strings. Symbols are a longstanding technique in programming going back to Lisp, where the <code>GENSYM</code> function generated… You guessed it… Symbols.<sup id="fnref-symbol"><a href="https://leanpub.com/javascriptallongesix/read#fn-symbol" rel="footnote">1</a></sup></p>

<p>The expression <code>Symbol.iterator</code> evaluates to a special symbol representing the name of the method that objects should use if they return an iterator object.</p>

<p>Our stack does, so instead of binding the existing iterator method to the name <code>iterator</code>, we bind it to the <code>Symbol.iterator</code>. We’ll do that using the <code>[</code> <code>]</code> syntax for using an expression as an object literal key:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Stack3</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">pop</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>

      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">},</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>
          <code class="p">}</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">iterationIndex</code><code class="o">--</code><code class="p">]}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="nx">Stack3</code><code class="p">();</code>

<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2000</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">collectionSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">collection</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

  <code class="kd">let</code> <code class="nx">eachIteration</code><code class="p">,</code>
      <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">((</code><code class="nx">eachIteration</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code> <code class="o">!</code><code class="nx">eachIteration</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">eachIteration</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">collectionSum</code><code class="p">(</code><code class="nx">stack</code><code class="p">)</code>
  <code class="c1">//=&gt; 2015</code>
</pre></div>

</figure>

<p>Using <code>[Symbol.iterator]</code> instead of <code>.iterator</code> seems like adding an extra moving part for nothing. Do we get anything in return?</p>

<p>Indeed we do. Behold the <code>for...of</code> loop:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">iterableSum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">num</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">sum</code>
<code class="p">}</code>

<code class="nx">iterableSum</code><code class="p">(</code><code class="nx">stack</code><code class="p">)</code>
  <code class="c1">//=&gt; 2015</code>
</pre></div>

</figure>

<p>The <code>for...of</code> loop works directly with any object that is <em>iterable</em>, meaning it works with any object that has a <code>Symbol.iterator</code> method that returns an object iterator. Here’s another linked list, this one is iterable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">Pair1</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">rest</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">first</code><code class="p">,</code>
    <code class="nx">rest</code><code class="p">,</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code> <code class="p">},</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">currentPair</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">currentPair</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">}</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">first</code><code class="p">;</code>

            <code class="nx">currentPair</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">rest</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">elements</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="nx">elements</code><code class="p">;</code>

  <code class="k">return</code> <code class="nx">elements</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="nx">EMPTY</code>
    <code class="o">:</code> <code class="nx">Pair1</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">list</code><code class="p">(...</code><code class="nx">rest</code><code class="p">))</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">someSquares</code> <code class="o">=</code> <code class="nx">list</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">25</code><code class="p">);</code>

<code class="nx">iterableSum</code><code class="p">(</code><code class="nx">someSquares</code><code class="p">)</code>
  <code class="c1">//=&gt; 55</code>
</pre></div>

</figure>

<p>As we can see, we can use <code>for...of</code> with linked lists just as easily as with stacks. And there’s one more thing: You recall that the spread operator (<code>...</code>) can spread the elements of an array in an array literal or as parameters in a function invocation.</p>

<p>Now is the time to note that we can spread any iterable. So we can spread the elements of an iterable into an array literal:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="s1">'some squares'</code><code class="p">,</code> <code class="p">...</code><code class="nx">someSquares</code><code class="p">]</code>
  <code class="c1">//=&gt; ["some squares", 1, 4, 9, 16, 25]</code>
</pre></div>

</figure>

<p>And we can also spread the elements of an array literal into parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstAndSecondElement</code> <code class="o">=</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">})</code>

<code class="nx">firstAndSecondElement</code><code class="p">(...</code><code class="nx">stack</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":5,"second":10}</code>
</pre></div>

</figure>

<p>This can be extremely useful.</p>

<p>One caveat of spreading iterables: JavaScript creates an array out of the elements of the iterable. That might be very wasteful for extremely large collections. For example, if we spread a large collection just to find an element in the collection, it might have been wiser to iterate over the element using its iterator directly.</p>

<p>And if we have an infinite collection, spreading is going to fail outright as we’re about to see.</p>

<h4 id="leanpub-auto-iterables-out-to-infinity">iterables out to infinity</h4>

<p>Iterables needn’t represent finite collections:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Numbers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
        <code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code><code class="p">})</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>There are useful things we can do with iterables representing an infinitely large collection. But let’s point out what we can’t do with them:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="s1">'all the numbers'</code><code class="p">,</code> <code class="p">...</code><code class="nx">Numbers</code><code class="p">]</code>
  <code class="c1">//=&gt; infinite loop!</code>

<code class="nx">firstAndSecondElement</code><code class="p">(...</code><code class="nx">Numbers</code><code class="p">)</code>
  <code class="c1">//=&gt; infinite loop!</code>
</pre></div>

</figure>

<p>Attempting to spread an infinite iterable into an array is always going to fail.</p>

<h4 id="leanpub-auto-ordered-collections">ordered collections</h4>

<p>The iterables we’re discussing represent <em>ordered collections</em>. One of the semantic properties of an ordered collection is that every time you iterate over it, you get its elements in order, from the beginning. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">abc</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code> <code class="s2">"b"</code><code class="p">,</code> <code class="s2">"c"</code><code class="p">];</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">a</code>
    <code class="nx">b</code>
    <code class="nx">c</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">a</code>
    <code class="nx">b</code>
    <code class="nx">c</code>
</pre></div>

</figure>

<p>This is accomplished with our own collections by returning a brand new iterator every time we call <code>[Symbol.iterator]</code>, and ensuring that our iterators start at the beginning and work forward.</p>

<p>Iterables needn’t represent ordered collections. We could make an infinite iterable representing random numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">RandomNumbers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
    <code class="p">({</code>
      <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()};</code>
      <code class="p">}</code>
    <code class="p">})</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">RandomNumbers</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mf">0.494052127469331</code>
    <code class="mf">0.835459444206208</code>
    <code class="mf">0.1408337657339871</code>
    <code class="p">...</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">RandomNumbers</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mf">0.7845381607767195</code>
    <code class="mf">0.4956772483419627</code>
    <code class="mf">0.20259276474826038</code>
    <code class="p">...</code>
</pre></div>

</figure>

<p>Whether you work with the same iterator over and over, or get a fresh iterable every time, you are always going to get fresh random numbers. Therefore, <code>RandomNumbers</code> is not an ordered collection.</p>

<p>Right now, we’re just looking at ordered collections. To reiterate (hah), an ordered collection represents a (possibly infinite) collection of elements that are in some order. Every time we get an iterator from an ordered collection, we start iterating from the beginning.</p>

<h4 id="operations">operations on ordered collections</h4>

<p>Let’s define some operations on ordered collections. Here’s <code>mapWith</code>, it takes an ordered collection, and returns another ordered collection representing a mapping over the original:<sup id="fnref-mapWith"><a href="https://leanpub.com/javascriptallongesix/read#fn-mapWith" rel="footnote">2</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">collection</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">collection</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

          <code class="k">return</code> <code class="p">({</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">)});</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>This illustrates the general pattern of working with ordered collections: We make them <em>iterables</em>, meaning that they have a <code>[Symbol.iterator]</code> method, that returns an <em>iterator</em>. An iterator is also an object, but with a <code>.next()</code> method that is invoked repeatedly to obtain the elements in order.</p>

<p>Many operations on ordered collections return another ordered collection. They do so by taking care to iterate over a result freshly every time we get an iterator for them. Consider this example for <code>mapWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Evens</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">Numbers</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">Evens</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mi">0</code>
    <code class="mi">2</code>
    <code class="mi">4</code>
    <code class="p">...</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">Evens</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mi">0</code>
    <code class="mi">2</code>
    <code class="mi">4</code>
    <code class="p">...</code>
</pre></div>

</figure>

<p><code>Numbers</code> is an ordered collection. We invoke <code>mapWith((x) =&gt; 2 * x, Numbers)</code> and get <code>Evens</code>. <code>Evens</code> works just as if we’d written this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Evens</code> <code class="o">=</code>  <code class="p">{</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">Numbers</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

        <code class="k">return</code> <code class="p">({</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="mi">2</code> <code class="o">*</code><code class="nx">value</code><code class="p">});</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Every time we write <code>for (const i of Evens)</code>, JavaScript calls <code>Evens[Symbol.iterator]()</code>. That in turns means it executes <code>const iterator = Numbers[Symbol.iterator]();</code> every time we write <code>for (const i of Evens)</code>, and that means that <code>iterator</code> starts at the beginning of <code>Numbers</code>.</p>

<p>So, <code>Evens</code> is also an ordered collection, because it starts at the beginning each time we get a fresh iterator over it. Thus, <code>mapWith</code> has the property of preserving the collection semantics of the iterable we give it. So we call it a <em>collection operation</em>.</p>

<p>Mind you, we can also map non-collection iterables, like <code>RandomNumbers</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">ZeroesToNines</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="mi">10</code> <code class="o">*</code> <code class="nx">limit</code><code class="p">),</code> <code class="nx">RandomNumbers</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">ZeroesToNines</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mi">5</code>
    <code class="mi">1</code>
    <code class="mi">9</code>
    <code class="p">...</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">ZeroesToNines</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="mi">3</code>
    <code class="mi">6</code>
    <code class="mi">1</code>
    <code class="p">...</code>
</pre></div>

</figure>

<p><code>mapWith</code> can get a new iterator from <code>RandomNumbers</code> each time we iterate over <code>ZeroesToNines</code>, but if <code>RandomNumbers</code> doesn’t behave like an ordered collection, that’s not <code>mapWith</code>’s fault. <code>RandomNumbers</code> is a <em>stream</em>, not an ordered collection, and thus <code>mapWith</code> returns another iterable behaving like a stream.</p>

<p>Here are two more operations on ordered collections, <code>filterWith</code> and <code>untilWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">filterWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">do</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
          <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">));</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">};</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kr">const</code> <code class="nx">untilWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
          <code class="kd">let</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

          <code class="nx">done</code> <code class="o">=</code> <code class="nx">done</code> <code class="o">||</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>

          <code class="k">return</code> <code class="p">({</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">value</code><code class="p">});</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>Like <code>mapWith</code>, they preserve the ordered collection semantics of whatever you give them.</p>

<p>And here’s a computation performed using operations on ordered collections: We’ll create an ordered collection of square numbers that end in one and are less than 1,000:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Squares</code> <code class="o">=</code> <code class="nx">mapWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">Numbers</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">EndWithOne</code> <code class="o">=</code> <code class="nx">filterWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">10</code> <code class="o">===</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">Squares</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">UpTo1000</code> <code class="o">=</code> <code class="nx">untilWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">1000</code><code class="p">),</code> <code class="nx">EndWithOne</code><code class="p">);</code>

<code class="p">[...</code><code class="nx">UpTo1000</code><code class="p">]</code>
  <code class="c1">//=&gt;</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">81</code><code class="p">,</code><code class="mi">121</code><code class="p">,</code><code class="mi">361</code><code class="p">,</code><code class="mi">441</code><code class="p">,</code><code class="mi">841</code><code class="p">,</code><code class="mi">961</code><code class="p">]</code>

<code class="p">[...</code><code class="nx">UpTo1000</code><code class="p">]</code>
  <code class="c1">//=&gt;</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">81</code><code class="p">,</code><code class="mi">121</code><code class="p">,</code><code class="mi">361</code><code class="p">,</code><code class="mi">441</code><code class="p">,</code><code class="mi">841</code><code class="p">,</code><code class="mi">961</code><code class="p">]</code>
</pre></div>

</figure>

<p>As we expect from an ordered collection, each time we iterate over <code>UpTo1000</code>, we begin at the beginning.</p>

<p>For completeness, here are two more handy iterable functions. <code>first</code> returns the first element of an iterable (if it has one), and <code>rest</code> returns an iterable that iterates over all but the first element of an iterable. They are equivalent to destructuring arrays with <code>[first, ...rest]</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]().</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">rest</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

      <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
      <code class="k">return</code> <code class="nx">iterator</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>like our other operations, <code>rest</code> preserves the ordered collection semantics of its argument.</p>

<h4 id="leanpub-auto-from">from</h4>

<p>Having iterated over a collection, are we limited to <code>for..do</code> and/or gathering the elements in an array literal and/or gathering the elements into the parameters of a function? No, of course not, we can do anything we like with them.</p>

<p>One useful thing is to write a <code>.from</code> function that gathers an iterable into a particular collection type. JavaScript’s built-in <code>Array</code> class already has one:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">UpTo1000</code><code class="p">)</code>
  <code class="c1">//=&gt; [1,81,121,361,441,841,961]</code>
</pre></div>

</figure>

<p>We can do the same with our own collections. As you recall, functions are mutable objects. And we can assign properties to functions with a <code>.</code> or even <code>[</code> and <code>]</code>. And if we assign a function to a property, we’ve created a method.</p>

<p>So let’s do that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Stack3</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="k">this</code><code class="p">();</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">stack</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Pair1</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="kd">function</code> <code class="nx">iterationToList</code> <code class="p">(</code><code class="nx">iteration</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iteration</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

    <code class="k">return</code> <code class="nx">done</code> <code class="o">?</code> <code class="nx">EMPTY</code> <code class="o">:</code> <code class="nx">Pair1</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">iterationToList</code><code class="p">(</code><code class="nx">iteration</code><code class="p">));</code>
  <code class="p">})(</code><code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]())</code>
</pre></div>

</figure>

<p>Now we can go “end to end,” If we want to map a linked list of numbers to a linked list of the squares of some numbers, we can do that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">numberList</code> <code class="o">=</code> <code class="nx">Pair1</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">untilWith</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">Numbers</code><code class="p">));</code>

<code class="nx">Pair1</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">Squares</code><code class="p">)</code>
  <code class="c1">//=&gt; {"first":0,</code>
        <code class="s2">"rest"</code><code class="o">:</code><code class="p">{</code><code class="s2">"first"</code><code class="o">:</code><code class="mi">1</code><code class="p">,</code>
                <code class="s2">"rest"</code><code class="o">:</code><code class="p">{</code><code class="s2">"first"</code><code class="o">:</code><code class="mi">4</code><code class="p">,</code>
                        <code class="s2">"rest"</code><code class="o">:</code><code class="p">{</code> <code class="p">...</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-summary-5">summary</h4>

<p>Iterators are a JavaScript feature that allow us to separate the concerns of how to iterate over a collection from what we want to do with the elements of a collection. <em>Iterable</em> ordered collections can be iterated over or gathered into another collection.</p>

<p>Separating concerns with iterators speaks to JavaScript’s fundamental nature: It’s a language that <em>wants</em> to compose functionality out of small, singe-responsibility pieces, whether those pieces are functions or objects built out of functions.</p>

<h3 id="generating-iterables">Generating Iterables</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/banco.jpg" alt="Banco do Café">
  <figcaption>Banco do Café</figcaption>
</figure>


<p>Iterables look cool, but then again, everything looks amazing when you’re given cherry-picked examples. What is there they don’t do well?</p>

<p>Let’s consider how they work. Whether it’s a simple functional iterator, or an iterable object with a <code>.next()</code> method, an iterator is something we call repeatedly until it tells us that it’s done.</p>

<p>Iterators have to arrange its own state such that when you call them, they compute and return the next item. This seems blindingly obvious and simple. If, for example, you want numbers, you write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Numbers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
        <code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code><code class="p">})</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The <code>Numbers</code> iterable returns an object that updates a mutable variable, <code>n</code>, to deliver number after number. How hard can this be?</p>

<p>Well, we’ve written our iterator as a <em>server</em>. It waits until given a request, and then it returns exactly one item. Then it waits for the next request. There is no concept of pushing numbers out from the iterator, just waiting until a number is pulled out of the iterator by whatever code consumes numbers.</p>

<p>Of course, when we have some code that makes a bunch of something, we don’t usually write it like that. We usually just write something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="o">++</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And magically, the numbers would pour forth. We would <em>generate</em> numbers. Let’s put that beside the code for the iterator, minus the iterable scaffolding:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Iteration</code>
<code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code><code class="p">})</code>

<code class="c1">// Generation</code>
<code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="o">++</code><code class="p">)</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>They’re of approximately equal complexity. So why bring up generation? Well, there are some collections that are much easier to generate than to iterate over. Let’s look at one:</p>

<h4 id="leanpub-auto-recursive-iterators">recursive iterators</h4>

<p>Iterators maintain state, that’s what they do. Generators have to manage the exact same amount of state, but sometimes, it’s much easier to manage that state in a generator. One of those cases is when we have to recursively enumerate something.</p>

<p>For example, iterating over a tree. Given an array that might contain arrays, let’s say we want to generate all the “leaf” elements, i.e. elements that are not, themselves, iterable.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Generation</code>
<code class="kr">const</code> <code class="nx">isIterable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="o">!!</code><code class="nx">something</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">generate</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">generate</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">generate</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">]])</code>
<code class="c1">//=&gt;</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
</pre></div>

</figure>

<p>Very simple. Now for the iteration version. We’ll write a functional iterator to keep things simple, but it’s easy to see the shape of the basic problem:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Iteration</code>
<code class="kr">const</code> <code class="nx">isIterable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="o">!!</code><code class="nx">something</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">treeIterator</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterators</code> <code class="o">=</code> <code class="p">[</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">];</code>

  <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">while</code> <code class="p">(</code><code class="o">!!</code><code class="nx">iterators</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterationResult</code> <code class="o">=</code> <code class="nx">iterators</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">next</code><code class="p">();</code>

      <code class="k">if</code> <code class="p">(</code><code class="nx">iterationResult</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">iterators</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="nx">iterationResult</code><code class="p">.</code><code class="nx">value</code><code class="p">))</code> <code class="p">{</code>
        <code class="nx">iterators</code><code class="p">.</code><code class="nx">unshift</code><code class="p">(</code><code class="nx">iterationResult</code><code class="p">.</code><code class="nx">value</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]());</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">iterationResult</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
    <code class="k">return</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">treeIterator</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">]]);</code>
<code class="kd">let</code> <code class="nx">n</code><code class="p">;</code>

<code class="k">while</code> <code class="p">(</code><code class="nx">n</code> <code class="o">=</code> <code class="nx">i</code><code class="p">())</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
</pre></div>

</figure>

<p>If you peel off <code>isIterable</code> and ignore the way that the iteration version uses <code>[Symbol.iterator]</code> and <code>.next</code>, we’re left with the fact that the generating version calls itself recursively, and the iteration version maintains an explicit stack. In essence, both the generation and iteration implementations have stacks, but the generation version’s stack is <em>implicit</em>, while the iteration version’s stack is <em>explicit</em>.</p>

<p>A less kind way to put it is that the iteration version is greenspunning something built into our programming language: We’re reinventing the use of a stack to manage recursion, because writing our code to respond to a function call makes us turn a simple recursive algorithm inside-out.</p>

<h4 id="leanpub-auto-state-machines">state machines</h4>

<p>Some iterables can be modelled as state machines. Let’s revisit the Fibonacci sequence. Again. One way to define it is:</p>

<ul>
  <li>The first element of the fibonacci sequence is zero.</li>
  <li>The second element of the fibonacci sequence is one.</li>
  <li>Every subsequent element of the fibonacci sequence is the sum of the previous two elements.</li>
</ul>

<p>Let’s write a generator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Generation</code>
<code class="kr">const</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">;</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">=</code> <code class="mi">0</code><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code> <code class="o">=</code> <code class="mi">1</code><code class="p">);</code>

  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">];</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">fibonacci</code><code class="p">()</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">5</code>
  <code class="mi">8</code>
  <code class="mi">13</code>
  <code class="mi">21</code>
  <code class="mi">34</code>
  <code class="mi">55</code>
  <code class="mi">89</code>
  <code class="mi">144</code>
  <code class="p">...</code>
</pre></div>

</figure>

<p>The thing to note here is that our <code>fibonacci</code> generator has three states: generating <code>0</code>, generating <code>1</code>, and generating everything after that. This isn’t a good fit for an iterator, because iterators have one functional entry point and therefore, we’d have to represent our three states explicitly, perhaps using a <a href="https://en.wikipedia.org/wiki/State_pattern">state pattern</a>:</p>

<p>We’ll keep it simple:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// Iteration</code>
<code class="kd">let</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">state</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">fibonacci</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">case</code> <code class="mi">0</code><code class="o">:</code>
      <code class="nx">state</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
      <code class="nx">state</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
    <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
      <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">];</code>
      <code class="k">return</code> <code class="nx">b</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">fibonacci</code><code class="p">());</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">5</code>
  <code class="mi">8</code>
  <code class="mi">13</code>
  <code class="mi">21</code>
  <code class="mi">34</code>
  <code class="mi">55</code>
  <code class="mi">89</code>
  <code class="mi">144</code>
  <code class="p">...</code>
</pre></div>

</figure>

<p>Again, this is not particularly horrendous, but like the recursive example, we’re explicitly greenspunning the natural linear state. In a generator, we write “do this, then  this, then this.” In an iterator, we have to wrap that up and explicitly keep track of what step we’re on.</p>

<p>So we see the same thing: The generation version has state, but it’s implicit in JavaScript’s linear control flow. Whereas the iteration version must make that state explicit.</p>

<h4 id="leanpub-auto-javascripts-generators">javascript’s generators</h4>

<p>It would be very nice if we could sometimes write iterators as a <code>.next()</code> method that gets called, and sometimes write out a generator. Given the title of this chapter, it is not a surprise that JavaScript  makes this possible.</p>

<p>We can write an iterator, but use a generation style of programming. An iterator written in a generation style is called a <em>generator</em>. To write a generator, we write a function, but we make two changes:</p>

<ol class="numeric">
  <li>We declare the function using the <code>function *</code> syntax. Not a fat arrow. Not a plain <code>function</code>.</li>
  <li>We don’t <code>return</code> values or output them to <code>console.log</code>. We “yield” values using the <code>yield</code> keyword.</li>
</ol>

<p>When we invoke the function, we get an iterator object back. Let’s start with the degenerate example, the <code>empty iterator</code>:<sup id="fnref-empty"><a href="https://leanpub.com/javascriptallongesix/read#fn-empty" rel="footnote">3</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">empty</code> <code class="p">()</code> <code class="p">{};</code>

<code class="nx">empty</code><code class="p">().</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">true</code><code class="p">}</code>
</pre></div>

</figure>

<p>When we invoke <code>empty</code>, we get an iterator with no elements. This makes sense, because <code>empty</code> never yields anything. We call its <code>.next()</code> method, but it’s done immediately.</p>

<p>Generator functions can take an argument. Let’s use that to illustrate <code>yield</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">only</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">yield</code> <code class="nx">something</code><code class="p">;</code>
<code class="p">};</code>

<code class="nx">only</code><code class="p">(</code><code class="s2">"you"</code><code class="p">).</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="s2">"you"</code><code class="p">}</code>
</pre></div>

</figure>

<p>Invoking <code>only("you")</code> returns an iterator that we can call with <code>.next()</code>, and it yields <code>"you"</code>. Invoking <code>only</code> more than once gives us fresh iterators each time:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">only</code><code class="p">(</code><code class="s2">"you"</code><code class="p">).</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="s2">"you"</code><code class="p">}</code>

<code class="nx">only</code><code class="p">(</code><code class="s2">"the lonely"</code><code class="p">).</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="s2">"the lonely"</code><code class="p">}</code>
</pre></div>

</figure>

<p>We can invoke the same iterator twice:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sixteen</code> <code class="o">=</code> <code class="nx">only</code><code class="p">(</code><code class="s2">"sixteen"</code><code class="p">);</code>

<code class="nx">sixteen</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="s2">"sixteen"</code><code class="p">}</code>

<code class="nx">sixteen</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">true</code><code class="p">}</code>
</pre></div>

</figure>

<p>It yields the value of <code>something</code>, and then it’s done.</p>

<h4 id="leanpub-auto-generators-are-coroutines">generators are coroutines</h4>

<p>Here’s a generator that yields three numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="kd">function</code> <code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
  <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
  <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
<code class="p">};</code>

<code class="nx">oneTwoThree</code><code class="p">().</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>

<code class="nx">oneTwoThree</code><code class="p">().</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>

<code class="nx">oneTwoThree</code><code class="p">().</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>

<code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">oneTwoThree</code><code class="p">();</code>

<code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>

<code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">2</code><code class="p">}</code>

<code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">3</code><code class="p">}</code>

<code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">true</code><code class="p">}</code>
</pre></div>

</figure>

<p>This is where generators behave very, very differently from ordinary functions. What happens <em>semantically</em>?</p>

<ol class="numeric">
  <li>We call <code>oneTwoThree()</code> and get an iterator.</li>
  <li>The iterator is in a nascent or “newborn” state.</li>
  <li>When we call <code>interator.next()</code>, the body of our generator begins to be evaluated.</li>
  <li>The body of our generator runs until it returns, ends, or encounters a <code>yield</code> statement, which is <code>yield 1;</code>.
    <ul>
      <li>The iterator <em>suspends its execution</em>.</li>
      <li>The iterator wraps <code>1</code> in <code>{done: false, value: 1}</code> and returns that from the call to <code>.next()</code>.</li>
      <li>The rest of the program continues along its way until it makes another call to <code>iterator.next()</code>.</li>
      <li>The iterator <em>resumes execution</em> from the point where it yielded the last value.</li>
    </ul>
  </li>
  <li>The body of our generator runs until it returns, ends, or encounters the next <code>yield</code> statement, which is <code>yield 2;</code>.
    <ul>
      <li>The iterator <em>suspends its execution</em>.</li>
      <li>The iterator wraps <code>2</code> in <code>{done: false, value: 2}</code> and returns that from the call to <code>.next()</code>.</li>
      <li>The rest of the program continues along its way until it makes another call to <code>iterator.next()</code>.</li>
      <li>The iterator <em>resumes execution</em> from the point where it yielded the last value.</li>
    </ul>
  </li>
  <li>The body of our generator runs until it returns, ends, or encounters the next <code>yield</code> statement, which is <code>yield 3;</code>.
    <ul>
      <li>The iterator <em>suspends its execution</em>.</li>
      <li>The iterator wraps <code>3</code> in <code>{done: false, value: 3}</code> and returns that from the call to <code>.next()</code>.</li>
      <li>The rest of the program continues along its way until it makes another call to <code>iterator.next()</code>.</li>
      <li>The iterator <em>resumes execution</em> from the point where it yielded the last value.</li>
    </ul>
  </li>
  <li>The body of our generator runs until it returns, ends, or encounters the next <code>yield</code> statement. There are no more lines of code, so it ends.
    <ul>
      <li>The iterator returns <code>{done: true}</code> from the call to <code>.next()</code>, and every call to this iterator’s <code>.next()</code> method will return <code>{done: true}</code> from now on.</li>
    </ul>
  </li>
</ol>

<p>This behaviour is not unique to JavaScript, generators are called <a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a> in other languages:</p>

<blockquote>
  <p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.</p>
</blockquote>

<p>Instead of thinking of there being on execution context, we can imagine that there are two execution contexts. With an iterator, we can call them the <em>producer</em> and the <em>consumer</em>. The iterator is the producer, and the code that iterates over it is the consumer. When the consumer calls <code>.next()</code>, it “suspends” and the producer starts running. When the producer <code>yields</code> a value, the producer suspends and the consumer starts running, taking the value from the result of calling <code>.next()</code>.</p>

<p>Of course, generators need not be implemented exactly as coroutines. For example, a “transpiler” might implement <code>oneTwoThree</code> as a state machine, a little like this (there is more to generators, but we’ll see that later):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">oneTwoThree</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">state</code> <code class="o">=</code> <code class="s1">'newborn'</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">next</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">switch</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">case</code> <code class="s1">'newborn'</code><code class="o">:</code>
          <code class="nx">state</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>
        <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
          <code class="nx">state</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="mi">2</code><code class="p">}</code>
        <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
          <code class="nx">state</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="mi">3</code><code class="p">}</code>
        <code class="k">case</code> <code class="mi">3</code><code class="o">:</code>
          <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>But no matter how JavaScript implements it, our mental model is that a generator function returns an iterator, and that when we call <code>.next()</code>, it runs until it returns, ends, or yields. If it yields, it suspends its own execution and the consuming code resumes execution, until <code>.next()</code> is called again, at which point the iterator resumes its own execution from the point where it yielded.</p>

<h4 id="leanpub-auto-generators-and-iterables">generators and iterables</h4>

<p>Our generator function <code>oneTwoThree</code> is not an iterator. It’s a function that returns an iterator when we invoke it. We write the function to <code>yield</code> values instead of <code>return</code> a single value, and JavaScript takes care of turning this into an object with a <code>.next()</code> function we can call.</p>

<p>If we call our generator function more than once, we get new iterators. As we saw above, we called <code>oneTwoThree</code> three times, and each time we got an iterator that begins at <code>1</code> and counts to <code>3</code>. Recalling the way we wrote ordered collections, we could make a collection that uses a generator function:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">const</code> <code class="nx">ThreeNumbers</code> <code class="o">=</code> <code class="p">{</code>
   <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code> <code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
     <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
     <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
     <code class="k">yield</code> <code class="mi">3</code>
   <code class="p">}</code>
 <code class="p">}</code>

 <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">ThreeNumbers</code><code class="p">)</code> <code class="p">{</code>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
 <code class="p">}</code>
   <code class="c1">//=&gt;</code>
     <code class="mi">1</code>
     <code class="mi">2</code>
     <code class="mi">3</code>

 <code class="p">[...</code><code class="nx">ThreeNumbers</code><code class="p">]</code>
   <code class="c1">//=&gt;</code>
     <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">]</code>

 <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">ThreeNumbers</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

 <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
   <code class="c1">//=&gt;</code>
     <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>

 <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
   <code class="c1">//=&gt;</code>
     <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">2</code><code class="p">}</code>

 <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
   <code class="c1">//=&gt;</code>
     <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">3</code><code class="p">}</code>

 <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>
   <code class="c1">//=&gt;</code>
     <code class="p">{</code><code class="s2">"done"</code><code class="o">:</code><code class="kc">true</code><code class="p">}</code>
</pre></div>

</figure>

<p>Now we can use it in a <code>for...of</code> loop, spread it into an array literal, or spread it into a function invocation, because we have written an iterable that uses a generator to return an iterator from its <code>[Symbol.iterator]</code> method.</p>

<p>This pattern is encouraged, so much so that JavaScript provides a concise syntax for writing generator methods for objects:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="kr">const</code> <code class="nx">ThreeNumbers</code> <code class="o">=</code> <code class="p">{</code>
   <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
     <code class="k">yield</code> <code class="mi">1</code><code class="p">;</code>
     <code class="k">yield</code> <code class="mi">2</code><code class="p">;</code>
     <code class="k">yield</code> <code class="mi">3</code>
   <code class="p">}</code>
 <code class="p">}</code>
</pre></div>

</figure>

<p>This object declares a <code>[Symbol.iterator]</code> function that makes it iterable. Because it’s declared <code>*[Symbol.iterator]</code>, it’s a generator instead of an iterator.</p>

<p>So to summarize, <code>ThreeNumbers</code> is an object that we’ve made iterable, by way of writing a <em>generator</em> method for <code>[Symbol.iterator]</code>.</p>

<h4 id="leanpub-auto-more-generators">more generators</h4>

<p>Generators can produce infinite streams of values:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Numbers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">yield</code> <code class="nx">i</code><code class="o">++</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">Numbers</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
  <code class="mi">6</code>
  <code class="mi">7</code>
  <code class="mi">8</code>
  <code class="mi">9</code>
  <code class="mi">10</code>
  <code class="p">...</code>
</pre></div>

</figure>

<p>Our <code>OneTwoThree</code> example used implicit state to output the numbers in sequence. Recall that we wrote <code>Fibonacci</code> using explicit state:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Fibonacci</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">state</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">switch</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">case</code> <code class="mi">0</code><code class="o">:</code>
            <code class="nx">state</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="nx">a</code><code class="p">};</code>
          <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
            <code class="nx">state</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="nx">b</code><code class="p">};</code>
          <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
            <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">];</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="nx">b</code><code class="p">};</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="k">of</code> <code class="nx">Fibonacci</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">5</code>
  <code class="mi">8</code>
  <code class="mi">13</code>
  <code class="mi">21</code>
  <code class="mi">34</code>
  <code class="mi">55</code>
  <code class="mi">89</code>
  <code class="mi">144</code>
  <code class="p">...</code>
</pre></div>

</figure>

<p>And here is the <code>Fibonacci</code> ordered collection, implemented with a generator method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Fibonacci</code> <code class="o">=</code> <code class="p">{</code>
  <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">;</code>

    <code class="k">yield</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">yield</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
      <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">]</code>
      <code class="k">yield</code> <code class="nx">b</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">Fibonacci</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">5</code>
  <code class="mi">8</code>
  <code class="mi">13</code>
  <code class="mi">21</code>
  <code class="mi">34</code>
  <code class="mi">55</code>
  <code class="mi">89</code>
  <code class="mi">144</code>
  <code class="p">...</code>
</pre></div>

</figure>

<p>We’ve writing a function that returns an iterator, but we used a generator to do it. And the generator’s syntax allows us to use JavaScript’s natural management of state instead of constantly rolling our own.</p>

<p>Of course, we could just as easily write a generator function for Fibonacci numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">fibonacci</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">;</code>

  <code class="k">yield</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

  <code class="k">yield</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">]</code>
    <code class="k">yield</code> <code class="nx">b</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">fibonacci</code><code class="p">())</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">0</code>
  <code class="mi">1</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">5</code>
  <code class="mi">8</code>
  <code class="mi">13</code>
  <code class="mi">21</code>
  <code class="mi">34</code>
  <code class="mi">55</code>
  <code class="mi">89</code>
  <code class="mi">144</code>
  <code class="p">...</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-yielding-iterables">yielding iterables</h4>

<p>Here’s a first crack at a function that returns an iterable object for iterating over trees:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">isIterable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="o">!!</code><code class="nx">something</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">TreeIterable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code> <code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">e</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
          <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">ee</code> <code class="k">of</code> <code class="nx">TreeIterable</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">ee</code><code class="p">;</code>
          <code class="p">}</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
          <code class="k">yield</code> <code class="nx">e</code><code class="p">;</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">})</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">TreeIterable</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">]]))</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
</pre></div>

</figure>

<p>We’ve gone with the full iterable here, a <code>TreeIterable(iterable)</code> returns an iterable that treats <code>iterable</code> as a tree. It works, but as we’ve just seen, a function that returns an iterable can often be written much more simply as a generator, rather than a function that returns an iterable object:<sup id="fnref-but"><a href="https://leanpub.com/javascriptallongesix/read#fn-but" rel="footnote">4</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">tree</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">e</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">ee</code> <code class="k">of</code> <code class="nx">tree</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">ee</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">yield</code> <code class="nx">e</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">tree</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">]]))</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
</pre></div>

</figure>

<p>We take advantage of the <code>for...of</code> loop in a plain and direct way: For each element <code>e</code>, if it is iterable, treat it as a tree and iterate over it, yielding each of its elements. If <code>e</code> is not an iterable, yield <code>e</code>.</p>

<p>JavaScript handles the recursion for us using its own execution stack. This is clearly simpler than trying to maintain our own stack and remembering whether we are shifting and unshifting, or pushing and popping.</p>

<p>But while we’re here, let’s look at one bit of this code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">ee</code> <code class="k">of</code> <code class="nx">tree</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
  <code class="k">yield</code> <code class="nx">ee</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>These three lines say, in essence, “yield all the elements of <code>TreeIterable(e)</code>, in order.” This comes up quite often when we have collections that are compounds, collections made from other collections.</p>

<p>Consider this operation on iterables:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">append</code> <code class="p">(...</code><code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">iterable</code> <code class="k">of</code> <code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">lyrics</code> <code class="o">=</code> <code class="nx">append</code><code class="p">([</code><code class="s2">"a"</code><code class="p">,</code> <code class="s2">"b"</code><code class="p">,</code> <code class="s2">"c"</code><code class="p">],</code> <code class="p">[</code><code class="s2">"one"</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">],</code> <code class="p">[</code><code class="s2">"do"</code><code class="p">,</code> <code class="s2">"re"</code><code class="p">,</code> <code class="s2">"me\</code>
<code class="s2">"</code><code class="p">]);</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">word</code> <code class="k">of</code> <code class="nx">lyrics</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">word</code><code class="p">);</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">a</code>
    <code class="nx">b</code>
    <code class="nx">c</code>
    <code class="nx">one</code>
    <code class="nx">two</code>
    <code class="nx">three</code>
    <code class="k">do</code>
    <code class="nx">re</code>
    <code class="nx">me</code>
</pre></div>

</figure>

<p><code>append</code> iterates over a collection of iterables, one element at a time. Things like arrays can be easily catenated, but <code>append</code> iterates lazily, so there’s no need to construct intermediary results.</p>

<p>Tucked inside of it is the same three-line idiom for yielding each element of an iterable. There is an abbreviation for this, we can use <code>yield *</code> to yield all the elements of an iterable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">append</code> <code class="p">(...</code><code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">iterable</code> <code class="k">of</code> <code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="o">*</code> <code class="nx">iterable</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">lyrics</code> <code class="o">=</code> <code class="nx">append</code><code class="p">([</code><code class="s2">"a"</code><code class="p">,</code> <code class="s2">"b"</code><code class="p">,</code> <code class="s2">"c"</code><code class="p">],</code> <code class="p">[</code><code class="s2">"one"</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">,</code> <code class="s2">"three"</code><code class="p">],</code> <code class="p">[</code><code class="s2">"do"</code><code class="p">,</code> <code class="s2">"re"</code><code class="p">,</code> <code class="s2">"me\</code>
<code class="s2">"</code><code class="p">]);</code>

<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">word</code> <code class="k">of</code> <code class="nx">lyrics</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">word</code><code class="p">);</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">a</code>
    <code class="nx">b</code>
    <code class="nx">c</code>
    <code class="nx">one</code>
    <code class="nx">two</code>
    <code class="nx">three</code>
    <code class="k">do</code>
    <code class="nx">re</code>
    <code class="nx">me</code>
</pre></div>

</figure>

<p><code>yield *</code> yields all of the elements of an iterable, in order. We can use it in <code>tree</code>, too:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">isIterable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="o">!!</code><code class="nx">something</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">];</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">tree</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">e</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isIterable</code><code class="p">(</code><code class="nx">e</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">yield</code> <code class="o">*</code> <code class="nx">tree</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">yield</code> <code class="nx">e</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>


<code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">i</code> <code class="k">of</code> <code class="nx">tree</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">]]))</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">//=&gt;</code>
  <code class="mi">1</code>
  <code class="mi">2</code>
  <code class="mi">3</code>
  <code class="mi">4</code>
  <code class="mi">5</code>
</pre></div>

</figure>

<p><code>yield*</code> is handy when writing generator functions that operate on or create iterables.</p>

<h4 id="leanpub-auto-rewriting-iterable-operations">rewriting iterable operations</h4>

<p>Now that we know about iterables, we can rewrite our iterable operations as generators. Instead of:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

          <code class="k">return</code> <code class="p">({</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">)});</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>We can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">mapWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>No need to explicitly construct an object that has a <code>[Symbol.iterator]</code> method. No need to return an object with a <code>.next()</code> method. No need to fool around with <code>{done}</code> or <code>{value}</code>, just <code>yield</code> values until we’re done.</p>

<p>We can do the same thing with our other operations like <code>filterWith</code> and <code>untilWith</code>. Here’re our iterable methods rewritten as generators:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">filterWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">untilWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">break</code><code class="p">;</code>
    <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>first</code> works directly with iterators and remains unchanged, but  <code>rest</code> can be rewritten as a generator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]().</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">rest</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

  <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
  <code class="k">yield</code> <code class="o">*</code> <code class="nx">iterator</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-summary-6">Summary</h4>

<p>A generator is a function that is defined with <code>function *</code> and uses <code>yield</code> (or <code>yield *</code>) to generate values. Using a generator instead of writing an iterator object that has a <code>.next()</code> method allows us to write code that can be much simpler for cases like recursive iterations or state patterns. And we don’t need to worry about wrapping our values in an object with <code>.done</code> and <code>.value</code> properties.</p>

<p>This is especially useful for making iterables.</p>

<h3 id="leanpub-auto-lazy-and-eager-collections">Lazy and Eager Collections</h3>

<p>The operations on iterables are tremendously valuable, but let’s reiterate why we care: In JavaScript, we build single-responsibility objects, and single-responsibility functions, and we compose these together to build more full-featured objects and algorithms.</p>

<blockquote>
  <p>Composing an iterable with a <code>mapIterable</code> method cleaves the responsibility for knowing how to map from the fiddly bits of how a linked list differs from a stack</p>
</blockquote>

<p>in the older style of object-oriented programming, we built “fat” objects. Each collection knew how to map itself (<code>.map</code>), how to fold itself (<code>.reduce</code>), how to filter itself (<code>.filter</code>) and how to find one element within itself (<code>.find</code>). If we wanted to flatten collections to arrays, we wrote a <code>.toArray</code> method for each type of collection.</p>

<p>Over time, this informal “interface” for collections grows by accretion. Some methods are only added to a few collections, some are added to all. But our objects grow fatter and fatter. We tell ourselves that, well, a collection ought to know how to map itself.</p>

<p>But we end up recreating the same bits of code in each <code>.map</code> method we create, in each <code>.reduce</code> method we create, in each <code>.filter</code> method we create, and in each <code>.find</code> method. Each one has its own variation, but the overall form is identical. That’s a sign that we should work at a higher level of abstraction, and working with iterables is that higher level of abstraction.</p>

<p>This “fat object” style springs from a misunderstanding: When we say a collection should know how to perform a map over itself, we don’t need for the collection to handle every single detail. That would be like saying that when we ask a bank teller for some cash, they personally print every bank note.</p>

<h4 id="leanpub-auto-implementing-methods-with-iteration">implementing methods with iteration</h4>

<p>Object-oriented collections should definitely have methods for mapping, reducing, filtering, and finding. And they should know how to accomplish the desired result, but they should do so by delegating as much of the work as possible to operations like <code>mapWith</code>.</p>

<p>Composing an iterable with a <code>mapIterable</code> method cleaves the responsibility for knowing how to map from the fiddly bits of how a linked list differs from a stack. And if we want to create convenience methods, we can reuse common pieces.</p>

<p>Here is <code>LazyCollection</code>, a mixin we can use with any ordered collection that is also an iterable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">extend</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">consumer</code><code class="p">,</code> <code class="p">...</code><code class="nx">providers</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">providers</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">provider</code> <code class="o">=</code> <code class="nx">providers</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">provider</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">provider</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code> <code class="p">{</code>
        <code class="nx">consumer</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">provider</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">consumer</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">LazyCollection</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">map</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

        <code class="k">return</code> <code class="p">{</code>
          <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="p">{</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
            <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

            <code class="k">return</code> <code class="p">({</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code>
            <code class="p">});</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>
  <code class="p">},</code>

  <code class="nx">reduce</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">seed</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
    <code class="kd">let</code> <code class="nx">iterationResult</code><code class="p">,</code>
    <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">seed</code><code class="p">;</code>

    <code class="k">while</code> <code class="p">((</code><code class="nx">iterationResult</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code> <code class="o">!</code><code class="nx">iterationResult</code><code class="p">.</code><code class="nx">done</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">accumulator</code><code class="p">,</code> <code class="nx">iterationResult</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">accumulator</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">filter</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

        <code class="k">return</code> <code class="p">{</code>
          <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">do</code> <code class="p">{</code>
              <code class="kr">const</code> <code class="p">{</code>
                <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
              <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
            <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">));</code>
            <code class="k">return</code> <code class="p">{</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
            <code class="p">};</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">)</code>
  <code class="p">},</code>

  <code class="nx">find</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

        <code class="k">return</code> <code class="p">{</code>
          <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="p">{</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
            <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

            <code class="nx">done</code> <code class="o">=</code> <code class="nx">done</code> <code class="o">||</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>

            <code class="k">return</code> <code class="p">({</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">value</code>
            <code class="p">});</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">)</code>
  <code class="p">},</code>

  <code class="nx">until</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

        <code class="k">return</code> <code class="p">{</code>
          <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="p">{</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
            <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

            <code class="nx">done</code> <code class="o">=</code> <code class="nx">done</code> <code class="o">||</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>

            <code class="k">return</code> <code class="p">({</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">value</code>
            <code class="p">});</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">)</code>
  <code class="p">},</code>

  <code class="nx">first</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]().</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">rest</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

        <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
        <code class="k">return</code> <code class="nx">iterator</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>
  <code class="p">},</code>

  <code class="nx">take</code><code class="p">(</code><code class="nx">numberToTake</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        <code class="kd">let</code> <code class="nx">remainingElements</code> <code class="o">=</code> <code class="nx">numberToTake</code><code class="p">;</code>

        <code class="k">return</code> <code class="p">{</code>
          <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="p">{</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code>
            <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

            <code class="nx">done</code> <code class="o">=</code> <code class="nx">done</code> <code class="o">||</code> <code class="nx">remainingElements</code><code class="o">--</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">;</code>

            <code class="k">return</code> <code class="p">({</code>
              <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">done</code> <code class="o">?</code> <code class="kc">undefined</code> <code class="o">:</code> <code class="nx">value</code>
            <code class="p">});</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To use <code>LazyCollection</code>, we mix it into an any iterable object. For simplicity, we’ll show how to mix it into <code>Numbers</code> and <code>Pair</code>. But it can also be mixed into prototypes (a/k/a “classes”), traits, or other OO constructs:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Numbers</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    
    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
        <code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code><code class="p">})</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>


<code class="c1">// Pair, a/k/a linked lists</code>

<code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">Pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">car</code><code class="p">,</code> <code class="nx">cdr</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
    <code class="nx">car</code><code class="p">,</code>
    <code class="nx">cdr</code><code class="p">,</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">false</code><code class="p">,</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">currentPair</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
      
      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">currentPair</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">}</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">car</code><code class="p">;</code>
            
            <code class="nx">currentPair</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">cdr</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>

<code class="nx">Pair</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="kd">function</code> <code class="nx">iterationToList</code> <code class="p">(</code><code class="nx">iteration</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iteration</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
    
    <code class="k">return</code> <code class="nx">done</code> <code class="o">?</code> <code class="nx">EMPTY</code> <code class="o">:</code> <code class="nx">Pair</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">iterationToList</code><code class="p">(</code><code class="nx">iteration</code><code class="p">));</code>
  <code class="p">})(</code><code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]());</code>
  
<code class="c1">// Stack</code>

<code class="kr">const</code> <code class="nx">Stack</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">pop</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>
    
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code> 
        <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code> 
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
    <code class="p">},</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>
      
      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">iterationIndex</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">index</code><code class="p">;</code>
          <code class="p">}</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">iterationIndex</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">};</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">iterationIndex</code><code class="o">--</code><code class="p">]}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>
  
<code class="nx">Stack</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="k">this</code><code class="p">();</code>
  
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">stack</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Pair and Stack in action</code>
  
<code class="nx">Stack</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">])</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">first</code><code class="p">()</code>

<code class="c1">//=&gt; 100</code>
  
<code class="nx">Pair</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">])</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">seed</code><code class="p">,</code> <code class="nx">element</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">seed</code> <code class="o">+</code> <code class="nx">element</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
  
<code class="c1">//=&gt; 220</code>
</pre></div>

</figure>

<h4 id="lazy-iterables">lazy collection operations</h4>

<p>“Laziness” is a very pejorative word when applied to people. But it can be an excellent strategy for efficiency in algorithms. Let’s be precise: <em>Laziness</em> is the characteristic of not doing any work until you know you need the result of the work.</p>

<p>Here’s an example. Compare these two:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">]</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">seed</code><code class="p">,</code> <code class="nx">element</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">seed</code> <code class="o">+</code> <code class="nx">element</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
  
<code class="nx">Pair</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">10</code><code class="p">])</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">seed</code><code class="p">,</code> <code class="nx">element</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">seed</code> <code class="o">+</code> <code class="nx">element</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>
</pre></div>

</figure>

<p>Both expressions evaluate to <code>220</code>. And they array is faster in practice, because it is a built-in data type that performs its work in the engine, while the linked list does its work in JavaScript.</p>

<p>But it’s still illustrative to dissect something important: Array’s <code>.map</code> and <code>.filter</code> methods gather their results into new arrays. Thus, calling <code>.map.filter.reduce</code> produces two temporary arrays that are discarded when <code>.reduce</code> performs its final computation.</p>

<p>Whereas the <code>.map</code> and <code>.filter</code> methods on <code>Pair</code> work with iterators. They produce small iterable objects that refer back to the original iteration. This reduces the memory footprint. When working with very large collections and many operations, this can be important.</p>

<p>The effect is even more pronounced when we use methods like <code>first</code>, <code>until</code>, or <code>take</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Stack</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code>
            <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code>
            <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">28</code><code class="p">,</code> <code class="mi">29</code><code class="p">])</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">first</code><code class="p">()</code>
</pre></div>

</figure>

<p>This expression begins with a stack containing 30 elements. The top two are <code>29</code> and <code>28</code>. It maps to the squares of all 30 numbers, but our code for mapping an iteration returns an iterable that can iterate over the squares of our numbers, not an array or stack of the squares. Same with <code>.filter</code>, we get an iterable that can iterate over the even squares, but not an actual stack or array.</p>

<p>Finally, we take the first element of that filtered, squared iterable and now JavaScript actually iterates over the stack’s elements, and it only needs to square two of those elements, <code>29</code> and <code>28</code>, to return the answer.</p>

<p>We can confirm this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Stack</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code>
            <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code>
            <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">28</code><code class="p">,</code> <code class="mi">29</code><code class="p">])</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`squaring </code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code>
  <code class="p">})</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`filtering </code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code>
  <code class="p">})</code>
  <code class="p">.</code><code class="nx">first</code><code class="p">()</code>

<code class="c1">//=&gt;</code>
  <code class="nx">squaring</code> <code class="mi">29</code>
  <code class="nx">filtering</code> <code class="mi">841</code>
  <code class="nx">squaring</code> <code class="mi">28</code>
  <code class="nx">filtering</code> <code class="mi">784</code>
  <code class="mi">784</code>
</pre></div>

</figure>

<p>If we write the almost identical thing with an array, we get a different behaviour:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code> <code class="mi">0</code><code class="p">,</code>  <code class="mi">1</code><code class="p">,</code>  <code class="mi">2</code><code class="p">,</code>  <code class="mi">3</code><code class="p">,</code>  <code class="mi">4</code><code class="p">,</code>  <code class="mi">5</code><code class="p">,</code>  <code class="mi">6</code><code class="p">,</code>  <code class="mi">7</code><code class="p">,</code>  <code class="mi">8</code><code class="p">,</code>  <code class="mi">9</code><code class="p">,</code>
 <code class="mi">10</code><code class="p">,</code> <code class="mi">11</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">13</code><code class="p">,</code> <code class="mi">14</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">17</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">19</code><code class="p">,</code>
 <code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">,</code> <code class="mi">22</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">25</code><code class="p">,</code> <code class="mi">26</code><code class="p">,</code> <code class="mi">27</code><code class="p">,</code> <code class="mi">28</code><code class="p">,</code> <code class="mi">29</code><code class="p">]</code>
  <code class="p">.</code><code class="nx">reverse</code><code class="p">()</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`squaring </code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code>
  <code class="p">})</code>
  <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`filtering </code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code>
  <code class="p">})[</code><code class="mi">0</code><code class="p">]</code>

<code class="c1">//=&gt;</code>
  <code class="nx">squaring</code> <code class="mi">0</code>
  <code class="nx">squaring</code> <code class="mi">1</code>
  <code class="nx">squaring</code> <code class="mi">2</code>
  <code class="nx">squaring</code> <code class="mi">3</code>
  <code class="p">...</code>
  <code class="nx">squaring</code> <code class="mi">28</code>
  <code class="nx">squaring</code> <code class="mi">29</code>
  <code class="nx">filtering</code> <code class="mi">0</code>
  <code class="nx">filtering</code> <code class="mi">1</code>
  <code class="nx">filtering</code> <code class="mi">4</code>
  <code class="p">...</code>
  <code class="nx">filtering</code> <code class="mi">784</code>
  <code class="nx">filtering</code> <code class="mi">841</code>
  <code class="mi">784</code>
</pre></div>

</figure>

<p>Arrays copy-on-read, so every time we perform a map or filter, we get a new array and perform all the computations. This might be expensive.</p>

<p>You recall we briefly touched on the idea of infinite collections? Let’s make iterable numbers. They <em>have</em> to be lazy, otherwise we couldn’t write things like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Numbers</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    
    <code class="k">return</code> <code class="p">{</code>
      <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code>
        <code class="p">({</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">n</code><code class="o">++</code><code class="p">})</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">LazyCollection</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">firstCubeOver1234</code> <code class="o">=</code>
  <code class="nx">Numbers</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">1234</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">first</code><code class="p">()</code>

<code class="c1">//=&gt; 1331</code>
</pre></div>

</figure>

<p>Balanced against their flexibility, our “lazy collections” use structure sharing. If we mutate a collection after taking an iterable, we might get an unexpected result. This is why “pure” functional languages like Haskell combine lazy semantics with immutable collections, and why even “impure” languages like Clojure emphasize the use of immutable collections.</p>

<h4 id="leanpub-auto-eager-collections">eager collections</h4>

<p>An <em>eager</em> collection, like an array, returns a collection of its own type from each of the methods. We can make an eager collection out of any collection that is <em>gatherable</em>, meaning it has a <code>.from</code> method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">extend</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">consumer</code><code class="p">,</code> <code class="p">...</code><code class="nx">providers</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">providers</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">provider</code> <code class="o">=</code> <code class="nx">providers</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">in</code> <code class="nx">provider</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">provider</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code> <code class="p">{</code>
        <code class="nx">consumer</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">provider</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">consumer</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">EagerCollection</code> <code class="o">=</code> <code class="p">(</code><code class="nx">gatherable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">map</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code>  <code class="nx">original</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
      
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
        <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">original</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
          <code class="p">}</code>
        <code class="p">})()</code>
      <code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">reduce</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">seed</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">seed</code><code class="p">;</code>

      <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">accumulator</code><code class="p">,</code> <code class="nx">element</code><code class="p">);</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">accumulator</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="nx">filter</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
    
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
        <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">original</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
          <code class="p">}</code>
        <code class="p">})()</code>
      <code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">find</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">return</code> <code class="nx">element</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">},</code>

    <code class="nx">until</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
    
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
        <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">original</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">break</code><code class="p">;</code>
            <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
          <code class="p">}</code>
        <code class="p">})()</code>
      <code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">first</code><code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]().</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="nx">rest</code><code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">iteration</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
      
      <code class="nx">iteration</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
        <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">yield</code> <code class="o">*</code> <code class="nx">iteration</code><code class="p">;</code>
        <code class="p">})()</code>
      <code class="p">);</code>
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">iterable</code><code class="p">);</code>
    <code class="p">},</code>

    <code class="nx">take</code><code class="p">(</code><code class="nx">numberToTake</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
      <code class="kd">let</code> <code class="nx">numberRemaining</code> <code class="o">=</code> <code class="nx">numberToTake</code><code class="p">;</code>
    
      <code class="k">return</code> <code class="nx">gatherable</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
        <code class="p">(</code><code class="kd">function</code><code class="o">*</code> <code class="p">()</code> <code class="p">{</code>
          <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">original</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">numberRemaining</code><code class="o">--</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>
            <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
          <code class="p">}</code>
        <code class="p">})()</code>
      <code class="p">);</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>Here is our <code>Pair</code> implementation. <code>Pair</code> is gatherable, because it implements <code>.from()</code>. We mix <code>EagerCollection(Pair)</code> into it, and this gives it all of our collection methods, which each method returning a new list of pairs:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">EMPTY</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">true</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">isEmpty</code> <code class="o">=</code> <code class="p">(</code><code class="nx">node</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">node</code> <code class="o">===</code> <code class="nx">EMPTY</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">Pair</code> <code class="o">=</code> <code class="p">(</code><code class="nx">car</code><code class="p">,</code> <code class="nx">cdr</code> <code class="o">=</code> <code class="nx">EMPTY</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
    <code class="nx">car</code><code class="p">,</code>
    <code class="nx">cdr</code><code class="p">,</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kc">false</code><code class="p">,</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">currentPair</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
      
      <code class="k">return</code> <code class="p">{</code>
        <code class="nx">next</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
          <code class="k">if</code> <code class="p">(</code><code class="nx">currentPair</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">true</code><code class="p">}</code>
          <code class="p">}</code>
          <code class="k">else</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">car</code><code class="p">;</code>
            
            <code class="nx">currentPair</code> <code class="o">=</code> <code class="nx">currentPair</code><code class="p">.</code><code class="nx">cdr</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code><code class="nx">done</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code>
          <code class="p">}</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">},</code> <code class="nx">EagerCollection</code><code class="p">(</code><code class="nx">Pair</code><code class="p">));</code>

<code class="nx">Pair</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="kd">function</code> <code class="nx">iterationToList</code> <code class="p">(</code><code class="nx">iteration</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code><code class="nx">done</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iteration</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
    
    <code class="k">return</code> <code class="nx">done</code> <code class="o">?</code> <code class="nx">EMPTY</code> <code class="o">:</code> <code class="nx">Pair</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">iterationToList</code><code class="p">(</code><code class="nx">iteration</code><code class="p">));</code>
  <code class="p">})(</code><code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]());</code>
  
<code class="nx">Pair</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]).</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">)</code>
  <code class="c1">//=&gt; </code>
    <code class="p">{</code><code class="s2">"car"</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
     <code class="s2">"cdr"</code><code class="o">:</code> <code class="p">{</code><code class="s2">"car"</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
             <code class="s2">"cdr"</code><code class="o">:</code> <code class="p">{</code><code class="s2">"car"</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code>
                     <code class="s2">"cdr"</code><code class="o">:</code> <code class="p">{</code><code class="s2">"car"</code><code class="o">:</code> <code class="mi">8</code><code class="p">,</code>
                             <code class="s2">"cdr"</code><code class="o">:</code> <code class="p">{</code><code class="s2">"car"</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>
                                     <code class="s2">"cdr"</code><code class="o">:</code> <code class="p">{}</code>
                                    <code class="p">}</code>
                            <code class="p">}</code>
                    <code class="p">}</code>
            <code class="p">}</code>
    <code class="p">}</code>
</pre></div>

</figure>

<h3 id="drunken">Interlude: The Carpenter Interviews for a Job</h3>

<p>“The Carpenter” was a JavaScript programmer, well-known for a meticulous attention to detail and love for hand-crafted, exquisitely joined code. The Carpenter normally worked through personal referrals, but from time to time a recruiter would slip through his screen. One such recruiter was Bob Plissken. Bob was well-known in the Python community, but his clients often needed experience with other languages.</p>

<p>Plissken lined up a technical interview with a well-funded startup in San Francisco. The Carpenter arrived early for his meeting with “Thing Software,” and was shown to conference room 13. A few minutes later, he was joined by one of the company’s developers, Christine.</p>

<h4 id="leanpub-auto-the-problem">the problem</h4>

<p>After some small talk, Christine explained that they liked to ask candidates to whiteboard some code. Despite his experience and industry longevity, the Carpenter did not mind being asked to demonstrate that he was, in fact, the person described on the resumé.</p>

<p>Many companies use white-boarding code as an excuse to have a technical conversation with a candidate, and The Carpenter felt that being asked to whiteboard code was an excuse to have a technical conversation with a future colleague. “Win, win” he thought to himself.</p>

<p><a href="https://www.flickr.com/photos/stigrudeholm/6710684795"><img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/chessboard.jpg" alt="Chessboard"></a></p>

<p>Christine intoned the question, as if by rote:</p>

<blockquote>
  <p>Consider a finite checkerboard of unknown size. On each square, we randomly place an arrow pointing to one of its four sides. A chequer is placed randomly on the checkerboard. Each move consists of moving the chequer one square in the direction of the arrow in the square it occupies. If the arrow should cause the chequer to move off the edge of the board, the game halts.</p>
</blockquote>

<blockquote>
  <p>The problem is this: The game board is hidden from us. A player moves the chequer, following the rules. As the player moves the chequer, they calls out the direction of movement, e.g. “↑, →, ↑, ↓, ↑, →…” Write an algorithm that will determine whether the game halts, strictly from the called out directions, in finite time and space.</p>
</blockquote>

<p>“So,” The Carpenter asked, “I am to write an algorithm that takes a possibly infinite stream of…”</p>

<p>Christine interrupted. “To save time, we have written a template of the solution for you in ECMASCript 2015 notation. Fill in the blanks. Your code should not presume anything about the game-board’s size or contents, only that it is given an arrow every time though the while loop. You may use <a href="http://babeljs.io/">babeljs.io</a>, or <a href="http://www.es6fiddle.net/">ES6Fiddle</a> to check your work. “</p>

<p>Christine quickly scribbled on the whiteboard:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Game</code> <code class="o">=</code> <code class="p">(</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">8</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="c1">// initialize the board</code>
  <code class="kr">const</code> <code class="nx">board</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">board</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">;</code> <code class="o">++</code><code class="nx">j</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">board</code><code class="p">[</code><code class="nx">i</code><code class="p">][</code><code class="nx">j</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'←→↓↑'</code><code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">4</code><code class="p">)];</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c1">// initialize the position</code>
  <code class="kd">let</code> <code class="nx">initialPosition</code> <code class="o">=</code> <code class="p">[</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="p">(</code><code class="nx">size</code> <code class="o">-</code> <code class="mi">4</code><code class="p">)),</code>
    <code class="mi">2</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="p">(</code><code class="nx">size</code> <code class="o">-</code> <code class="mi">4</code><code class="p">))</code>
  <code class="p">];</code>

  <code class="c1">// ???</code>
  <code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">initialPosition</code><code class="p">;</code>

  <code class="kr">const</code> <code class="nx">MOVE</code> <code class="o">=</code> <code class="p">{</code>
    <code class="s2">"←"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="p">],</code>
    <code class="s2">"→"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="p">],</code>
    <code class="s2">"↓"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="o">-</code> <code class="mi">1</code><code class="p">],</code>
    <code class="s2">"↑"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="o">+</code> <code class="mi">1</code><code class="p">]</code>
  <code class="p">};</code>
  <code class="k">while</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">&gt;=</code><code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">size</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">arrow</code> <code class="o">=</code> <code class="nx">board</code><code class="p">[</code><code class="nx">x</code><code class="p">][</code><code class="nx">y</code><code class="p">];</code>

    <code class="c1">// ???</code>

    <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">MOVE</code><code class="p">[</code><code class="nx">arrow</code><code class="p">]([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]);</code>
  <code class="p">}</code>
  <code class="c1">// ???</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>“What,” Christine asked, “Do you write in place of the three <code>// ???</code> placeholders to determine whether the game halts?”</p>

<h4 id="leanpub-auto-the-carpenters-solution">the carpenter’s solution</h4>

<p>The Carpenter was not surprised at the problem. Bob Plissken was a crafty, almost reptilian recruiter that traded in information and secrets. Whenever Bob sent a candidate to a job interview, he debriefed them afterwards and got them to disclose what questions were asked in the interview. He then coached subsequent candidates to give polished answers to the company’s pet technical questions.</p>

<p>And just as companies often pick a problem that gives them broad latitude for discussing alternate approaches and determining that depth of a candidate’s experience, The Carpenter liked to sketch out solutions that provided an opportunity to judge the interviewer’s experience and provide an easy excuse to discuss the company’s approach to software design.</p>

<p>Bob had, in fact, warned The Carpenter that “Thing” liked to ask either or both of two questions: Determine how to detect a loop in a linked list, and determine whether the chequerboard game would halt. To save time, The Carpenter had prepared the same answer for both questions.</p>

<p>The Carpenter coughed softly, then began. “To begin with, I’ll transform a game into an iterable that generates arrows, using the ‘Starman’ notation for generators. I’ll refactor a touch to make things clearer, for example I’ll extract the board to make it easier to test:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">MOVE</code> <code class="o">=</code> <code class="p">{</code>
  <code class="s2">"←"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="p">],</code>
  <code class="s2">"→"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="p">],</code>
  <code class="s2">"↓"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="o">+</code> <code class="mi">1</code><code class="p">],</code>
  <code class="s2">"↑"</code><code class="o">:</code> <code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="o">-</code> <code class="mi">1</code><code class="p">]</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Board</code> <code class="o">=</code> <code class="p">(</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">8</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="c1">// initialize the board</code>
  <code class="kr">const</code> <code class="nx">board</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">board</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">;</code> <code class="o">++</code><code class="nx">j</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">board</code><code class="p">[</code><code class="nx">i</code><code class="p">][</code><code class="nx">j</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'←→↓↑'</code><code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="mi">4</code><code class="p">)];</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c1">// initialize the position</code>
  <code class="kr">const</code> <code class="nx">position</code> <code class="o">=</code> <code class="p">[</code>
    <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">size</code><code class="p">),</code>
    <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">size</code><code class="p">)</code>
  <code class="p">];</code>

  <code class="k">return</code> <code class="p">{</code><code class="nx">board</code><code class="p">,</code> <code class="nx">position</code><code class="p">};</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Game</code> <code class="o">=</code> <code class="p">({</code><code class="nx">board</code><code class="p">,</code> <code class="nx">position</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="kr">const</code> <code class="nx">size</code> <code class="o">=</code> <code class="nx">board</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">length</code><code class="p">;</code>

  <code class="k">return</code> <code class="p">({</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">position</code><code class="p">;</code>

      <code class="k">while</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">&gt;=</code><code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">size</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">size</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">direction</code> <code class="o">=</code> <code class="nx">board</code><code class="p">[</code><code class="nx">y</code><code class="p">][</code><code class="nx">x</code><code class="p">];</code>

        <code class="k">yield</code> <code class="nx">direction</code><code class="p">;</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">MOVE</code><code class="p">[</code><code class="nx">direction</code><code class="p">]([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]);</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>“Now that we have an iterable, we can transform the iterable of arrows into an iterable of positions.” The Carpenter sketched quickly. “We want to take the arrows and convert them to positions. For that, we’ll map the Game iterable to positions. A <code>statefulMap</code> is a lazy map that preserves state from iteration to iteration. That’s what we need, because we need to know the current position to map each move to the next position.”</p>

<p>“This is a standard idiom we can obtain from libraries, we don’t reinvent the wheel. I’ll show it here for clarity:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">statefulMapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">seed</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code><code class="p">,</code>
          <code class="nx">state</code> <code class="o">=</code> <code class="nx">seed</code><code class="p">;</code>

      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
        <code class="p">[</code><code class="nx">state</code><code class="p">,</code> <code class="nx">value</code><code class="p">]</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">element</code><code class="p">);</code>
        <code class="k">yield</code> <code class="nx">value</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p>“Armed with this, it’s straightforward to map an iterable of directions to an iterable of strings representing positions:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">positionsOf</code> <code class="o">=</code> <code class="p">(</code><code class="nx">game</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">statefulMapWith</code><code class="p">(</code>
    <code class="p">(</code><code class="nx">position</code><code class="p">,</code> <code class="nx">direction</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">]</code> <code class="o">=</code>  <code class="nx">MOVE</code><code class="p">[</code><code class="nx">direction</code><code class="p">](</code><code class="nx">position</code><code class="p">);</code>
      <code class="nx">position</code> <code class="o">=</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">];</code>
      <code class="k">return</code> <code class="p">[</code><code class="nx">position</code><code class="p">,</code> <code class="sb">`x: </code><code class="si">${</code><code class="nx">x</code><code class="si">}</code><code class="sb">, y: </code><code class="si">${</code><code class="nx">y</code><code class="si">}</code><code class="sb">`</code><code class="p">];</code>
    <code class="p">},</code>
    <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code>
    <code class="nx">game</code><code class="p">);</code>
</pre></div>

</figure>

<p>The Carpenter reflected. “Having turned our game loop into an iterable, we can now see that our problem of whether the game terminates is isomorphic to the problem of detecting whether the positions given ever repeat themselves: If the chequer ever returns to a position it has previously visited, it will cycle endlessly.”</p>

<p>“We could draw positions as nodes in a graph, connected by arcs representing the arrows. Detecting whether the game terminates is equivalent to detecting whether the graph contains a cycle.”</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/tortoise-hare.jpg" alt="The Tortoise and the Hare">
  <figcaption>The Tortoise and the Hare</figcaption>
</figure>


<p>“There’s an old joke that a mathematician is someone who will take a five-minute problem, then spend an hour proving it is equivalent to another problem they have already solved. I approached this question in that spirit. Now that we have created an iterable of values that can be compared with <code>===</code>, I can show you this function:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">tortoiseAndHare</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">hare</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
  <code class="kd">let</code> <code class="nx">hareResult</code> <code class="o">=</code> <code class="p">(</code><code class="nx">hare</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code> <code class="nx">hare</code><code class="p">.</code><code class="nx">next</code><code class="p">());</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">tortoiseValue</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>

    <code class="nx">hareResult</code> <code class="o">=</code> <code class="nx">hare</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">hareResult</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">tortoiseValue</code> <code class="o">===</code> <code class="nx">hareResult</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">hareResult</code> <code class="o">=</code> <code class="nx">hare</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">hareResult</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">tortoiseValue</code> <code class="o">===</code> <code class="nx">hareResult</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>“A long time ago,” The Carpenter explained, “Someone asked me a question in an interview. I have never forgotten the question, or the general form of the solution. The question was, <em>Given a linked list, detect whether it contains a cycle. Use constant space.</em>”</p>

<p>“This is, of course, the most common solution, it is <a href="https://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare">Floyd’s cycle-finding algorithm</a>, although there is some academic dispute as to whether Robert Floyd actually discovered it or was misattributed by Knuth.”</p>

<p>“Thus, the solution to the game problem is:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">terminates</code> <code class="o">=</code> <code class="p">(</code><code class="nx">game</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">tortoiseAndHare</code><code class="p">(</code><code class="nx">positionsOf</code><code class="p">(</code><code class="nx">game</code><code class="p">))</code>

<code class="kr">const</code> <code class="nx">test</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">[</code><code class="s2">"↓"</code><code class="p">,</code><code class="s2">"←"</code><code class="p">,</code><code class="s2">"↑"</code><code class="p">,</code><code class="s2">"→"</code><code class="p">],</code>
  <code class="p">[</code><code class="s2">"↓"</code><code class="p">,</code><code class="s2">"→"</code><code class="p">,</code><code class="s2">"↓"</code><code class="p">,</code><code class="s2">"↓"</code><code class="p">],</code>
  <code class="p">[</code><code class="s2">"↓"</code><code class="p">,</code><code class="s2">"→"</code><code class="p">,</code><code class="s2">"→"</code><code class="p">,</code><code class="s2">"←"</code><code class="p">],</code>
  <code class="p">[</code><code class="s2">"↑"</code><code class="p">,</code><code class="s2">"→"</code><code class="p">,</code><code class="s2">"←"</code><code class="p">,</code><code class="s2">"↑"</code><code class="p">]</code>
<code class="p">];</code>

<code class="nx">terminates</code><code class="p">(</code><code class="nx">Game</code><code class="p">({</code><code class="nx">board</code><code class="o">:</code> <code class="nx">test</code><code class="p">,</code> <code class="nx">position</code><code class="o">:</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]}))</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">terminates</code><code class="p">(</code><code class="nx">Game</code><code class="p">({</code><code class="nx">board</code><code class="o">:</code> <code class="nx">test</code><code class="p">,</code> <code class="nx">position</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">0</code><code class="p">]}))</code>
  <code class="c1">//=&gt; true</code>
<code class="nx">terminates</code><code class="p">(</code><code class="nx">Game</code><code class="p">({</code><code class="nx">board</code><code class="o">:</code> <code class="nx">test</code><code class="p">,</code> <code class="nx">position</code><code class="o">:</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">3</code><code class="p">]}))</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">terminates</code><code class="p">(</code><code class="nx">Game</code><code class="p">({</code><code class="nx">board</code><code class="o">:</code> <code class="nx">test</code><code class="p">,</code> <code class="nx">position</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">]}))</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>“This solution makes use of iterables and a single utility function, <code>statefulMapWith</code>. It also cleanly separates the mechanics of the game from the algorithm for detecting cycles in a graph.”</p>

<h4 id="leanpub-auto-the-aftermath">the aftermath</h4>

<p>The Carpenter sat down and waited. This type of solution provided an excellent opportunity to explore lazy versus eager evaluation, the performance of iterators versus native iteration, single responsibility design, and many other rich topics.</p>

<p>The Carpenter was confident that although nobody would write this exact code in production, prospective employers would also recognize that nobody would try to detect whether a chequer game terminates in production, either. It’s all just a pretext for kicking off an interesting conversation, right?</p>

<p>Christine looked at the solution on the board, frowned, and glanced at the clock on the wall. “<em>Well, where has the time gone?</em>”</p>

<p>“We at the Thing Software company are very grateful you made some time to visit with us, but alas, that is all the time we have today. If we wish to talk to you further, we’ll be in touch.”</p>

<p>The Carpenter never did hear back from them, but the next day there was an email containing a generous contract from Friends of Ghosts (“FOG”), a codename for a stealth startup doing interesting work, and the Thing interview was forgotten.</p>

<p>Some time later, The Carpenter ran into Bob Plissken at a local technology meet-up. “John! What happened at Thing?” Bob wanted to know, “I asked them what they thought of you, and all they would say was, <em>Writes unreadable code</em>. I thought it was a lock! I thought you’d finally make your escape from New York.”</p>

<p>The Carpenter smiled. “I forgot about them, it’s been a while. So, do They Live?”</p>

<p><a href="https://www.flickr.com/photos/jlhopgood/6795353385"><img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/time.jpg" alt="Time"></a></p>

<h4 id="leanpub-auto-after-another-drink">after another drink</h4>

<p>A few drinks later, The Carpenter was telling his Thing story and an engineer named Kidu introduced themself.</p>

<p>“I worked at Thing, and Christine told us about your solution. I had a look at the code you left on the whiteboard. Of course, white-boarding in an interview situation is notoriously unreliable, so small defects are not important. But I couldn’t help but notice that your solution doesn’t actually meet the stated requirements for a different reason:”</p>

<p>“The <code>hasCycle</code> function, a/k/a Tortoise and Hare, requires two separate iterators to do its job. Whereas the problem as stated involves a single stream of directions. You’re essentially calling for the player to clone themselves and call out the directions in parallel.”</p>

<p>The Carpenter thought about this for a moment. “Kidu, you’re right, that’s a fantastic observation. I should have used a Teleporting Tortoise!”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="c1">// implements Teleporting Tortoise</code>
<code class="c1">// cycle detection algorithm.</code>
<code class="kr">const</code> <code class="nx">hasCycle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">](),</code>
      <code class="nx">teleportDistance</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="p">{</code><code class="nx">value</code><code class="p">,</code> <code class="nx">done</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code>
        <code class="nx">tortoise</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>

    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">teleportDistance</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="p">{</code><code class="nx">value</code><code class="p">,</code> <code class="nx">done</code><code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">(),</code>
          <code class="nx">hare</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>

      <code class="k">if</code> <code class="p">(</code><code class="nx">tortoise</code> <code class="o">===</code> <code class="nx">hare</code><code class="p">)</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">teleportDistance</code> <code class="o">*=</code> <code class="mi">2</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Kidu shrugged. “You know, the requirement asked for a finite space algorithm, not a constant state algorithm. Doesn’t it make sense to go with a faster finite space algorithm? There’s no benefit to constant space if finite space is sufficient.”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">hasCycle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">orderedCollection</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">visited</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">();</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">orderedCollection</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">visited</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">visited</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>The Carpenter stared at Kidu’s solution. “I guess,” he allowed, “It isn’t always necessary to make a solution so awesome it would please the Ghosts of Mars.”</p>

<h3 id="interactive-generators">Interactive Generators</h3>

<p>We used generators to build iterators that maintain implicit state. We saw how to use them for recursive unfolds and state machines. But there are other times we want to build functions that maintain implicit state. Let’s start by looking at a very simple example of a function that can be written statefully.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/coffee-chess.jpg" alt="Coffee and Chess">
  <figcaption>Coffee and Chess</figcaption>
</figure>


<p>Consider, for example, the moves in a game. The moves a player makes are a stream of values, just like the contents of an array can be consider a stream of values. But of course, iterating over a stream of moves requires us to wait for the game to be over so we know what moves were made.</p>

<p>Let’s take a look at a very simple example, <a href="https://en.wikipedia.org/wiki/naughts-and-crosses">naughts and crosses</a> (We really ought to do something like Chess, but that might be a little out of scope for this chapter). To save space, we’ll ignore rotations and reflections, and we’ll model the first player’s moves as a stream.</p>

<p>The first player will always be <code>o</code>, and they will always place their chequer in the top-left corner, coincidentally numbered <code>o</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>   
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>
</pre></div>

</figure>

<p>The second player has five possible moves if we ignore reflections:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> 
<code class="o">---+---+---</code>
   <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code>
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code> <code class="mi">8</code>
</pre></div>

</figure>

<p>Let’s consider move <code>1</code>. That produces this board:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>
</pre></div>

</figure>

<p>We will always play into position <code>6</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p><code>x</code> has six possible moves, but they are really just two choices: <code>3</code> and anything else:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code> <code class="mi">2</code> 
<code class="o">---+---+---</code>
 <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code>
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code> <code class="mi">7</code> <code class="o">|</code> <code class="mi">8</code>
</pre></div>

</figure>

<p>For <code>2</code>, <code>4</code>, <code>5</code>, <code>7</code>, or <code>8</code>, we play <code>3</code> and win. But if <code>x</code> moves <code>3</code>, we play <code>8</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code> <code class="nx">o</code>
</pre></div>

</figure>

<p><code>x</code> now has three significant moves: <code>4</code>, <code>7</code>, and anything else:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code> <code class="mi">2</code> 
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code>
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code> <code class="mi">7</code> <code class="o">|</code> <code class="mi">8</code>
</pre></div>

</figure>

<p>If <code>x</code> plays <code>4</code>, we play <code>7</code> and win. If <code>x</code> plays anything else, including <code>7</code>, we play <code>4</code> and win.</p>

<h4 id="leanpub-auto-representing-naughts-and-crosses-as-a-stateless-function">representing naughts and crosses as a stateless function</h4>

<p>We could plays naughts and crosses as a stateless function. We encode each position of the board in some fashion, and then we build a dictionary from positions to moves.  For example, the entry for:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p>Would be <code>8</code>, producing:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code> <code class="nx">o</code>
</pre></div>

</figure>

<p>And the entry for:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
   <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p>Would be <code>3</code>, producing:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p>We can encode the board in several different ways. We could use multiline strings with formatting just as we’ve written it here, but it is a design smell to couple presentation with modelling. Our function should be just as useful on a teletype as it would be backing a DOM game that uses a table, or a browser game that draws on Canvas.</p>

<p>Let’s use an array. So this:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
   <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p>Will be represented as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
<code class="p">]</code>
</pre></div>

</figure>

<p>And this:</p>

<figure class="code">
<div class="highlight"><pre><code></code> <code class="nx">o</code> <code class="o">|</code> <code class="nx">x</code> <code class="o">|</code>   
<code class="o">---+---+---</code>
 <code class="nx">x</code> <code class="o">|</code>   <code class="o">|</code>  
<code class="o">---+---+---</code>
 <code class="nx">o</code> <code class="o">|</code>   <code class="o">|</code>  
</pre></div>

</figure>

<p>Will be represented as:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
<code class="p">]</code>
</pre></div>

</figure>

<p>We can use a POJO to make a map from positions to moves. We’ll use the <code>[]</code> notation for keys, it allows us to use any expression as a key, and JavaScript will convert it to a string. So if we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">moveLookupTable</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[[</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">8</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
  <code class="p">[[</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">'o'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">'x'</code>
  <code class="p">]]</code><code class="o">:</code> <code class="mi">3</code>
  
  <code class="c1">// ...</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>We get:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{</code>
  <code class="s2">"o,x, , , , , , , "</code><code class="o">:</code><code class="mi">6</code><code class="p">,</code>
  <code class="s2">"o,x,x, , , ,o, , "</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code>
  <code class="s2">"o,x, ,x, , ,o, , "</code><code class="o">:</code><code class="mi">8</code><code class="p">,</code>
  <code class="s2">"o,x, , ,x, ,o, , "</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code>
  <code class="s2">"o,x, , , ,x,o, , "</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code>
  <code class="s2">"o,x, , , , ,o,x, "</code><code class="o">:</code><code class="mi">3</code><code class="p">,</code>
  <code class="s2">"o,x, , , , ,o, ,x"</code><code class="o">:</code><code class="mi">3</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And if we want to look up what move to make, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">moveLookupTable</code><code class="p">[[</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code>
<code class="p">]]</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>And from there, a stateless function to play naughts-and-crosses is trivial:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">statelessNaughtsAndCrosses</code><code class="p">([</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
  <code class="s1">'o'</code><code class="p">,</code> <code class="s1">'x'</code><code class="p">,</code> <code class="s1">' '</code>
<code class="p">])</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-representing-naughts-and-crosses-as-a-stateful-function">representing naughts and crosses as a stateful function</h4>

<p>Our <code>statelessNaughtsAndCrosses</code> function pushes the work of tracking the game’s state onto us, the player. What if we want to exchange moves with the function? In that case, we need a stateful function. Our “API” will work like this: When we want a new game, we’ll call a function that will return a game function, We’ll call the game function repeatedly, passing our moves, and get the opponent’s moves from it.</p>

<p>Something like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">aNaughtsAndCrossesGame</code> <code class="o">=</code> <code class="nx">statefulNaughtsAndCrosses</code><code class="p">();</code>

<code class="c1">// our opponent makes the first move</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">()</code>
  <code class="c1">//=&gt; 0</code>
  
<code class="c1">// then we move, and get its next move back</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>
  
<code class="c1">// then we move, and get its next move back</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>We can build this out of our <code>statelessNaughtsAndCrosses</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">statefulNaughtsAndCrosses</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">[</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code>
    <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="s1">' '</code>
  <code class="p">];</code>
  
  <code class="k">return</code> <code class="p">(</code><code class="nx">x</code> <code class="o">=</code> <code class="kc">false</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">[</code><code class="nx">x</code><code class="p">]</code> <code class="o">===</code> <code class="s1">' '</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">state</code><code class="p">[</code><code class="nx">x</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'x'</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">throw</code> <code class="s2">"occupied!"</code>
    <code class="p">}</code>
    <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="nx">moveLookupTable</code><code class="p">[</code><code class="nx">state</code><code class="p">];</code>
    <code class="nx">state</code><code class="p">[</code><code class="nx">o</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'o'</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">o</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">aNaughtsAndCrossesGame</code> <code class="o">=</code> <code class="nx">statefulNaughtsAndCrosses</code><code class="p">();</code>

<code class="c1">// our opponent makes the first move</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">()</code>
  <code class="c1">//=&gt; 0</code>
  
<code class="c1">// then we move, and get its next move back</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 6</code>
  
<code class="c1">// then we move, and get its next move back</code>
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>
  <code class="c1">//=&gt; 3</code>
</pre></div>

</figure>

<p>Let’s recap what we have: We have a stateful function, but we built it by wrapping a stateless function in a function that updates state based on the moves we provide. The state is encoded entirely in data.</p>

<h4 id="leanpub-auto-this-seems-familiar">this seems familiar</h4>

<p>When we looked at <a href="https://leanpub.com/javascriptallongesix/read#generating-iterables">generators</a>, we saw that some iterators are inherently stateful, but sometimes it is awkward to represent them in a fully stateless fashion. Sometimes there is a state machine that is naturally represented implicitly in JavaScript’s control flow rather than explicitly in data.</p>

<p>We’ve done almost the exact same thing here with our naughts and crosses game. A game like this is absolutely a state machine, and we’ve explicitly coded those states into the lookup table. Which leads us to wonder: Is there a way to encode those states <em>implicitly</em>, in JavaScript control flow?</p>

<p>If we were in full control of the interaction, it would be easy to encode the game play as a decision tree instead of as a lookup table. For example, we could do this in a browser:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">browserNaughtsAndCrosses</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">x1</code> <code class="o">=</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">prompt</code><code class="p">(</code><code class="s1">'o plays 0, where does x play?'</code><code class="p">));</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">x1</code><code class="p">)</code> <code class="p">{</code>
    
    <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
      <code class="kr">const</code> <code class="nx">x2</code> <code class="o">=</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">prompt</code><code class="p">(</code><code class="s1">'o plays 6, where does x play?'</code><code class="p">));</code>
      <code class="k">switch</code> <code class="p">(</code><code class="nx">x2</code><code class="p">)</code> <code class="p">{</code>
        
        <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">4</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">5</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">7</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">8</code><code class="o">:</code>
          <code class="nx">alert</code><code class="p">(</code><code class="s1">'o plays 3'</code><code class="p">);</code>
          <code class="k">break</code><code class="p">;</code>
        
        <code class="k">case</code> <code class="mi">3</code><code class="o">:</code>
          <code class="kr">const</code> <code class="nx">x3</code> <code class="o">=</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">prompt</code><code class="p">(</code><code class="s1">'o plays 8, where does x play?'</code><code class="p">));</code>
          <code class="k">switch</code> <code class="p">(</code><code class="nx">x3</code><code class="p">)</code> <code class="p">{</code>
            
            <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
            <code class="k">case</code> <code class="mi">5</code><code class="o">:</code>
            <code class="k">case</code> <code class="mi">7</code><code class="o">:</code>
              <code class="nx">alert</code><code class="p">(</code><code class="s1">'o plays 4'</code><code class="p">);</code>
              <code class="k">break</code><code class="p">;</code>
              
            <code class="k">case</code> <code class="mi">4</code><code class="o">:</code>
              <code class="nx">alert</code><code class="p">(</code><code class="s1">'o plays 7'</code><code class="p">);</code>
              <code class="k">break</code><code class="p">;</code>
          <code class="p">}</code>
      <code class="p">}</code>
      <code class="k">break</code><code class="p">;</code>
    
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Naughts and crosses is simple enough that the lookup function seems substantially simpler, in part because linear code doesn’t represent trees particularly well. But we can clearly see that if we wanted to, we could represent the state of the program implicitly in a decision tree.</p>

<p>However, our solution inverts the control. We aren’t calling our function with moves, it’s calling us. With iterators, we wrote a generator function using <code>function *</code>, and then used <code>yield</code> to yield values while maintaining the implicit state of the generator’s control flow.</p>

<p>Can we do the same thing here? At first glance, no. How do we get the player’s moves to the generator function? But the first glance is deceptive, because we only see what we’ve seen so far. Let’s see how it would actually work.</p>

<h4 id="leanpub-auto-interactive-generators">interactive generators</h4>

<p>So far, we have called iterators (and generators) with <code>.next()</code>. But what if we pass a value to <code>.next()</code>? If we could do that, a generator function that played naughts and crosses would look like this:</p>

<p>If it <em>was</em> possible, how would it work? </p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code><code class="o">*</code> <code class="nx">generatorNaughtsAndCrosses</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">x1</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">0</code><code class="p">;</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">x1</code><code class="p">)</code> <code class="p">{</code>
    
    <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
      <code class="kr">const</code> <code class="nx">x2</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">6</code><code class="p">;</code>
      <code class="k">switch</code> <code class="p">(</code><code class="nx">x2</code><code class="p">)</code> <code class="p">{</code>
        
        <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">4</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">5</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">7</code><code class="o">:</code>
        <code class="k">case</code> <code class="mi">8</code><code class="o">:</code>
          <code class="k">yield</code> <code class="mi">3</code><code class="p">;</code>
          <code class="k">break</code><code class="p">;</code>
        
        <code class="k">case</code> <code class="mi">3</code><code class="o">:</code>
          <code class="kr">const</code> <code class="nx">x3</code> <code class="o">=</code> <code class="k">yield</code> <code class="mi">8</code><code class="p">;</code>
          <code class="k">switch</code> <code class="p">(</code><code class="nx">x3</code><code class="p">)</code> <code class="p">{</code>
            
            <code class="k">case</code> <code class="mi">2</code><code class="o">:</code>
            <code class="k">case</code> <code class="mi">5</code><code class="o">:</code>
            <code class="k">case</code> <code class="mi">7</code><code class="o">:</code>
              <code class="k">yield</code> <code class="mi">4</code><code class="p">;</code>
              <code class="k">break</code><code class="p">;</code>
              
            <code class="k">case</code> <code class="mi">4</code><code class="o">:</code>
              <code class="k">yield</code> <code class="mi">7</code><code class="p">;</code>
              <code class="k">break</code><code class="p">;</code>
          <code class="p">}</code>
      <code class="p">}</code>
      <code class="k">break</code><code class="p">;</code>
    
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">aNaughtsAndCrossesGame</code> <code class="o">=</code> <code class="nx">generatorNaughtsAndCrosses</code><code class="p">();</code>
</pre></div>

</figure>

<p>We can then get the first move by calling <code>.next()</code>. Thereafter, we call <code>.next(...)</code> and pass in our moves (The very first call has to be <code>.next()</code> without any arguments, because the generator hasn’t started yet. If we wanted to pass some state to the generator before it begins, we’d do that with parameters.):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">aNaughtsAndCrossesGame</code><code class="p">.</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code>
  <code class="c1">//=&gt; 0</code>
  
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">value</code>
  <code class="c1">//=&gt; 6</code>
  
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">value</code>
  <code class="c1">//=&gt; 8</code>
  
<code class="nx">aNaughtsAndCrossesGame</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="mi">7</code><code class="p">).</code><code class="nx">value</code>
  <code class="c1">//=&gt; 4  </code>
</pre></div>

</figure>

<p>Our generator function maintains state implicitly in its control flow, but returns an iterator that we call, it doesn’t call us. It isn’t a collection, it has no meaning if we try to spread it into parameters or as the subject of a <code>for...of</code> block.</p>

<p>But the generator function allows us to maintain state implicitly. And sometimes, we want to use implicit state instead of explicitly storing state in our data.</p>

<h4 id="leanpub-auto-summary-7">summary</h4>

<p>We have looked at generators as ways of making iterators over static collections, where state is modelled implicitly in control flow. But as we see here, it’s also possible to use a generator interactively, passing values in and receiving a value in return, just like an ordinary function.</p>

<p>Again, the salient difference is that an “interactive” generator is stateful, and it embodies its state in its control flow.</p>

<h3 id="leanpub-auto-basic-operations-on-iterables">Basic Operations on Iterables</h3>

<p>Here are the operations we’ve defined on Iterables. As discussed, they preserve the collection semantics of the iterable they are given:</p>

<h4 id="leanpub-auto-operations-that-transform-one-iterable-into-another">operations that transform one iterable into another</h4>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">mapWith</code><code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">mapAllWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="o">*</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">filterWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">compact</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">element</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">element</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">untilWith</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">break</code><code class="p">;</code>
    <code class="k">yield</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">rest</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

  <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
  <code class="k">yield</code> <code class="o">*</code> <code class="nx">iterator</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">take</code> <code class="p">(</code><code class="nx">numberToTake</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterator</code> <code class="o">=</code> <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>

  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">numberToTake</code><code class="p">;</code> <code class="o">++</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">iterator</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-operations-that-compose-two-or-more-iterables-into-an-iterable">operations that compose two or more iterables into an iterable</h4>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="o">*</code> <code class="nx">zip</code> <code class="p">(...</code><code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterators</code> <code class="o">=</code> <code class="nx">iterables</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]());</code>

  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">pairs</code> <code class="o">=</code> <code class="nx">iterators</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">j</code> <code class="o">=&gt;</code> <code class="nx">j</code><code class="p">.</code><code class="nx">next</code><code class="p">()),</code>
          <code class="nx">dones</code> <code class="o">=</code> <code class="nx">pairs</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">done</code><code class="p">),</code>
          <code class="nx">values</code> <code class="o">=</code> <code class="nx">pairs</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">dones</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>
    <code class="k">yield</code> <code class="nx">values</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="o">*</code> <code class="nx">zipWith</code> <code class="p">(</code><code class="nx">zipper</code><code class="p">,</code> <code class="p">...</code><code class="nx">iterables</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">iterators</code> <code class="o">=</code> <code class="nx">iterables</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]());</code>

  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">pairs</code> <code class="o">=</code> <code class="nx">iterators</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">j</code> <code class="o">=&gt;</code> <code class="nx">j</code><code class="p">.</code><code class="nx">next</code><code class="p">()),</code>
          <code class="nx">dones</code> <code class="o">=</code> <code class="nx">pairs</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">done</code><code class="p">),</code>
          <code class="nx">values</code> <code class="o">=</code> <code class="nx">pairs</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">dones</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>
    <code class="k">yield</code> <code class="nx">zipper</code><code class="p">(...</code><code class="nx">values</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Note: <code>zip</code> is also the following special case of <code>zipWith</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">zip</code> <code class="o">=</code> <code class="nx">callFirst</code><code class="p">(</code><code class="nx">zipWith</code><code class="p">,</code> <code class="p">(...</code><code class="nx">values</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">values</code><code class="p">);</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-operations-that-transform-an-iterable-into-a-value">operations that transform an iterable into a value</h4>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">reduceWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="nx">seed</code><code class="p">,</code> <code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">seed</code><code class="p">;</code>

  <code class="k">for</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">iterable</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">accumulator</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">accumulator</code><code class="p">,</code> <code class="nx">element</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">accumulator</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">first</code> <code class="o">=</code> <code class="p">(</code><code class="nx">iterable</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">iterable</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]().</code><code class="nx">next</code><code class="p">().</code><code class="nx">value</code><code class="p">;</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-memoizing-an-iterable">memoizing an iterable</h4>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">memoize</code> <code class="p">(</code><code class="nx">generator</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">memos</code> <code class="o">=</code> <code class="p">{},</code>
        <code class="nx">iterators</code> <code class="o">=</code> <code class="p">{};</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="o">*</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">args</code><code class="p">);</code>
    <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">memos</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">memos</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
      <code class="nx">iterators</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">generator</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">memos</code><code class="p">[</code><code class="nx">key</code><code class="p">].</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">memos</code><code class="p">[</code><code class="nx">key</code><code class="p">][</code><code class="nx">i</code><code class="o">++</code><code class="p">];</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="p">{</code> <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">iterators</code><code class="p">[</code><code class="nx">key</code><code class="p">].</code><code class="nx">next</code><code class="p">();</code>

        <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">return</code><code class="p">;</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
          <code class="k">yield</code> <code class="nx">memos</code><code class="p">[</code><code class="nx">key</code><code class="p">][</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
        <code class="p">}</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<div class="footnotes">
  <ol>
    <li id="fn-symbol">You can read more about JavaScript symbols in Axel Rauschmayer’s <a href="http://www.2ality.com/2014/12/es6-symbols.html">Symbols in ECMAScript 2015</a>.<a href="https://leanpub.com/javascriptallongesix/read#fnref-symbol" rel="rev-footnote">↩</a>
</li>
    <li id="fn-mapWith">Yes, we also used the name <code>mapWith</code> for working with ordinary collections elsewhere. If we were writing a library of functions, we would have to disambiguate the two kinds of mapping functions with special names, namespaces, or modules. But for the purposes of discussing ideas, we can use the same name twice in two different contexts. It’s the same idea, after all.<a href="https://leanpub.com/javascriptallongesix/read#fnref-mapWith" rel="rev-footnote">↩</a>
</li>
    <li id="fn-empty">We wrote a <em>generator declaration</em>. We can also write <code>const empty = function * () {}</code> to bind an anonymous generator to the <code>empty</code> keyword, but we don’t need to do that here.<a href="https://leanpub.com/javascriptallongesix/read#fnref-empty" rel="rev-footnote">↩</a>
</li>
    <li id="fn-but">This may <strong>not</strong> work with various transpilers and other incomplete ECMAScript 2015 implementations. Check the documentation. For example, you must enable the “high compliancy” mode in <a href="http://babeljs.io/">BabelJS</a>. This is off by default to provide the highest possible performance for code bases that do not need to use features like this.<a href="https://leanpub.com/javascriptallongesix/read#fnref-but" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="symbols">A Coffeehouse: Symbols</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/tiny.jpg" alt="&quot;Uniqueness&quot; is an important quality in society and in programs.">
  <figcaption>“Uniqueness” is an important quality in society and in programs.</figcaption>
</figure>


<p>Programmers often spend a lot of time trying to define “sameness:” JavaScript programmers know that <code>"foo" === "foo"</code> is always true, but <code>new String("foo") === new String("foo")</code> is always false, and how tricky it is to define what we mean when we say that <code>{ foo: "bar" }</code> is <em>semantically equivalent</em> to <code>{ foo: "bar" }</code>.</p>

<p>Programmers don’t think about it quite as much, but entities being different from each other is also important. We know that <code>function () {} !== function () {}</code>. But having objects that we know to be different from each other can be very useful.</p>

<blockquote>
  <p>Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.–<a href="https://en.wikipedia.org/wiki/Greenspun&#39;s_tenth_rule">Greenspun’s Tenth Rule</a></p>
</blockquote>

<p>In older versions of JavaScript, programmers would hack together unique objects, using timestamps, GUIDS, counters and other techniques. None of which are individually wrong, but when there are 99 different ways to do the same thing that everybody ends up doing, the important parts of our code become obfuscated under the weight of our ad hoc, informally-specified, bug-ridden, slow implementations of Common Lisp’s <a href="http://www.lispdoc.com/?q=gensym">gensym</a>.</p>

<p>So <code>Symbol</code> was added to the language. In its simplest form, <code>Symbol</code> is a function that returns a unique entity. No two symbols are alike, ever:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Symbol</code><code class="p">()</code> <code class="o">!===</code> <code class="nx">Symbol</code><code class="p">()</code>
</pre></div>

</figure>

<p>Symbols have string representations, although they may appear cryptic:<sup id="fnref-impl"><a href="https://leanpub.com/javascriptallongesix/read#fn-impl" rel="footnote">1</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Symbol</code><code class="p">().</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(undefined)_u.mwf0blvw5</code>
<code class="nx">Symbol</code><code class="p">().</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(undefined)_s.niklxrko8m</code>
<code class="nx">Symbol</code><code class="p">().</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(undefined)_s.mbsi4nduh</code>
</pre></div>

</figure>

<p>You can add your own text to help make it intelligible:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Symbol</code><code class="p">(</code><code class="s2">"Allongé"</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(Allongé)_s.52x692eab</code>
<code class="nx">Symbol</code><code class="p">(</code><code class="s2">"Allongé"</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(Allongé)_s.q6hq5lx01p</code>
<code class="nx">Symbol</code><code class="p">(</code><code class="s2">"Allongé"</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>
  <code class="c1">//=&gt; Symbol(Allongé)_s.jii7eyiyza</code>
</pre></div>

</figure>

<p>There are some ways that JavaScript makes symbols especially handy. Using symbols as property names, for example.</p>

<h4 id="privacy-with-symbols">privacy with symbols</h4>

<p>When we use a symbol as a property name, it is automatically unique and non-enumerable. It is still possible to discover its existence and retrieve its value, but it is not possible for accidentally access or overwrite a property that uses a symbol as its key.</p>

<p>Therefore, we can give objects private properties with symbols. Consider this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code> 
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> 
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">])</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]];</code>
        
        <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="nx">Queue</code><code class="p">();</code>
<code class="nx">q</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'hello'</code><code class="p">);</code>
<code class="nx">q</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'symbols'</code><code class="p">);</code>

<code class="nx">q</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'hello'</code>
  
<code class="nx">q</code>
  <code class="c1">//=&gt; {"array":["hello","symbols"],"head":0,"tail":1}</code>
  
<code class="nx">q</code><code class="p">.</code><code class="nx">tail</code>
  <code class="c1">//=&gt; 1</code>
</pre></div>

</figure>

<p>Because we used compact method syntax, the <code>pushTail</code>, <code>pullHead</code>, and <code>isEmpty</code> properties are not “enumerable,” so they don’t show up in the console. But other code can access them. The <code>array</code>, <code>head</code>, and <code>tail</code> properties are enumerable and accessible.</p>

<p>Let’s use symbols for these properties instead:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(),</code>
      <code class="nx">head</code>  <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(),</code>
      <code class="nx">tail</code>  <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
      
<code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="p">[</code><code class="nx">array</code><code class="p">]</code><code class="o">:</code> <code class="p">[],</code> 
    <code class="p">[</code><code class="nx">head</code><code class="p">]</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> 
    <code class="p">[</code><code class="nx">tail</code><code class="p">]</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">])</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]];</code>
        
        <code class="k">this</code><code class="p">[</code><code class="nx">array</code><code class="p">][</code><code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">tail</code><code class="p">]</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">[</code><code class="nx">head</code><code class="p">]</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="nx">Queue</code><code class="p">();</code>
<code class="nx">q</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'hello'</code><code class="p">);</code>
<code class="nx">q</code><code class="p">.</code><code class="nx">pushTail</code><code class="p">(</code><code class="s1">'symbols'</code><code class="p">);</code>

<code class="nx">q</code><code class="p">.</code><code class="nx">pullHead</code><code class="p">()</code>
  <code class="c1">//=&gt; 'hello'</code>
  
<code class="nx">q</code>
  <code class="c1">//=&gt; {}</code>
  
<code class="nx">q</code><code class="p">.</code><code class="nx">tail</code>
  <code class="c1">//=&gt; undefined</code>
</pre></div>

</figure>

<p>Now the <code>array</code>, <code>head</code>, and <code>tail</code> properties are not enumerable and they aren’t accessible by those names because they’re actually symbols assigned to the <code>array</code>, <code>head</code>, and <code>tail</code> variables.</p>

<div class="footnotes">
  <ol>
    <li id="fn-impl">The exact representation depends upon the implementation<a href="https://leanpub.com/javascriptallongesix/read#fnref-impl" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="metaobjects">Life on the Plantation: Metaobjects</h2>

<p><img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/shadowbecomeswhite.jpg" alt="Krups Machines"><sup id="fnref-shadowbecomeswhite"><a href="https://leanpub.com/javascriptallongesix/read#fn-shadowbecomeswhite" rel="footnote">1</a></sup></p>

<p>(Note: The material in this section has been condensed and adapted from the book <a href="https://leanpub.com/javascript-spessore">JavaScript Spessore</a>)</p>

<div class="page-break"></div>
<h3 id="leanpub-auto-why-metaobjects">Why Metaobjects?</h3>

<aside class="information blurb">
    <p>In computer science, a metaobject is an object that manipulates, creates, describes, or implements other objects (including itself). The object that the metaobject is about is called the base object. Some information that a metaobject might store is the base object’s type, interface, class, methods, attributes, parse tree, etc.</p>

  <p>–<a href="https://en.wikipedia.org/wiki/Metaobject">Wikipedia</a></p>

</aside>

<p>It is possible to write software using objects alone. When we need behaviour for an object, we can give it methods by binding functions to keys in the object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Sam'</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Lowry'</code><code class="p">,</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We call this a “naïve” object. It has state and behaviour, but it lacks division of responsibility between its state and its behaviour.</p>

<p>This lack of separation has two drawbacks. First, it intermingles properties that are part of the model domain (such as <code>firstName</code>), with methods (and possibly other properties, although none are shown here) that are part of the implementation domain. Second, when we needed to share common behaviour, we could have objects share common functions, but does it not scale: There’s no sense of organization, no clustering of objects and functions that share a common responsibility.</p>

<p>Metaobjects solve the lack-of-separation problem by separating the domain-specific properties of objects from their implementation-specific properties and the functions that represent their behaviour.</p>

<p>The basic principle of the metaobject is that we separate the mechanics of behaviour from the domain properties of the base object. This has immediate engineering benefits, and it’s also the foundation for designing programs with formal classes, expectations, and delegation.</p>

<h3 id="mixins">Mixins, Forwarding, and Delegation</h3>

<p>The simplest possible metaobject in JavaScript is a <em>mixin</em>. Consider our naïve object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Sam'</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Lowry'</code><code class="p">,</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We can separate its domain properties from its behaviour:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Sam'</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Lowry'</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>And use <code>Object.assign</code> to mix the behaviour in:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">sam</code><code class="p">,</code> <code class="nx">Person</code><code class="p">);</code>

<code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code>
  <code class="c1">//=&gt; [Function]</code>
</pre></div>

</figure>

<p>This allows us to separate the behaviour from the properties in our code.</p>

<p>Our <code>Person</code> object is a <em>mixin</em>, it provides functionality to be mixed into an object with a function like <code>Object.assign</code>. Mixins are not “copied” into objects in the sense of making brand new versions of each of their functions: <code>Object.assign</code> copies <em>references</em> to each function from the mixin into the target object.</p>

<p>We can test this for ourselves:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">===</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">fullName</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code> <code class="o">===</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">rename</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>If we want to use the same behaviour with another object, we can do that:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">peck</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Sam'</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Peckinpah'</code>
<code class="p">};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">peck</code><code class="p">,</code> <code class="nx">Person</code><code class="p">);</code>
</pre></div>

</figure>

<p>And of course, that object gets references to the original functions as well:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">===</code> <code class="nx">peck</code><code class="p">.</code><code class="nx">fullName</code>
  <code class="c1">//=&gt; true</code>
  
<code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code> <code class="o">===</code> <code class="nx">peck</code><code class="p">.</code><code class="nx">rename</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Thus, many objects can mix one object in.</p>

<p>Things get even better: One object can mix many objects in:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">HasCareer</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">career</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">chosenCareer</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">setCareer</code> <code class="p">(</code><code class="nx">career</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">chosenCareer</code> <code class="o">=</code> <code class="nx">career</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">peck</code><code class="p">,</code> <code class="nx">Person</code><code class="p">,</code> <code class="nx">HasCareer</code><code class="p">);</code>

<code class="nx">peck</code><code class="p">.</code><code class="nx">setCareer</code><code class="p">(</code><code class="s1">'Director'</code><code class="p">);</code>
</pre></div>

</figure>

<p>Since many objects can all mix the same object in, and since one object can mix many objects into itself, there is a <em>many-to-many</em> relationship between objects and mixins.</p>

<h4 id="leanpub-auto-forwarding">forwarding</h4>

<p>Another way to build a metaobject that defines behaviour for another object is by having the object <em>forward</em> one or more method calls to a metaobject.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">forward</code> <code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">metaobject</code><code class="p">,</code> <code class="p">...</code><code class="nx">methods</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">methods</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">metaobject</code><code class="p">[</code><code class="nx">methodName</code><code class="p">](...</code><code class="nx">args</code><code class="p">)</code>
  <code class="p">});</code>

  <code class="k">return</code> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This function <em>forwards</em> methods to another object. Any other object, it could be a metaobject specifically designed to define behaviour, or it could be a domain object that has other responsibilities. Like mixins, one object might forward method invocations to more than one metaobject.</p>

<p>In this example, we start with an investment portfolio metaobject that has a <code>netWorth</code> method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">portfolio</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">investments</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
  
  <code class="k">return</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">investments</code><code class="p">]</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">addInvestment</code> <code class="p">(</code><code class="nx">investment</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">investments</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">investment</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="nx">netWorth</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">investments</code><code class="p">].</code><code class="nx">reduce</code><code class="p">(</code>
        <code class="kd">function</code> <code class="p">(</code><code class="nx">acc</code><code class="p">,</code> <code class="nx">investment</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">return</code> <code class="nx">acc</code> <code class="o">+</code> <code class="nx">investment</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="mi">0</code>
      <code class="p">);</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">})();</code>
</pre></div>

</figure>

<p>And next we create an investor who has a portfolio of investments:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">investor</code> <code class="o">=</code> <code class="nx">forward</code><code class="p">({},</code> <code class="nx">portfolio</code><code class="p">,</code> <code class="s2">"addInvestment"</code><code class="p">,</code> <code class="s2">"netWorth"</code><code class="p">);</code>

<code class="nx">investor</code><code class="p">.</code><code class="nx">addInvestment</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"art"</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1000000</code> <code class="p">})</code>
<code class="nx">investor</code><code class="p">.</code><code class="nx">addInvestment</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"art"</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">2000000</code> <code class="p">})</code>
<code class="nx">investor</code><code class="p">.</code><code class="nx">netWorth</code><code class="p">()</code>
  <code class="c1">//=&gt; 3000000</code>
</pre></div>

</figure>

<h4 id="forwarding">forwarding</h4>

<p>Forwarding is a relationship between an object that receives a method invocation receiver and a provider object. They may be peers. The provider may be contained by the consumer. Or perhaps the provider is a metaobject.</p>

<p>When forwarding, the provider object has its own state. There is no special binding of function contexts, instead the consumer object has its own methods that forward to the provider and return the result. Our <code>forward</code> function above handles all of that, iterating over the provider’s properties and making forwarding methods in the consumer.</p>

<p>The key idea is that when forwarding, the provider object handles each method <em>in its own context</em>. And because there is a forwarding method in the consumer object and a handling method in the provider, the two can be varied independently. Each forwarding function invokes the method in the provider <em>by name</em>. So we can do this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">portfolio</code><code class="p">.</code><code class="nx">netWorth</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="s2">"I'm actually bankrupt!"</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We’re overwriting the method in the <code>portfolio</code> object, but not the forwarding function. So now, our <code>investor</code> object will forward invocations of <code>netWorth</code> to the new function, not the original.</p>

<p>We say that mixing in is “early bound,” while forwarding is “late bound:” We’ll look up the method when it’s invoked.</p>

<h4 id="leanpub-auto-shared-forwarding">shared forwarding</h4>

<p>The premise of a mixin is that every time you mix the metaobject’s behaviour into an object, the receiver holds the state for the behaviour being mixed in. Thus, you can mix the same metaobject into many objects, and they each will have their own state.</p>

<p>Forwarding does not work this way. When objects A and B both forward to C, the private state for C is held in C, and thus A and B share state. Sometimes this is what we want. but if it isn’t, we must be very careful about using forwarding.</p>

<h4 id="leanpub-auto-summarizing-what-we-know-so-far">summarizing what we know so far</h4>

<p>So now we have two things: Mixing in a mixin, and forwarding to a first-class object. And we’ve seen that mixins <em>execute in the context of the receiver</em>, but forwarding is <em>late-bound</em>.</p>

<p>Which provokes a question: What is evaluated in the receiver’s context, but late-bound, not early-bound?</p>

<h4 id="leanpub-auto-delegation">delegation</h4>

<p>Let’s build it. Here’s a version of the <code>forward</code> function, modified to evaluate method invocation in the receiver’s context:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">delegate</code> <code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">metaobject</code><code class="p">,</code> <code class="p">...</code><code class="nx">methods</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">methods</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">metaobject</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">a</code><code class="o">\</code>
<code class="nx">rgs</code><code class="p">)</code>
  <code class="p">});</code>

  <code class="k">return</code> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This new <code>delegate</code> function does exactly the same thing as the <code>forward</code> function, but the line that does the delegation looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">metaobject</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>
</pre></div>

</figure>

<p>It uses the receiver as the context instead of the provider. This has all the same coupling implications that our mixins have, of course. And it layers in additional indirection. But unlike a mixin and like forwarding, the indirection gives us some late binding, allowing us to modify the metaobject’s methods <em>after</em> we have delegated behaviour from a receiver to it.</p>

<h4 id="leanpub-auto-delegation-vs-forwarding">delegation vs. forwarding</h4>

<p>Delegation and forwarding are both very similar. One metaphor that might help distinguish them is to think of receiving an email asking you to donate some money to a worthy charity.</p>

<ul>
  <li>If you <em>forward</em> the email to a friend, and the friend donates money, the friend is donating their own money and getting their own tax receipt.</li>
  <li>If you <em>delegate</em> responding to your accountant, the accountant donates <em>your</em> money to the charity and you receive the tax receipt.</li>
</ul>

<p>In both cases, the other entity does the work when you receive the email.</p>

<h3 id="later-binding">Later Binding</h3>

<p>When comparing Mixins to Delegation, we noted that Mixins are early bound and Delegation is late bound. Let’s be specific. Given:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Incrementor</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">increment</code> <code class="p">()</code> <code class="p">{</code>
    <code class="o">++</code><code class="k">this</code><code class="p">.</code><code class="nx">_value</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">value</code> <code class="p">(</code><code class="nx">optionalValue</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">optionalValue</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">_value</code> <code class="o">=</code> <code class="nx">optionalValue</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_value</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">counter</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">Incrementor</code><code class="p">);</code>
</pre></div>

</figure>

<p>We are mixing <code>Incrementor</code> into <code>counter</code>. At some point later, we encounter:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">counter</code><code class="p">.</code><code class="nx">value</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
</pre></div>

</figure>

<p>What function handles the invocation of <code>.value</code>? because we mixed <code>Incrementor</code> into <code>counter</code>, it’s the same function as <code>Incrementor.counter</code>. We don’t look that up when <code>counter.value(42)</code> is evaluated, because that was bound to <code>counter.value</code> when we extended <code>counter</code>. This is early binding.</p>

<p>However, given:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">counter</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nx">delegate</code><code class="p">(</code><code class="nx">counter</code><code class="p">,</code> <code class="nx">Incrementor</code><code class="p">);</code>

<code class="c1">// ...time passes...</code>

<code class="nx">counter</code><code class="p">.</code><code class="nx">value</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>
</pre></div>

</figure>

<p>We again are most likely invoking <code>Incrementor.value</code>, but now we are determining this <em>at the time <code>counter.value(42)</code> is evaluated</em>. We bound the target of the delegation, <code>Incrementor</code>, to <code>counter</code>, but we are going to look the actual property of <code>Incrementor.value</code> up when it is invoked. This is late binding, and it is useful in that we can make some changes to <code>Incrementor</code> after the delegation has been set up, perhaps to add some logging.</p>

<p>It is very nice not to have to do things like this in a very specific order: When things have to be done in a specific order, they are <em>coupled in time</em>. Late binding is a decoupling technique.</p>

<h4 id="leanpub-auto-but-wait-theres-more">but wait, there’s more</h4>

<p>But we can get <em>even later than that</em>. Although the specific function is late bound, the target of the delegation, <code>Incrementor</code>, is early bound. We can late bind that too! Here’s a variation on <code>delegate</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">delegateToOwn</code> <code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">propertyName</code><code class="p">,</code> <code class="p">...</code><code class="nx">methods</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">methods</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">metaobject</code> <code class="o">=</code> <code class="nx">receiver</code><code class="p">[</code><code class="nx">propertyName</code><code class="p">];</code>
      <code class="k">return</code> <code class="nx">metaobject</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">});</code>

  <code class="k">return</code> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This function sets things up so that an object can delegate to one of its own properties, instead of an arbitrary object. It’s quite common for an object to forward methods to one of its own properties. In this manner, objects can be constructed using <em>composition</em>. </p>

<p>Let’s take another look at the investor example. Here’s the <code>portfolio</code> we used before. modified to use the receiver’s context like a mixin:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">portfolio</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">investmentsProperty</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
  
  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">addInvestment</code> <code class="p">(</code><code class="nx">investment</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">investment</code><code class="p">);</code>
    <code class="p">},</code>
    <code class="nx">netWorth</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">investmentsProperty</code><code class="p">].</code><code class="nx">reduce</code><code class="p">(</code>
        <code class="kd">function</code> <code class="p">(</code><code class="nx">acc</code><code class="p">,</code> <code class="nx">investment</code><code class="p">)</code> <code class="p">{</code>
          <code class="k">return</code> <code class="nx">acc</code> <code class="o">+</code> <code class="nx">investment</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="mi">0</code>
      <code class="p">);</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">})();</code>
</pre></div>

</figure>

<p>Next we’ll make that a property of our investor, and delegate to the <code>nestEgg</code> property by name, not the object itself:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">investor</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">nestEgg</code><code class="o">:</code> <code class="nx">portfolio</code>
<code class="p">}</code>

<code class="nx">delegateToOwn</code><code class="p">(</code><code class="nx">investor</code><code class="p">,</code> <code class="s1">'nestEgg'</code><code class="p">,</code> <code class="s1">'addInvestment'</code><code class="p">,</code> <code class="s1">'netWorth'</code><code class="p">);</code>

<code class="nx">investor</code><code class="p">.</code><code class="nx">addInvestment</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"art"</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1000000</code> <code class="p">})</code>
<code class="nx">investor</code><code class="p">.</code><code class="nx">addInvestment</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"art"</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">2000000</code> <code class="p">})</code>
<code class="nx">investor</code><code class="p">.</code><code class="nx">netWorth</code><code class="p">()</code>
  <code class="c1">//=&gt; 3000000</code>
</pre></div>

</figure>

<p>Our <code>investor</code> object delegates the <code>addInvestment</code> and <code>netWorth</code> methods to its own <code>nestEgg</code> property. So far, this is just like the <code>delegate</code> method above. But consider what happens if we decide to assign a new portfolio to our investor:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">companyRetirementPlan</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">netWorth</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">1500000</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">investor</code><code class="p">.</code><code class="nx">nestEgg</code> <code class="o">=</code> <code class="nx">companyRetirementPlan</code><code class="p">;</code>

<code class="nx">investor</code><code class="p">.</code><code class="nx">netWorth</code><code class="p">()</code>
  <code class="c1">//=&gt; 1500000</code>
</pre></div>

</figure>

<p>The <code>delegateToOwn</code> delegation now delegates to <code>companyRetirementPlan</code>, because it is bound to the property name, not to the original object. This seems questionable for portfolios–what happens to the old portfolio when you assign a new one?–but has tremendous application for modeling classes of behaviour that change dynamically.</p>

<h4 id="state-machines">state machines</h4>

<p>A very common use case for this delegation is when building <a href="https://en.wikipedia.org/wiki/Finite-state_machine">finite state machines</a>. As described in the book <a href="https://leanpub.com/4rulesofsimpledesign">Understanding the Four Rules of Simple Design</a> by Corey Haines, you <em>could</em> implement <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game of Life</a> using <code>if</code> statements. Hand waving furiously over other parts of the system, you might get:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Universe</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c1">// ...</code>
  <code class="nx">numberOfNeighbours</code> <code class="p">(</code><code class="nx">location</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">thisGame</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">Universe</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">Cell</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">alive</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_alive</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">numberOfNeighbours</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">thisGame</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_location</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">aliveInNextGeneration</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">alive</code><code class="p">())</code> <code class="p">{</code>
      <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">3</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
      <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">2</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">3</code><code class="o">\</code>
<code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">someCell</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">_alive</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
  <code class="nx">_location</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="o">-</code><code class="mi">15</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">12</code><code class="p">}</code>
<code class="p">},</code> <code class="nx">Cell</code><code class="p">);</code>
</pre></div>

</figure>

<p>One of the many insights from <a href="https://leanpub.com/4rulesofsimpledesign">Understanding the Four Rules of Simple Design</a> is that this business of having an <code>if (alive())</code> in the middle of a method is a hint that cells are stateful.</p>

<p>We can extract this into a state machine using delegation to a property:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Alive</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">alive</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">aliveInNextGeneration</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">3</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Dead</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">alive</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">aliveInNextGeneration</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">2</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">()</code> <code class="o">===</code> <code class="mi">3</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">FsmCell</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">numberOfNeighbours</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">thisGame</code><code class="p">.</code><code class="nx">numberOfNeighbours</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_location</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">delegateToOwn</code><code class="p">(</code><code class="nx">Cell</code><code class="p">,</code> <code class="s1">'_state'</code><code class="p">,</code> <code class="p">[</code><code class="s1">'alive'</code><code class="p">,</code> <code class="s1">'aliveInNextGeneration'</code><code class="p">]);</code>

<code class="kr">const</code> <code class="nx">someFsmCell</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">_state</code><code class="o">:</code> <code class="nx">Alive</code><code class="p">,</code>
  <code class="nx">_location</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="o">-</code><code class="mi">15</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">12</code><code class="p">}</code>
<code class="p">},</code> <code class="nx">FsmCell</code><code class="p">);</code>
</pre></div>

</figure>

<p><code>someFsmCell</code> delegates <code>alive</code> and <code>aliveInNextGeneration</code> to its <code>_state</code> property, and you can change its state with assignment:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">someFsmCell</code><code class="p">.</code><code class="nx">_state</code> <code class="o">=</code> <code class="nx">Dead</code><code class="p">;</code>
</pre></div>

</figure>

<p>In practice, states would be assigned en masse, but this demonstrates one of the simplest possible state machines. In the wild, most business objects are state machines, sometimes with multiple, loosely coupled states. Employees can be:</p>

<ul>
  <li>In or out of the office;</li>
  <li>On probation, on contract, or permanent;</li>
  <li>Part time or full time.</li>
</ul>

<p>Delegation to a property representing state takes advantage of late binding to break behaviour into smaller components that have cleanly defined responsibilities.</p>

<h4 id="leanpub-auto-late-bound-forwarding">late bound forwarding</h4>

<p>The exact same technique can be used for forwarding to a property, and forwarding to a property can also be used for some kinds of state machines. Forwarding to a property has lower coupling than delegation, and is preferred where appropriate.</p>

<h3 id="prototypes">Delegation via Prototypes</h3>

<p>At this point, we’re discussed separating behaviour from object properties using metaobjects while avoiding discussion of prototypes. This is deliberate, because what we have achieved is developing a vocabulary for describing what a prototype is.</p>

<p>Let’s review what we know so far:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">fullName</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>So far, just like any other metaobject we’d use as a mixin, or perhaps with delegation.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
<code class="nx">sam</code>
  <code class="c1">//=&gt; {}</code>
</pre></div>

</figure>

<p>This is different. Instead of creating an object and then using <code>Object.assign</code> to incorporate behaviour from a metaobject, we’re using <code>Object.create</code>, a built-in method that creates the object while simultaneously associating it with a prototype.</p>

<p>The methods <code>fullName</code> and <code>rename</code> do not appear in its string representation. We’ll find out why in a moment.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code>
  <code class="c1">//=&gt; [Function]</code>
<code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code>
  <code class="c1">//=&gt; [Function]</code>
<code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Samuel'</code><code class="p">,</code> <code class="s1">'Ballard'</code><code class="p">)</code>
  <code class="c1">//=&gt; { firstName: 'Samuel', lastName: 'Ballard' }</code>
<code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Samuel Ballard'</code>
</pre></div>

</figure>

<p>And yet, they appear to be properties of <code>sam</code>, and we can invoke them in the usual fashion. Furthermore, we can tell that when the methods are invoked, the current context is being set to the receive, <code>sam</code>: That’s why invoking <code>rename</code> sets <code>sam.firstName</code> and <code>sam.lastName</code>.</p>

<p>So far this is almost identical to using a mixin or delegation, but not a private mixin or forwarding because methods are evaluated in <code>sam</code>’s scope. The only difference appears to be how <code>sam</code> is displayed in the console. We recall that the big difference between a mixin and delegation is whether the methods are early or late bound.</p>

<p>So, if we <em>change</em> a method in <code>Person</code>, then if prototypes are early bound, <code>sam</code>’s behaviour will not change. Whereas if methods are late bound, <code>sam</code>’s behaviour will change. Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Person</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">+</code> <code class="s1">', '</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code><code class="p">;</code>
<code class="p">};</code>

<code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Ballard, Samuel'</code>
</pre></div>

</figure>

<p>Aha! Prototypes have <em>delegation semantics</em>: They are late bound, and evaluated in the receiver’s context. This is exactly why many programmers say that prototypes are a delegation mechanism.</p>

<p>We’ve already seen delegation implemented via <em>method proxies</em>. Now we see it implemented via prototypes.</p>

<h4 id="leanpub-auto-prototypes-are-strictly-many-to-one">prototypes are strictly many-to-one.</h4>

<p>Delegation is a many-to-many relationship. One object can directly delegate to more than one metaobject, and more than one object can directly delegate to the same metaobject. This is not the case with prototypes: <code>Object.create</code> only allows you to specific <em>one</em> prototype for an object you’re creating. You can <em>change</em> the prototype of an Object with <code>Object.setprototypeOf</code>, but each object can onlyhave one prototype at a time.</p>

<h4 id="leanpub-auto-sharing-prototypes">sharing prototypes</h4>

<p>Several objects can share one prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">saywhatagain</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
</pre></div>

</figure>

<p><code>sam</code> and <code>saywhatagain</code> both share the <code>Person</code> prototype, so they both share the <code>rename</code> and <code>fullName</code> methods. But they each have their own properties, so:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Samuel'</code><code class="p">,</code> <code class="s1">'Ballard'</code><code class="p">);</code>
<code class="nx">saywhatagain</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Samuel'</code><code class="p">,</code> <code class="s1">'Jackson'</code><code class="p">);</code>

<code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Samuel Ballard'</code>

<code class="nx">saywhatagain</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Samuel Jackson'</code>
</pre></div>

</figure>

<p>The limitation of this scheme becomes apparent when we consider behaviours that need to be composed. Given <code>Person</code>, <code>IsAuthor</code>, and <code>HasBooks</code>, if we have some people that are authors, some that have children, some that aren’t authors and don’t have children, and some authors that have children, prototypes cannot directly manage these behaviours without duplication.</p>

<h4 id="leanpub-auto-prototypes-are-open-for-extension">prototypes are open for extension</h4>

<p>With forwarding and delegation, the body of the method being proxied is late-bound because it is looked up by name when the method is invoked. This differs from mixins, where the body of the method is early bound by reference at the time the metaobject is mixed in.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">methodNames</code> <code class="o">=</code> <code class="p">(</code><code class="nx">object</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">object</code><code class="p">).</code><code class="nx">filter</code><code class="p">(</code><code class="nx">key</code> <code class="o">=&gt;</code> <code class="k">typeof</code><code class="p">(</code><code class="nx">object</code><code class="p">[</code><code class="nx">key</code><code class="p">])</code> <code class="o">==</code> <code class="s1">'function'</code><code class="p">)</code>
    
<code class="kd">function</code> <code class="nx">delegate</code> <code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">metaobject</code><code class="p">,</code> <code class="p">...</code><code class="nx">methods</code> <code class="o">=</code> <code class="nx">methodNames</code><code class="p">(</code><code class="nx">metaobject</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">methods</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">metaobject</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">a</code><code class="o">\</code>
<code class="nx">rgs</code><code class="p">)</code>
  <code class="p">});</code>

  <code class="k">return</code> <code class="nx">receiver</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">lowry</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">delegate</code><code class="p">(</code><code class="nx">lowry</code><code class="p">,</code> <code class="nx">Person</code><code class="p">);</code>
<code class="nx">lowry</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Sam'</code><code class="p">,</code> <code class="s1">'Lowry'</code><code class="p">);</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="s1">'. '</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
<code class="p">};</code>
<code class="nx">lowry</code><code class="p">.</code><code class="nx">fullName</code><code class="p">();</code>
  <code class="c1">//=&gt; 'S. Lowry'</code>
</pre></div>

</figure>

<p>Prototypes and delegation both allow you to change the body of a method after a metaobject has been bound to an object.</p>

<p>But what happens if we add an entirely new method to our metaobject?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Person</code><code class="p">.</code><code class="nx">surname</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>An object using our method proxies <em>does not</em> delegate the new method to its metaobject, because we never created a method proxy for <code>surname</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">lowry</code><code class="p">.</code><code class="nx">surname</code><code class="p">()</code>
  <code class="c1">//=&gt; TypeError: Object #&lt;Object&gt; has no method 'surname'</code>
</pre></div>

</figure>

<p>Whereas, an object using a prototype <em>does</em> delegate the new method to the prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">surname</code><code class="p">()</code>
 <code class="c1">//=&gt; 'Ballard'</code>
</pre></div>

</figure>

<p>Prototypes late bind the method bodies <em>and</em> they late bind the identities of the methods being delegated. So you can add and remove methods to a prototype, and the behaviour of all of the objects bound to that prototype will be changed.</p>

<p>We say that <em>prototypes are open for extension</em>, because you can extend their behaviour <em>after</em> creating objects with them. We say that <em>mixins are closed for extension</em>, because behaviour added to a mixin does not change any of the objects that have already incorporated it.</p>

<h4 id="leanpub-auto-summarizing">summarizing</h4>

<p>Prototypes are a special kind of delegation mechanism that is built into JavaScript. Delegating through prototypes is:</p>

<ol class="numeric">
  <li>Late bound on method bodies, just like delegation through method proxies;</li>
  <li>Late bound on the method identities, which is superior to delegation through method proxies;</li>
  <li>Evaluated in the receiver’s context, just like delegation.</li>
  <li>Open for extension, unlike mixins, forwarding, and explicit delegation.</li>
</ol>

<p>Prototypes are usually the first form of metaobject that many developers learn in JavaScript, and quite often the last.</p>

<h4 id="leanpub-auto-one-more-thing">…one more thing!</h4>

<p>There is one more way that delegation via prototypes differs from delegation via method proxies, and it’s very important. We recall from above that object delegating to a prototype appear differently in the console than objects delegating via method proxies:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code>
  <code class="c1">//=&gt; { firstName: 'Samuel', lastName: 'Ballard' }</code>

<code class="nx">lowry</code>
  <code class="c1">//=&gt;</code>
    <code class="p">{</code> <code class="nx">fullName</code><code class="o">:</code> <code class="p">[</code><code class="nb">Function</code><code class="p">],</code>
      <code class="nx">rename</code><code class="o">:</code> <code class="p">[</code><code class="nb">Function</code><code class="p">],</code>
      <code class="nx">firstName</code><code class="o">:</code> <code class="s1">'Sam'</code><code class="p">,</code>
      <code class="nx">lastName</code><code class="o">:</code> <code class="s1">'Lowry'</code> <code class="p">}</code>
</pre></div>

</figure>

<p>The reason is very simple: The code for representing an object in the console iterates over its “own” properties, properties that belong to the object itself and not its prototype. In the case of <code>sam</code>, those are <code>firstName</code> and <code>lastName</code>, but not <code>fullName</code> or <code>rename</code> because those are properties of the prototype.</p>

<p>Whereas in the case of <code>lowry</code>, <code>fullName</code> and <code>rename</code> are properties of <code>Person</code>, but there are also function proxies that are properties of the <code>lowry</code> object itself.</p>

<p>We can test this for ourselves using the <code>.hasOwnProperty</code> method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="s1">'fullName'</code><code class="p">);</code>
  <code class="c1">//=&gt; false</code>
<code class="nx">lowry</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="s1">'fullName'</code><code class="p">);</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>One of the goals of metaobjects is to separate domain properties (such as <code>firstName</code>) from behaviour (such as <code>.fullName()</code>). All of our metaobject techniques allow us to do that in our written code, but prototypes do this extremely effectively in the runtime structure of the objects themselves.</p>

<p>This is extremely useful.</p>

<h3 id="leanpub-auto-shared-prototypes">Shared Prototypes</h3>

<p>We can create a very simple object and associate it with a prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">sam</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
</pre></div>

</figure>

<p>This associates behaviour with our object:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'sam'</code><code class="p">,</code> <code class="s1">'hill'</code><code class="p">);</code>
<code class="nx">sam</code><code class="p">.</code><code class="nx">fullName</code><code class="p">();</code>
  <code class="c1">//=&gt; 'sam hill'</code>
</pre></div>

</figure>

<p>There is no way to associate more than one prototype with the same object, but we can associate more than one object with the same prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">bewitched</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
<code class="nx">bewitched</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Samantha'</code><code class="p">,</code> <code class="s1">'Stephens'</code><code class="p">);</code>
</pre></div>

</figure>

<p>Although they share the prototype, their individual properties (as access with <code>this</code>), are separate:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">sam</code>
  <code class="c1">//=&gt; { firstName: 'sam', lastName: 'hill' }</code>
<code class="nx">bewitched</code>
  <code class="c1">//=&gt; { firstName: 'Samantha', lastName: 'Stephens' }</code>
</pre></div>

</figure>

<p>This is very convenient.</p>

<h4 id="leanpub-auto-prototype-chains">prototype chains</h4>

<p>Consider our <code>HasCareer</code> mixin:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">HasCareer</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">career</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">chosenCareer</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">setCareer</code> <code class="p">(</code><code class="nx">career</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">chosenCareer</code> <code class="o">=</code> <code class="nx">career</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>We can use it as a prototype, of course. But we already want to use <code>Person</code> as a prototype. What can we do? Obviously, we can combine <code>Person</code> and <code>HasCareer</code> into a “fat prototype” called <code>PersonWithCareer</code>. This is not great, a general principle of software is that entities should have a single clearly defined responsibility.</p>

<p>Even if we weren’t hung up on single responsibility, another issue is that not all people have careers, so we need one prototype for people, and another for people with careers.</p>

<p>The catch is, another principle of good design is that every piece of knowledge should have one unambiguous representation. The knowledge of what makes a person falls into this category. If we were to add another method to <code>Person</code>, would we remember to add it to <code>PersonWithCareer</code>?</p>

<p>Let’s work from two principles:</p>

<ol class="numeric">
  <li>Any object can have an object as its prototype, and any object can be a prototype.</li>
  <li>The behaviour of an object consists of all of its own behaviour, plus all the behaviour of its prototype.</li>
</ol>

<p>When we say <em>any</em> object can have a prototype, does that include objects used as prototypes? Yes. Objects used as prototypes can have prototypes of their own.</p>

<p>Let’s try it. First things first:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">PersonWithCareer</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>
</pre></div>

</figure>

<p>Now let’s mix <code>HasCareer</code> into <code>PersonWithCareer</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">PersonWithCareer</code><code class="p">,</code> <code class="nx">HasCareer</code><code class="p">);</code>
</pre></div>

</figure>

<p>And now we can use <code>PersonWithCareer</code> as a prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">goldie</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">PersonWithCareer</code><code class="p">);</code>
<code class="nx">goldie</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Samuel'</code><code class="p">,</code> <code class="s1">'Goldwyn'</code><code class="p">);</code>
<code class="nx">goldie</code><code class="p">.</code><code class="nx">setCareer</code><code class="p">(</code><code class="s1">'Producer'</code><code class="p">);</code>
</pre></div>

</figure>

<p>Why does this work?</p>

<p>Imagine that we were writing a JavaScript (or other OO) language implementation. Method invocation is incredibly messy, full of special optimizations and so forth, but perhaps we only have ten days to get it done, so we might proceed like this without even thinking about prototype chains:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">invokeMethod</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">methodName</code><code class="p">,</code> <code class="nx">listOfArguments</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">invokeMethodWithContext</code><code class="p">(</code><code class="nx">receiver</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">,</code> <code class="nx">methodName</code><code class="p">,</code> <code class="nx">listOfArguments</code><code class="o">\</code>
<code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">invokeMethodWithContext</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">,</code> <code class="nx">methodName</code><code class="p">,</code> <code class="nx">listOfArguments</code><code class="p">)</code><code class="o">\</code>
 <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">prototype</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="nx">receiver</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">methodName</code><code class="p">))</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">receiver</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">listOfArguments</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">receiver</code><code class="p">))</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">invokeMethodWithContext</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">prototype</code><code class="p">,</code> <code class="nx">methodName</code><code class="p">,</code> <code class="nx">listOfArgumen</code><code class="o">\</code>
<code class="nx">ts</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">{</code>
    <code class="k">throw</code> <code class="s1">'Method Missing '</code> <code class="o">+</code> <code class="nx">methodName</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Very simple: If the object implements the method, invoke it with <code>.apply</code>. If the object doesn’t implement it but has a prototype, ask the prototype to implement it in the original receiver’s context.</p>

<p>What if the prototype doesn’t implement it but has a prototype of its own? Well, we’ll recursively try that object too. Conceptually, this is what happens when we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">goldie</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Samuel Goldwyn'</code>
</pre></div>

</figure>

<p>In theory, the JavaScript engine walks up a chain starting with the <code>goldie</code> object, followed by our <code>PersonWithCareer</code> prototype followed by our <code>Person</code> prototype.</p>

<h4 id="leanpub-auto-trees">trees</h4>

<p>Chaining prototypes is a useful technique, however it has some limitations. Because objects can have only one prototype, you cannot model all combinations of responsibilities solely with prototype chains. The classic example is known as “The W Pattern:”</p>

<p>Let’s consider three prototypes to be used for employees in a factory: <code>Laborer</code>, <code>Manager</code>, and <code>OnProbation</code>.</p>

<p>All employees are either <code>Laborer</code> or <code>Manager</code>, but not both. So far, very easy, they can be prototypes. Some labourers are also on probation, as are some managers. How do we handle this with prototype chains?</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/w.jpg" alt="Labourers, Managers, and OnProbation">
  <figcaption>Labourers, Managers, and OnProbation</figcaption>
</figure>


<p>Well, we can’t have <code>Laborer</code> or <code>Manager</code> share <code>OnProbation</code> as a prototype, because then <em>all</em> labourers and managers would be on probation. And if we make <code>OnProbation</code> have <code>Laborer</code> as its prototype, there’s no way to have a manager also be on probation without making it also a laborer, and that’s not allowed.</p>

<p>Quite simply, a tree is an insufficient mechanism for modeling this relationship.</p>

<p>Prototype chains model trees, but most domain responsibilities cannot be represented as trees, so we must either revert to using “fat prototypes,” or find another way to represent responsibilities, such as mixing metaobjects into prototypes.</p>

<h4 id="leanpub-auto-prototypes-and-mixins">prototypes and mixins</h4>

<p>We’ve seen how to use <code>Object.assign</code> to mix functionality directly into objects. Prototypes are objects, so it follows that we can mix functionality into prototypes. We used this technique when we created the <code>PersonWithCareer</code> shared prototype.</p>

<p>We can extend this technique when we run into limitations with prototype chains:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Laborer</code> <code class="o">=</code> <code class="p">{</code>
 <code class="c1">// ...</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">Manager</code> <code class="o">=</code> <code class="p">{</code>
 <code class="c1">// ...</code>
<code class="p">};</code>
<code class="kr">const</code> <code class="nx">Probationary</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">LaborerOnProbation</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">Laborer</code><code class="p">,</code> <code class="nx">Probationary</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">ManagerOnProbation</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">Manager</code><code class="p">,</code> <code class="nx">Probationary</code><code class="p">);</code>
</pre></div>

</figure>

<p>Using mixins, we have created prototypes that model combining labor/management with probationary status.</p>

<h4 id="leanpub-auto-caveat-programmer">caveat programmer</h4>

<p>Whether we’re using prototype chains or mixins, we’re introducing coupling. As discussed in <a href="https://leanpub.com/javascriptallongesix/read#mixins">Mixins, Forwarding, and Delegation</a>, prototypes that are brought into proximity with each other (by placing them anywhere in the same chain, or by mixing them into the same object) become deeply coupled because they both have complete access to an object’s private internal state through <code>this</code>.</p>

<p>To reduce this coupling, we have to find a way to insulate prototypes from each other. Techniques like forwarding, while straightforward to use directly on an object or through a singleton prototype, require special handling when used in a shared prototype.</p>

<p>We’ll discuss this at more length when we look at classes.</p>

<div class="footnotes">
  <ol>
    <li id="fn-shadowbecomeswhite">
<a href="http://www.flickr.com/photos/31383674@N00/10529091736">Krups Machines</a> (c) 2010 Shadow Becomes White, <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">some rights reserved</a><a href="https://leanpub.com/javascriptallongesix/read#fnref-shadowbecomeswhite" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-decaffeinated-impostors">Decaffeinated: Impostors</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/decaf-espresso.jpg" alt="Decaf espresso">
  <figcaption>Decaf espresso</figcaption>
</figure>


<p>Now that we’ve explored objects in some depth, it’s time to acknowledge something that even small children know: Everything in JavaScript behaves like an object, everything in JavaScript behaves like an instance of a function, and therefore everything in JavaScript behaves as if it inherits some methods from a prototype and/or has some elements of its own.</p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="mf">3.14159265</code><code class="p">.</code><code class="nx">toPrecision</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
  <code class="c1">//=&gt; '3.1415'</code>
  
<code class="s1">'FORTRAN, SNOBOL, LISP, BASIC'</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">', '</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 'FORTRAN',</code>
  <code class="err">#</code>     <code class="s1">'SNOBOL'</code><code class="p">,</code>
  <code class="err">#</code>     <code class="s1">'LISP'</code><code class="p">,</code>
  <code class="err">#</code>     <code class="s1">'BASIC'</code> <code class="p">]</code>
  
<code class="p">[</code> <code class="s1">'FORTRAN'</code><code class="p">,</code>
  <code class="s1">'SNOBOL'</code><code class="p">,</code>
  <code class="s1">'LISP'</code><code class="p">,</code>
  <code class="s1">'BASIC'</code> <code class="p">].</code><code class="nx">length</code>
<code class="c1">//=&gt; 4</code>
</pre></div>

</figure>

<p>Functions themselves are instances, and they have methods. For example, every function has a method <code>call</code>. <code>call</code>’s first argument is a <em>context</em>: When you invoke <code>.call</code> on a function, it invoked the function, setting <code>this</code> to the context. It passes the remainder of the arguments to the function. It seems like objects are everywhere in JavaScript!</p>

<p>You may have noticed that we use “weasel words” to describe how everything in JavaScript <em>behaves like</em> an object. Everything <em>behaves as if</em> it delegates behaviour to a prototype.</p>

<p>The full explanation is this: As you know, JavaScript has “value types” like <code>String</code>, <code>Number</code>, and <code>Boolean</code>. As noted in the first chapter, value types are also called <em>primitives</em>, and one consequence of the way JavaScript implements primitives is that they aren’t objects. Which means they can be identical to other values of the same type with the same contents, but the consequence of certain design decisions is that value types don’t actually have methods or prototypes.</p>

<p>So. Value types don’t have methods or prototypes. And yet:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s2">"Spence Olham"</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">' '</code><code class="p">)</code>
  <code class="c1">//=&gt; ["Spence", "Olham"]</code>
</pre></div>

</figure>

<p>Somehow, when we write <code>"Spence Olham".split(' ')</code>, the string <code>"Spence Olham"</code> isn’t an object, it doesn’t have methods, but it does a damn fine job of impersonating an object with a <code>String</code> prototype. How does <code>"Spence Olham"</code> impersonate an object?</p>

<p>JavaScript pulls some legerdemain. When you do something that treats a value like an object, JavaScript checks to see whether the value actually is an object. If the value is actually a primitive,<sup id="fnref-reminder"><a href="https://leanpub.com/javascriptallongesix/read#fn-reminder" rel="footnote">1</a></sup> JavaScript temporarily makes an object that is a kinda-sorta copy of the primitive and that kinda-sorta copy has methods and you are temporarily fooled into thinking that <code>"Spence Olham"</code> has a <code>.split</code> method.</p>

<p>These kinda-sorta copies are called String <em>instances</em> as opposed to String <em>primitives</em>. And the instances have methods, while the primitives do not. How does JavaScript make an instance out of a primitive? With <code>new</code>, of course.<sup id="fnref-later"><a href="https://leanpub.com/javascriptallongesix/read#fn-later" rel="footnote">2</a></sup> Let’s try it:</p>

<p>The string instance looks just like our string primitive. But does it behave like a string primitive? Not entirely:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">new</code> <code class="nb">String</code><code class="p">(</code><code class="s2">"Spence Olham"</code><code class="p">)</code> <code class="o">===</code> <code class="s2">"Spence Olham"</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Aha! It’s an object with its own identity, unlike string primitives that behave as if they have a canonical representation. If we didn’t care about their identity, that wouldn’t be a problem. But if we carelessly used a string instance where we thought we had a string primitive, we could run into a subtle bug:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">if</code> <code class="p">(</code><code class="nx">userName</code> <code class="o">===</code> <code class="s2">"Spence Olham"</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">getMarried</code><code class="p">();</code>
  <code class="nx">goCamping</code><code class="p">()</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>That code is not going to work as we expect should we accidentally bind <code>new String("Spence Olham")</code> to <code>userName</code> instead of the primitive <code>"Spence Olham"</code>.</p>

<p>This basic issue that instances have unique identities but primitives with the same contents have the same identities–is true of all primitive types, including numbers and booleans: If you create an instance of anything with <code>new</code>, it gets its own identity.</p>

<p>There are more pitfalls to beware. Consider the truthiness of string, number and boolean primitives:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s1">''</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'falsy'</code>
<code class="mi">0</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'falsy'</code>
<code class="kc">false</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'falsy'</code>
</pre></div>

</figure>

<p>Compare this to their corresponding instances:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">new</code> <code class="nb">String</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'truthy'</code>
<code class="k">new</code> <code class="nb">Number</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'truthy'</code>
<code class="k">new</code> <code class="nb">Boolean</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code> <code class="o">?</code> <code class="s1">'truthy'</code> <code class="o">:</code> <code class="s1">'falsy'</code>
  <code class="c1">//=&gt; 'truthy'</code>
</pre></div>

</figure>

<p>Our notion of “truthiness” and “falsiness” is that all instances are truthy, even string, number, and boolean instances corresponding to primitives that are falsy.</p>

<p>There is one sure cure for “JavaScript Impostor Syndrome.” Just as <code>new PrimitiveType(...)</code> creates an instance that is an impostor of a primitive, <code>PrimitiveType(...)</code> creates an original, canonicalized primitive from a primitive or an instance of a primitive object.</p>

<p>For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">String</code><code class="p">(</code><code class="k">new</code> <code class="nb">String</code><code class="p">(</code><code class="s2">"Spence Olham"</code><code class="p">))</code> <code class="o">===</code> <code class="s2">"Spence Olham"</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Getting clever, we can write this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">unknown</code><code class="p">.</code><code class="nx">constructor</code><code class="p">(</code><code class="nx">unknown</code><code class="p">)</code>
<code class="p">}</code>
    
<code class="nx">original</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="o">===</code> <code class="kc">true</code>
  <code class="c1">//=&gt; true</code>
<code class="nx">original</code><code class="p">(</code><code class="k">new</code> <code class="nb">Boolean</code><code class="p">(</code><code class="kc">true</code><code class="p">))</code> <code class="o">===</code> <code class="kc">true</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Of course, <code>original</code> will not work for your own creations unless you take great care to emulate the same behaviour. But it does work for strings, numbers, and booleans.</p>

<div class="footnotes">
  <ol>
    <li id="fn-reminder">Recall that Strings, Numbers, Booleans and so forth are value types and primitives. We’re calling them primitives here.<a href="https://leanpub.com/javascriptallongesix/read#fnref-reminder" rel="rev-footnote">↩</a>
</li>
    <li id="fn-later">We’ll read all about the <code>new</code> keyword in <a href="https://leanpub.com/javascriptallongesix/read#new">COnstructors and <code>new</code></a>.
      <p>new String(“Spence Olham”)
  //⇒ “Spence Olham”<a href="https://leanpub.com/javascriptallongesix/read#fnref-later" rel="rev-footnote">↩</a></p>
    </li>
  </ol>
</div>


<h2 id="classes">Finish the Cup: Constructors and Classes</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/beans1.jpg" alt="Other languages call their objects &quot;beans,&quot; but serve extra-weak coffee in an attempt to be all things to all people">
  <figcaption>Other languages call their objects “beans,” but serve extra-weak coffee in an attempt to be all things to all people</figcaption>
</figure>


<p>As discussed in <a href="https://leanpub.com/javascriptallongesix/read#encapsulation">Encapsulating State</a>, JavaScript objects are very simple, yet the combination of objects, functions, and closures can create powerful data structures. We’ve also seen how to use <a href="https://leanpub.com/javascriptallongesix/read#metaobjects">Metaobjects</a> to separate behaviour from domain properties, and to share functionality amongst many different objects. And finally, we saw that one particular type of metaobject, a <em>prototype</em>, provides us with a robust model for delegation.</p>

<p>In this section, we will return to prototypes, and see how to use JavaScript’s <code>class</code> keyword to write one style of “object-oriented” JavaScript.</p>

<h3 id="new">Constructors and <code>new</code>
</h3>

<p>Let’s strip a function down to the bare essentials:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Ur</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>
</pre></div>

</figure>

<p>Or the equivalent:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Ur</code> <code class="p">()</code> <code class="p">{};</code>
</pre></div>

</figure>

<p>This doesn’t look like it has anything to do with objects and constructing things: It doesn’t have an expression that yields a Plain Old JavaScript Object when the function is applied. Yet, there is a way to make an object out of it. Behold the power of the <code>new</code> keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">new</code> <code class="nx">Ur</code><code class="p">()</code>
  <code class="c1">//=&gt; {}</code>
</pre></div>

</figure>

<p>We got an object back! What can we find out about this object?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">new</code> <code class="nx">Ur</code><code class="p">()</code> <code class="o">===</code> <code class="k">new</code> <code class="nx">Ur</code><code class="p">()</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Every time we call <code>new</code> with a function and get an object back, we get a unique object. We could call these “Objects created with the <code>new</code> keyword,” but this would be cumbersome. So we’re going to call them <em>instances</em>. Instances of what? Instances of the function that creates them. So given <code>const i = new Ur()</code>, we say that <code>i</code> is an instance of <code>Ur</code>.</p>

<p>We also say that <code>Ur</code> is the <em>constructor</em> of <code>i</code>, and that <code>Ur</code> is a <em>constructor function</em>. Therefore, an instance is an object created by using the <code>new</code> keyword on a constructor function, and that function is the instance’s constructor.</p>

<blockquote>
  <p>An instance is an object created by using the <code>new</code> keyword on a constructor function, and that function is the instance’s constructor.</p>
</blockquote>

<h4 id="leanpub-auto-constructors-instances-and-prototypes">constructors, instances, and prototypes</h4>

<p>There’s more. Here’s something you may not know about functions, every function has a <code>.prototype</code> property by default:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code>
  <code class="c1">//=&gt; {}</code>
</pre></div>

</figure>

<p>We remember <a href="https://leanpub.com/javascriptallongesix/read#prototypes">prototypes</a>. What do we know about the prototype property of every function? Let’s run our standard test:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{}).</code><code class="nx">prototype</code> <code class="o">===</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{}).</code><code class="nx">prototype</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Every function is initialized with its own unique value for the <code>.prototype</code> property. What does it do? Is it related to the prototypes we saw with Metaobjects? Let’s try something:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">language</code> <code class="o">=</code> <code class="s1">'JavaScript'</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">continent</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Ur</code><code class="p">();</code>
  <code class="c1">//=&gt; {}</code>
<code class="nx">continent</code><code class="p">.</code><code class="nx">language</code>
  <code class="c1">//=&gt; 'JavaScript'</code>
</pre></div>

</figure>

<p>That’s very interesting! Instances seem to behave as if they <em>delegate</em> to their constructors prototype, just as if we’d created them using <code>Object.create(Ur.prototype)</code>.</p>

<p>We can actually test this directly:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">continent</code><code class="p">)</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>And we can inspect the prototype of our <code>continent</code> directly:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">continent</code><code class="p">)</code> <code class="o">===</code> <code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Let’s try a few things:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">continent</code><code class="p">.</code><code class="nx">language</code> <code class="o">=</code> <code class="s1">'CoffeeScript'</code><code class="p">;</code>
<code class="nx">continent</code>
  <code class="c1">//=&gt; {language: 'CoffeeScript'}</code>
<code class="nx">continent</code><code class="p">.</code><code class="nx">language</code>
  <code class="c1">//=&gt; 'CoffeeScript'</code>
<code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">language</code>
  <code class="s1">'JavaScript'</code>
</pre></div>

</figure>

<p>You can set elements of an instance, and they “override” the constructor’s prototype, but they don’t actually change the constructor’s prototype. Let’s make another instance and try something else.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">another</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Ur</code><code class="p">();</code>
  <code class="c1">//=&gt; {}</code>
<code class="nx">another</code><code class="p">.</code><code class="nx">language</code>
  <code class="c1">//=&gt; 'JavaScript'</code>
</pre></div>

</figure>

<p>New instances don’t acquire any changes made to other instances. Makes sense. And:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">language</code> <code class="o">=</code> <code class="s1">'Sumerian'</code>
<code class="nx">another</code><code class="p">.</code><code class="nx">language</code>
  <code class="c1">//=&gt; 'Sumerian'</code>
</pre></div>

</figure>

<p>Even more interesting: Changing the constructor’s prototype changes the behaviour of all of its instances. This <em>is</em> the prototype/delegation relationship we have already seen with <code>Object.create</code>.</p>

<p>Speaking of prototypes, here’s something else that’s very interesting:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">continent</code><code class="p">.</code><code class="nx">constructor</code>
  <code class="c1">//=&gt; [Function]</code>

<code class="nx">continent</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">===</code> <code class="nx">Ur</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Every instance we create with <code>new</code> acquires a <code>constructor</code> element that is initialized to their constructor function. Objects we don’t create with <code>new</code> still have a <code>constructor</code> element, it’s a built-in function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">{}.</code><code class="nx">constructor</code>
  <code class="c1">//=&gt; [Function: Object]</code>
</pre></div>

</figure>

<p>If that’s true, what about prototypes? Do they have constructors?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code>
  <code class="c1">//=&gt; [Function]</code>
<code class="nx">Ur</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">===</code> <code class="nx">Ur</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Very interesting!</p>

<h4 id="leanpub-auto-revisiting-this-idea-of-queues">revisiting <code>this</code> idea of queues</h4>

<p>Let’s rewrite our Queue to use <code>new</code> and <code>.prototype</code>, using <code>this</code> and <code>Object.assign</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
  <code class="p">})</code>
<code class="p">};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">},</code>
  <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">value</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>You recall that when we first looked at <code>this</code>, we only covered the case where a function that belongs to an object is invoked. Now we see another case: When a function is invoked by the <code>new</code> operator, <code>this</code> is set to the new object being created. Thus, our code for <code>Queue</code> initializes the queue.</p>

<p>You can see why <code>this</code> is so handy in JavaScript: We wouldn’t be able to define functions in the prototype that worked on the instance if JavaScript didn’t give us an easy way to refer to the instance itself.</p>

<h4 id="leanpub-auto-how-do-constructors-compare-to-objectcreate">how do constructors compare to <code>Object.create</code>?</h4>

<p>Let’s summarize what we know:</p>

<p>When we use the <code>new</code> keyword with a function, we <em>construct</em> an object. The function is called with its context (<code>this</code>) set to the new object, and the new object delegates behaviour to whatever object is in the function’s <code>.prototype</code> property.</p>

<p>When we use <code>Object.create</code>, we create a new object and that object delegates its behaviour to whatever object we pass to <code>Object.create</code>. If we want to do any other initialization with the object, we can do that in a separate step.</p>

<p>Roughly speaking, we could use <code>Object.create</code> to emulate the obvious features of the <code>new</code> keyword. Let’s try it. We’ll start with <code>worksLikeNew</code>, a function that takes a constructor and some optional arguments, and acts like the <code>new</code> keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">worksLikeNew</code> <code class="p">(</code><code class="nx">constructor</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instance</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>

  <code class="nx">instance</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">=</code> <code class="nx">constructor</code><code class="p">;</code>

  <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">constructor</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">instance</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

  <code class="k">return</code> <code class="nx">result</code> <code class="o">===</code> <code class="kc">undefined</code> <code class="o">?</code> <code class="nx">instance</code> <code class="o">:</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">NamedContinent</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">NamedContinent</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">description</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`A continent named "</code><code class="err">\</code><code class="sb"></code>
<code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">"`</code> <code class="p">};</code>

<code class="kr">const</code> <code class="nx">na</code> <code class="o">=</code> <code class="nx">worksLikeNew</code><code class="p">(</code><code class="nx">NamedContinent</code><code class="p">,</code> <code class="s2">"North America"</code><code class="p">);</code>

<code class="nx">na</code><code class="p">.</code><code class="nx">description</code><code class="p">()</code>
  <code class="c1">//=&gt; A continent named "North America"</code>
</pre></div>

</figure>

<p>So do we <em>need</em> the <code>new</code> keyword, given that we can emulate it? Well, one could argue that we don’t <em>need</em> multiplication for positive integers:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">times</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">a</code> <code class="o">===</code> <code class="mi">0</code>
    <code class="o">?</code> <code class="mi">0</code>
    <code class="o">:</code> <code class="nx">b</code> <code class="o">+</code> <code class="nx">times</code><code class="p">(</code><code class="nx">a</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="nx">b</code><code class="p">);</code>
</pre></div>

</figure>

<p>Programming is a process of choosing and making abstractions, and combining constructor functions with the <code>new</code> keyword provides a single abstraction that handles several duties:</p>

<ul>
  <li>The constructor’s prototype provides a metaobject for describing the behaviour of every instance created with the constructor.</li>
  <li>The <code>.constructor</code> property of each instance provides an identifier for associating instances with constructors.</li>
  <li>The constructor’s own code provides initialization for each instance.</li>
</ul>

<p>We can do all these things with <code>Object.create</code>, but if we want to do exactly these things, and little else, <code>new</code> and a constructor function are easier, simpler, and familiar at a glance to other JavaScript programmers.</p>

<p>But when we want to do more, or different things, it might be better to use <code>Object.create</code> directly.</p>

<h3 id="leanpub-auto-why-classes-in-javascript">Why Classes in JavaScript?</h3>

<p>JavaScript programmers have been using constructors for a very long time. Long enough to notice several drawbacks with them:</p>

<ol class="numeric">
  <li>There are too many “moving parts.” Why is it necessary to define a constructor function, then manipulate its <code>prototype</code> property in a separate step?</li>
  <li>Why is chaining prototypes so complicated?</li>
</ol>

<p>Experienced JavaScript programmers generally responded by moving in either of two directions: Some programmers noticed that working directly with prototypes was simpler than doing everything with constructors, and gravitated towards using <code>Object.create</code> directly, using the techniques we’ve discussed in the section on <a href="https://leanpub.com/javascriptallongesix/read#metaobjects">Metaobjects</a>.</p>

<p>This approach is more flexible and powerful than using constructors, however it often seems <em>unfamiliar</em> to people who have been taught that objects should always be associated with a hierarchy of classes.</p>

<h4 id="leanpub-auto-abstractioneering">abstractioneering</h4>

<p>Other experienced JavaScript programmers embraced classes, but paved over the awkwardness of constructors and prototypes by building their own class abstractions. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">clazz</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">superclazz</code><code class="p">,</code> <code class="nx">properties</code><code class="p">,</code> <code class="nx">constructor</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">[</code><code class="nx">superclazz</code><code class="p">,</code> <code class="nx">properties</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nb">Object</code><code class="p">,</code> <code class="nx">args</code><code class="p">[</code><code class="mi">0</code><code class="p">]];</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="p">[</code><code class="nx">superclazz</code><code class="p">,</code> <code class="nx">properties</code><code class="p">]</code> <code class="o">=</code> <code class="nx">args</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="nx">properties</code><code class="p">.</code><code class="nx">constructor</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">constructor</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">properties</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">else</code> <code class="nx">constructor</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>

  <code class="nx">constructor</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">superclazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">properties</code><code class="p">);</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code>
    <code class="nx">constructor</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code>
    <code class="s1">'constructor'</code><code class="p">,</code>
    <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">constructor</code> <code class="p">}</code>
  <code class="p">);</code>

  <code class="k">return</code> <code class="nx">constructor</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>With this <code>clazz</code> function, we can write a <code>Queue</code> like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
      <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
    <code class="p">});</code>
  <code class="p">},</code>
  <code class="nx">pushTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">},</code>
  <code class="nx">pullHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>And we can write a <code>Dequeue</code> that “subclasses” a <code>Queue</code> like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Dequeue</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Queue</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>
  <code class="p">},</code>
  <code class="nx">size</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+</code> <code class="mi">1</code>
  <code class="p">},</code>
  <code class="nx">pullTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">];</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">pushHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">;</code> <code class="o">--</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code><code class="p">]</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
      <code class="p">}</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code>
    <code class="p">}</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="nx">Dequeue</code><code class="p">.</code><code class="nx">INCREMENT</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
</pre></div>

</figure>

<p>Chaining prototypes is handled for us, and we can set up the constructor function and the prototype’s methods in one step. And there’s a lot to be said for making “classes” out of prototypes. Because prototypes are “just objects,” and methods are “just functions,” we can re-use a lot of the techniques we’ve already developed for objects and functions with our prototypes and methods.</p>

<h4 id="prototype-is-a-win">why prototypes being objects is a win</h4>

<p>For example, we can use <code>Object.assign</code> to mix functionality into our classes:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">HasManager</code> <code class="o">=</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">setManager</code> <code class="p">(</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">removeManager</code><code class="p">();</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="nx">manager</code><code class="p">;</code>
    <code class="nx">manager</code><code class="p">.</code><code class="nx">addReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">removeManager</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">.</code><code class="nx">removeReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Manager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">addReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">removeReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">reports</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">MiddleManager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Manager</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Manager</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">});</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">MiddleManager</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">HasManager</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">Worker</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">});</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Worker</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">HasManager</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or even more declaratively:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">HasManager</code> <code class="o">=</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">setManager</code> <code class="p">(</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">removeManager</code><code class="p">();</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="nx">manager</code><code class="p">;</code>
    <code class="nx">manager</code><code class="p">.</code><code class="nx">addReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">removeManager</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">.</code><code class="nx">removeReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">Manager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">addReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">removeReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">reports</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">MiddleManager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Manager</code><code class="p">,</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Manager</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">HasManager</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">Worker</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">HasManager</code><code class="p">));</code>
</pre></div>

</figure>

<p>Likewise, decorating methods is as easy with these “classes” as it is with any other method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fluent</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodBody</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">methodBody</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">Manager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">addReport</code><code class="o">:</code> <code class="nx">fluent</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
  <code class="p">}),</code>
  <code class="nx">removeReport</code><code class="o">:</code> <code class="nx">fluent</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
  <code class="p">}),</code>
  <code class="kd">function</code> <code class="nx">reports</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">MiddleManager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Manager</code><code class="p">,</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Manager</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">HasManager</code><code class="p">));</code>

<code class="kr">const</code> <code class="nx">Worker</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="nx">HasManager</code><code class="p">));</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-the-problem-with-rolling-our-own-classes">the problem with rolling our own classes</h4>

<p>Building abstractions is a fundamental activity in programming. So it is not wrong to take basic tools like prototypes and build upwards from them.</p>

<p>However.
JavaScript is a simple and elegant language, and being able to write something like <code>clazz</code> in 20-ish lines of code is wonderful. It is not a hardship to read 20 lines of code to figure out how something works. Unless you have to read twenty lines of code every time you read a new program.</p>

<p>If everyone, or a very large number of people, are building roughly the same abstractions, but doing them in slightly different ways, each program is nice, but the ecosystem as a whole is a mess. Every time we read a new program, we have to figure out whether they are using raw constructors, rolling their own class abstraction, or using classes from various libraries.</p>

<p>For this reason (and perhaps others), the <code>class</code> keyword was added to the JavaScript language.</p>

<h3 id="leanpub-auto-classes-with-class">Classes with <code>class</code>
</h3>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/vacuum-upper.jpg" alt="Vac Pot Upper Chamber">
  <figcaption>Vac Pot Upper Chamber</figcaption>
</figure>


<p>JavaScript now has a simple way to write a “class.” Here’s a simple class written with <code>clazz</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
    <code class="p">},</code>
  <code class="nx">fullName</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">rename</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>And here it is with the <code>class</code> keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>And here’s a <code>Dequeue</code> to show “inheritance:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Dequeue</code> <code class="kr">extends</code> <code class="nx">Queue</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>
  <code class="p">},</code>
  <code class="nx">size</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+</code> <code class="mi">1</code>
  <code class="p">},</code>
  <code class="nx">pullTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">];</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">pushHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">;</code> <code class="o">--</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code><code class="p">]</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>
      <code class="p">}</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">INCREMENT</code>
    <code class="p">}</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">-=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="nx">Dequeue</code><code class="p">.</code><code class="nx">INCREMENT</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
</pre></div>

</figure>

<p>The interesting thing about <code>Dequeue</code> is that it works whether we write our <code>Queue</code> like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Queue</code> <code class="p">()</code> <code class="p">{</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
  <code class="p">});</code>
<code class="p">}</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Queue</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">pushTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">},</code>
  <code class="nx">pullHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Or like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Queue</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">({</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
      <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
    <code class="p">});</code>
  <code class="p">},</code>
  <code class="nx">pushTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">},</code>
  <code class="nx">pullHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="nx">isEmpty</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>Or even like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Queue</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
      <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
      <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code>
    <code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">pushTail</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
  <code class="p">}</code>
  <code class="nx">pullHead</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">isEmpty</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">isEmpty</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>It turns out that “classes” in JavaScript are fully compatible with constructors and prototypes. That’s because behind the scenes, <em>they’re almost indistinguishable</em>. In basic use, the <code>class</code> keyword is syntactic sugar for writing constructor functions with prototypes.</p>

<p>There is some extra magic for handling <code>super</code> (and a few other nice-to-have features like getters and setters), but by design, and to maximize compatibility with existing code bases, the <code>class</code> keyword is a declarative way to write functions and prototypes.</p>

<h4 id="leanpub-auto-classes-are-values">classes are values</h4>

<p>When we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>It looks like we are creating a global class named <code>Person</code>. Some other languages sometimes have this idea that class names have a special significance and that they’re always global, although you can namespace them in certain ways, and the mechanism behind class names and namespaces if different than the mechanism behind variable bindings.</p>

<p>JavaScript does not do this. <code>Person</code> is a name bound in the environment where we evaluate the code. So yes, at the topmost level, that code creates a global binding.</p>

<p>But we could also write something like this, taking advantage of <a href="https://leanpub.com/javascriptallongesix/read#privacy-with-symbols">privacy with symbols</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">PrivatePerson</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'firstName),</code>
<code class="s1">        lastName  = Symbol('</code><code class="nx">lastName</code><code class="err">'</code><code class="p">);</code>

  <code class="k">return</code> <code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
    <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
      <code class="o">++</code><code class="nx">population</code><code class="p">;</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">];</code>
    <code class="p">}</code>
    <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">})();</code>
</pre></div>

</figure>

<p>What does this do? It creates some symbols, then creates a class (also named person) within the same environment and uses those symbols to create private properties. It then returns the newly created class, which we bind to the name <code>PrivatePerson</code>. This hides the symbols <code>firstName</code> and <code>lastName</code> from other code.</p>

<p>Notice also that we <em>returned</em> the class. This implies (correctly) that the <code>class</code> keyword creates a <em>class expression</em>, and an expression is a value that can be used everywhere, just like a named function expression.</p>

<p>Of course, we could have bound the value returned from the IIFE to any name we like, even <code>Person</code>, but we give it a different name just to show that we have a value, just like any other value, and we bind it to a name in the environment, just like any other name in the environment. In this case, even the name <code>Person</code> is encapsulated within the IIFE.</p>

<p>In JavaScript, “classes” and “class expressions” are values just like any other value, and that means we can do anything with them that we can do with other values, like return them from functions, pass them to functions, and bind them to different names as we see fit.</p>

<h3 id="object-methods">Object Methods</h3>

<p>An <em>instance method</em> is a function defined in the constructor’s prototype. Every instance acquires this behaviour unless otherwise “overridden.” Instance methods usually have some interaction with the instance, such as references to <code>this</code> or to other methods that interact with the instance. A <em>constructor method</em> is a function belonging to the constructor itself.</p>

<p>There is a third kind of method, one that any object (obviously including all instances) can have. An <em>object method</em> is a function defined in the object itself. Like instance methods, object methods usually have some interaction with the object, such as references to <code>this</code> or to other methods that interact with the object.</p>

<p>Object methods are really easy to create with Plain Old JavaScript Objects, because they’re the only kind of method you can use. Recall from <a href="https://leanpub.com/javascriptallongesix/read#this">This and That</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BetterQueue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>
  <code class="p">({</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code> 
    <code class="nx">head</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> 
    <code class="nx">tail</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">pushTail</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">pullHead</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">];</code>
        
        <code class="k">this</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">head</code><code class="p">]</code> <code class="o">=</code> <code class="k">void</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">head</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="k">return</code> <code class="nx">value</code>
      <code class="p">}</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">tail</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">head</code>
    <code class="p">}</code>
  <code class="p">});</code>
</pre></div>

</figure>

<p><code>pushTail</code>, <code>pullHead</code>, and <code>isEmpty</code> are object methods. Also, from <a href="https://leanpub.com/javascriptallongesix/read#hiding-state">encapsulation</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">array</code><code class="o">:</code> <code class="p">[],</code>
    <code class="nx">index</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code>
    <code class="nx">push</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">,</code>
    <code class="nx">pop</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code><code class="p">];</code>
      
      <code class="nx">obj</code><code class="p">.</code><code class="nx">array</code><code class="p">[</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code><code class="p">]</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code> 
        <code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">-=</code> <code class="mi">1</code> 
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code>
    <code class="p">},</code>
    <code class="nx">isEmpty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">index</code> <code class="o">&lt;</code> <code class="mi">0</code>
  <code class="p">};</code>
  
  <code class="k">return</code> <code class="nx">obj</code><code class="p">;</code>
<code class="p">})();</code>
</pre></div>

</figure>

<p>Although they don’t refer to the object, <code>push</code>, <code>pop</code>, and <code>isEmpty</code> semantically interact with the opaque data structure represented by the object, so they are object methods too.</p>

<h4 id="leanpub-auto-object-methods-within-instances">object methods within instances</h4>

<p>Instances of constructors can have object methods as well. Typically, object methods are added in the constructor. Here’s a gratuitous example, a widget model that has a read-only <code>id</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">WidgetModel</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">attrs</code><code class="p">)</code> <code class="p">{</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">attrs</code> <code class="o">||</code> <code class="p">{});</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">id</code> <code class="p">}</code>
<code class="p">}</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">WidgetModel</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">set</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">attr</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">attr</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">get</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">attr</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">attr</code><code class="p">]</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p><code>set</code> and <code>get</code> are instance methods, but <code>id</code> is an object method: Each object has its own <code>id</code> closure, where <code>id</code> is bound to the id of the widget by the argument <code>id</code> in the constructor. The advantage of this approach is that instances can have different object methods, or object methods with their own closures as in this case. The disadvantage is that every object has its own methods, which uses up much more memory than instance methods, which are shared amongst all instances.</p>

<aside class="tip blurb">
    <p>Object methods are defined within the object. So if you have several different “instances” of the same object, there will be an object method for each object. Object methods can be associated with any object, not just those created with the <code>new</code> keyword. Instance methods apply  to instances, objects created with the <code>new</code> keyword. Instance methods are defined in a  prototype and are shared by all instances.</p>

</aside>

<h3 id="leanpub-auto-why-not-classes">Why Not Classes?</h3>

<p>Classes are popular, and if classes map neatly to the way we wish to model something, we should use them.</p>

<p>That being said, there are some caveats to understand.</p>

<h4 id="leanpub-auto-the-class-keyword-is-a-minimal-notation">the <code>class</code> keyword is a minimal notation</h4>

<p>By design, the <code>class</code> keyword provides the very minimum set of features needed to implement “classes.” Everything else must be done in some other way. For example, if you write constructors or prototypes directly, you can use method decorators (as we saw <a href="https://leanpub.com/javascriptallongesix/read#prototype-is-a-win">earlier</a>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fluent</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodBody</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">methodBody</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  
<code class="kr">const</code> <code class="nx">Manager</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">(</code><code class="nx">Person</code><code class="p">,</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Person</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">},</code>
  <code class="nx">addReport</code><code class="o">:</code> <code class="nx">fluent</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
  <code class="p">}),</code>
  <code class="nx">removeReport</code><code class="o">:</code> <code class="nx">fluent</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
  <code class="p">}),</code>
  <code class="nx">reports</code><code class="o">:</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>But at this time, you cannot use method decorators when you use the <code>class</code> syntax. There are plans to introduce a new, purpose-built decorator syntax for this purpose, which highlights one of the issues with the <code>class</code> syntax: By writing what amounts to a new language on top of JavaScript, it must inevitably reinvent all of the things that are already possible in JavaScript.</p>

<h4 id="leanpub-auto-classes-encourage-the-construction-of-class-hierarchies">classes encourage the construction of class hierarchies</h4>

<p>The easy thing to do with classes is to create <a href="https://en.wikipedia.org/wiki/Class_hierarchy">class hierarchies</a>. These are implemented by chaining prototypes. And there is a problem with chained prototypes: They couple classes to each other.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/tree.jpg" alt="A class hierarchy">
  <figcaption>A class hierarchy</figcaption>
</figure>


<p>When one class extends another, its methods can access any of the properties and methods defined anywhere on the prototype chain. Given hierarchies designed as trees, a change to a class can break the behaviour of any of the classes below it or above it on the tree.</p>

<p>When two or more metaobjects all have access to the same base object via <a href="https://en.wikipedia.org/wiki/Open_recursion#Open_recursion">open recursion</a>, they become tightly coupled because they can interact via setting and reading all the base object’s properties. It is impossible to restrict their interaction to a well-defined set of methods.</p>

<p>This coupling exists for all metaobject patterns that include open recursion, such as mixins, delegation, and delegation through prototypes. In particular, when chains of naive prototypes form class hierarchies, this coupling leads to the <a href="https://en.wikipedia.org/wiki/Fragile_base_class">fragile base class problem</a>.</p>

<aside class="information blurb">
    <p>The <strong>fragile base class problem</strong> is a fundamental architectural problem of object-oriented programming systems where base classes (superclasses) are considered “fragile” because seemingly safe modifications to a base class, when inherited by the derived classes, may cause the derived classes to malfunction. The programmer cannot determine whether a base class change is safe simply by examining in isolation the methods of the base class.–<a href="https://en.wikipedia.org/wiki/Fragile_base_class">Wikipedia</a></p>

</aside>

<p>In JavaScript, prototype chains are vulnerable because changes to one prototype’s behaviour may break another prototype’s behaviour in the same chain.</p>

<p>In the next section we will look at a technique for <a href="https://leanpub.com/javascriptallongesix/read#reducing%20coupling">reducing coupling between classes</a>. And we will look at avoiding deep hierarchies with mixins.</p>

<h3 id="leanpub-auto-summary-8">Summary</h3>

<aside class="tip blurb">
    <h4 id="leanpub-auto-instances-and-classes">Instances and Classes</h4>

  <ul>
    <li>The <code>new</code> keyword turns any function into a <em>constructor</em> for creating <em>instances</em>.</li>
    <li>All functions have a <code>prototype</code> element.</li>
    <li>Instances behave as if the elements of their constructor’s prototype are their elements.</li>
    <li>The <code>class</code> keyword acts as <em>syntactic sugar</em> for writing constructor functions.</li>
    <li>Classes created with the class keyword are actually constructor functions with optionally chained prototypes.</li>
    <li>Classes should be used in moderation, the syntax deliberately limits the flexibility and class hierarchies can lead to overly coupled code.</li>
  </ul>

</aside>

<h2 id="leanpub-auto-recipes-with-constructors-and-classes">Recipes with Constructors and Classes</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/diedrich-roaster.jpg" alt="These recipes are being roasted to perfection.">
  <figcaption>These recipes are being roasted to perfection.</figcaption>
</figure>


<h4 id="leanpub-auto-disclaimer-3">Disclaimer</h4>

<p>The recipes are written for practicality, and their implementation may introduce JavaScript features that haven’t been discussed in the text to this point, such as methods and/or prototypes. The overall <em>use</em> of each recipe will fit within the spirit of the language discussed so far, even if the implementations may not.</p>

<h3 id="bound">Bound</h3>

<p>Earlier, we saw a recipe for <a href="https://leanpub.com/javascriptallongesix/read#getWith">getWith</a> that plays nicely with properties:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">getWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">attr</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">object</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">object</code><code class="p">[</code><code class="nx">attr</code><code class="p">]</code>
</pre></div>

</figure>

<p>Simple and useful. But now that we’ve spent some time looking at objects with methods we can see that <code>get</code> (and <code>pluck</code>) has a failure mode. Specifically, it’s not very useful if we ever want to get a <em>method</em>, since we’ll lose the context. Consider some hypothetical class:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">InventoryRecord</code> <code class="p">(</code><code class="nx">apples</code><code class="p">,</code> <code class="nx">oranges</code><code class="p">,</code> <code class="nx">eggs</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">record</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">apples</code><code class="o">:</code> <code class="nx">apples</code><code class="p">,</code>
    <code class="nx">oranges</code><code class="o">:</code> <code class="nx">oranges</code><code class="p">,</code>
    <code class="nx">eggs</code><code class="o">:</code> <code class="nx">eggs</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">InventoryRecord</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">apples</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">apples</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">.</code><code class="nx">apples</code>
<code class="p">}</code>

<code class="nx">InventoryRecord</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">oranges</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">oranges</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">.</code><code class="nx">oranges</code>
<code class="p">}</code>

<code class="nx">InventoryRecord</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">eggs</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">eggs</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">.</code><code class="nx">eggs</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">inventories</code> <code class="o">=</code> <code class="p">[</code>
  <code class="k">new</code> <code class="nx">InventoryRecord</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">144</code><code class="p">,</code> <code class="mi">36</code> <code class="p">),</code>
  <code class="k">new</code> <code class="nx">InventoryRecord</code><code class="p">(</code> <code class="mi">240</code><code class="p">,</code> <code class="mi">54</code><code class="p">,</code> <code class="mi">12</code> <code class="p">),</code>
  <code class="k">new</code> <code class="nx">InventoryRecord</code><code class="p">(</code> <code class="mi">24</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">42</code> <code class="p">)</code>
<code class="p">];</code>
</pre></div>

</figure>

<p>Now how do we get all the egg counts?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">)</code>
  <code class="c1">//=&gt; [ [Function: eggs],</code>
  <code class="c1">//     [Function: eggs],</code>
  <code class="c1">//     [Function: eggs] ]</code>
</pre></div>

</figure>

<p>And if we try applying those functions…</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">getWith</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">unboundmethod</code> <code class="o">=&gt;</code> <code class="nx">unboundmethod</code><code class="p">()</code>
<code class="p">)</code>
  <code class="c1">//=&gt; TypeError: Cannot read property 'eggs' of undefined</code>
</pre></div>

</figure>

<p>It doesn’t work, because these are unbound methods we’re “getting” from each object. The context has been lost! Here’s a new version of <code>get</code> that plays nicely with methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">bound</code> <code class="o">=</code> <code class="p">(</code><code class="nx">messageName</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">args</code> <code class="o">===</code> <code class="p">[])</code>
    <code class="o">?</code> <code class="nx">instance</code> <code class="o">=&gt;</code> <code class="nx">instance</code><code class="p">[</code><code class="nx">messageName</code><code class="p">].</code><code class="nx">bind</code><code class="p">(</code><code class="nx">instance</code><code class="p">)</code>
    <code class="o">:</code> <code class="nx">instance</code> <code class="o">=&gt;</code> <code class="nb">Function</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">bind</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code>
                    <code class="nx">instance</code><code class="p">[</code><code class="nx">messageName</code><code class="p">],</code> <code class="p">[</code><code class="nx">instance</code><code class="p">].</code><code class="nx">concat</code><code class="p">(</code><code class="nx">args</code><code class="p">)</code>
                  <code class="p">);</code>

<code class="nx">mapWith</code><code class="p">(</code><code class="nx">bound</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">boundmethod</code> <code class="o">=&gt;</code>  <code class="nx">boundmethod</code><code class="p">()</code>
<code class="p">)</code>
  <code class="c1">//=&gt; [ 36, 12, 42 ]</code>
</pre></div>

</figure>

<p><code>bound</code> is the recipe for getting a bound method from an object by name. It has other uses, such as callbacks. <code>bound('render')(aView)</code> is equivalent to <code>aView.render.bind(aView)</code>. There’s an option to add a variable number of additional arguments, handled by:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">instance</code> <code class="o">=&gt;</code> <code class="nb">Function</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">bind</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code>
              <code class="nx">instance</code><code class="p">[</code><code class="nx">messageName</code><code class="p">],</code> <code class="p">[</code><code class="nx">instance</code><code class="p">].</code><code class="nx">concat</code><code class="p">(</code><code class="nx">args</code><code class="p">)</code>
            <code class="p">);</code>
</pre></div>

</figure>

<p>The exact behaviour will be covered in <a href="https://leanpub.com/javascriptallongesix/read#binding">Binding Functions to Contexts</a>. You can use it like this to add arguments to the bound function to be evaluated:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">InventoryRecord</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">add</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">item</code><code class="p">,</code> <code class="nx">amount</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">[</code><code class="nx">item</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">[</code><code class="nx">item</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">);</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">record</code><code class="p">[</code><code class="nx">item</code><code class="p">]</code> <code class="o">+=</code> <code class="nx">amount</code><code class="p">;</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">mapWith</code><code class="p">(</code><code class="nx">bound</code><code class="p">(</code><code class="s1">'add'</code><code class="p">,</code> <code class="s1">'eggs'</code><code class="p">,</code> <code class="mi">12</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">boundmethod</code> <code class="o">=&gt;</code> <code class="nx">boundmethod</code><code class="p">()</code>
<code class="p">)</code>
  <code class="c1">//=&gt; [ { record: </code>
  <code class="c1">//       { apples: 0,</code>
  <code class="c1">//         oranges: 144,</code>
  <code class="c1">//         eggs: 48 } },</code>
  <code class="c1">//     { record: </code>
  <code class="c1">//       { apples: 240,</code>
  <code class="c1">//         oranges: 54,</code>
  <code class="c1">//         eggs: 24 } },</code>
  <code class="c1">//     { record: </code>
  <code class="c1">//       { apples: 24,</code>
  <code class="c1">//         oranges: 12,</code>
  <code class="c1">//         eggs: 54 } } ]</code>
</pre></div>

</figure>

<h3 id="send">Send</h3>

<p>Previously, we saw that the recipe <a href="https://leanpub.com/javascriptallongesix/read#bound">bound</a> can be used to get a bound method from an instance. Unfortunately, invoking such methods is a little messy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">bound</code><code class="p">(</code><code class="s1">'eggs'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">boundmethod</code> <code class="o">=&gt;</code> <code class="nx">boundmethod</code><code class="p">()</code> 
<code class="p">)</code>
  <code class="c1">//=&gt; [ 36, 12, 42 ]</code>
</pre></div>

</figure>

<p>As we noted, it’s ugly to write</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">boundmethod</code> <code class="o">=&gt;</code> <code class="nx">boundmethod</code><code class="p">()</code>
</pre></div>

</figure>

<p>So instead, we write a new recipe:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">send</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">instance</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">instance</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

<code class="nx">mapWith</code><code class="p">(</code><code class="nx">send</code><code class="p">(</code><code class="s1">'apples'</code><code class="p">))(</code><code class="nx">inventories</code><code class="p">)</code>
  <code class="c1">//=&gt; [ 0, 240, 24 ]</code>
</pre></div>

</figure>

<p><code>send('apples')</code> works very much like <code>&amp;:apples</code> in the Ruby programming language. You may ask, why retain <code>bound</code>? Well, sometimes we want the function but don’t want to evaluate it immediately, such as when creating callbacks. <code>bound</code> does that well.</p>

<h3 id="invoke">Invoke</h3>

<p><a href="https://leanpub.com/javascriptallongesix/read#send">Send</a> is useful when invoking a function that’s a member of an object (or of an instance’s prototype). But we sometimes want to invoke a function that is designed to be executed within an object’s context. This happens most often when we want  to “borrow” a method from one “class” and use it on another object.</p>

<p>It’s not an unprecedented use case. The Ruby programming language has a handy feature called <a href="http://www.ruby-doc.org/core-1.8.7/Object.html#method-i-instance_exec">instance_exec</a>. It lets you execute an arbitrary block of code in the context of any object. Does this sound familiar? JavaScript has this exact feature, we just call it <code>.apply</code> (or <code>.call</code> as the case may be). We can execute any function in the context of any arbitrary object.</p>

<p>The only trouble with <code>.apply</code> is that being a method, it doesn’t compose nicely with other functions like combinators. So, we create a function that allows us to use it as a combinator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">invoke</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">instance</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">instance</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
</pre></div>

</figure>

<p>For example, let’s say someone else’s code gives you an array of objects that are in part, but not entirely like arrays. Something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code> <code class="mi">0</code><code class="o">:</code> <code class="s1">'zero'</code><code class="p">,</code> 
    <code class="mi">1</code><code class="o">:</code> <code class="s1">'one'</code><code class="p">,</code> 
    <code class="mi">2</code><code class="o">:</code> <code class="s1">'two'</code><code class="p">,</code>
    <code class="nx">length</code><code class="o">:</code> <code class="mi">3</code><code class="p">},</code>
  <code class="p">{</code> <code class="mi">0</code><code class="o">:</code> <code class="s1">'none'</code><code class="p">,</code>
    <code class="nx">length</code><code class="o">:</code> <code class="mi">1</code> <code class="p">},</code>
  <code class="c1">// ...</code>
<code class="p">];</code>
</pre></div>

</figure>

<p>If they were arrays, and we wanted to copy them, we would use:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">send</code><code class="p">(</code><code class="s1">'slice'</code><code class="p">,</code> <code class="mi">0</code><code class="p">))(</code><code class="nx">data</code><code class="p">)</code>
</pre></div>

</figure>

<p>Because arrays have a <code>.send</code> method. But our quasi-arrays have no such thing. So… We want to borrow the <code>.slice</code> method from arrays, but have it work on our data. <code>invoke([].slice, 0)</code> does the trick:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">mapWith</code><code class="p">(</code><code class="nx">invoke</code><code class="p">([].</code><code class="nx">slice</code><code class="p">,</code> <code class="mi">0</code><code class="p">))(</code><code class="nx">data</code><code class="p">)</code>
  <code class="c1">//=&gt; [</code>
         <code class="p">[</code><code class="s2">"zero"</code><code class="p">,</code><code class="s2">"one"</code><code class="p">,</code><code class="s2">"two"</code><code class="p">],</code>
         <code class="p">[</code><code class="s2">"none"</code><code class="p">],</code>
         <code class="c1">// ...</code>
       <code class="p">]</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-instance-eval">instance eval</h4>

<p><code>invoke</code> is useful when you have the function and are looking for the instance. It can be written “the other way around,” for when you have the instance and are looking for the function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">instanceEval</code> <code class="o">=</code> <code class="nx">instance</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">fn</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">instance</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
</pre></div>

</figure>

<h3 id="fluent">Fluent</h3>

<p>Object and instance methods can be bifurcated into two classes: Those that query something, and those that update something. Most design philosophies arrange things such that update methods return the value being updated. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Cake</code> <code class="p">{</code>
  <code class="nx">setFlavour</code> <code class="p">(</code><code class="nx">flavour</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">flavour</code> <code class="o">=</code> <code class="nx">flavour</code> 
  <code class="p">},</code>
  <code class="nx">setLayers</code> <code class="p">(</code><code class="nx">layers</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">layers</code> <code class="o">=</code> <code class="nx">layers</code> 
  <code class="p">},</code>
  <code class="nx">bake</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// do some baking</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">cake</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Cake</code><code class="p">();</code>
<code class="nx">cake</code><code class="p">.</code><code class="nx">setFlavour</code><code class="p">(</code><code class="s1">'chocolate'</code><code class="p">);</code>
<code class="nx">cake</code><code class="p">.</code><code class="nx">setLayers</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="nx">cake</code><code class="p">.</code><code class="nx">bake</code><code class="p">();</code>
</pre></div>

</figure>

<p>Having methods like <code>setFlavour</code> return the value being set mimics the behaviour of assignment, where <code>cake.flavour = 'chocolate'</code> is an expression that in addition to setting a property also evaluates to the value <code>'chocolate'</code>.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent</a> style presumes that most of the time when you perform an update, you are more interested in doing other things with the receiver than the values being passed as argument(s). Therefore, the rule is to return the receiver unless the method is a query:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Cake</code> <code class="p">{</code>
  <code class="nx">setFlavour</code> <code class="p">(</code><code class="nx">flavour</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">this</code><code class="p">.</code><code class="nx">flavour</code> <code class="o">=</code> <code class="nx">flavour</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">setLayers</code> <code class="p">(</code><code class="nx">layers</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">this</code><code class="p">.</code><code class="nx">layers</code> <code class="o">=</code> <code class="nx">layers</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">bake</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// do some baking</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The code to work with cakes is now easier to read and less repetitive:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">cake</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Cake</code><code class="p">().</code>
               <code class="nx">setFlavour</code><code class="p">(</code><code class="s1">'chocolate'</code><code class="p">).</code>
               <code class="nx">setLayers</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code>
               <code class="nx">bake</code><code class="p">();</code>
</pre></div>

</figure>

<p>For one-liners like setting a property, this is fine. But some functions are longer, and we want to signal the intent of the method at the top, not buried at the bottom. Normally this is done in the method’s name, but fluent interfaces are rarely written to include methods like <code>setLayersAndReturnThis</code>.</p>

<p>When we write our own prototypes, the <code>fluent</code> method decorator solves this problem:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fluent</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodBody</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">methodBody</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>Now you can write methods like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Cake</code> <code class="p">()</code> <code class="p">{}</code>

<code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setFlavour</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">flavour</code><code class="p">)</code> <code class="p">{</code> 
  <code class="k">this</code><code class="p">.</code><code class="nx">flavour</code> <code class="o">=</code> <code class="nx">flavour</code><code class="p">;</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>It’s obvious at a glance that this method is “fluent.”</p>

<p>When we use the <code>class</code> keyword, we can decorate functions in a similar manner:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Cake</code> <code class="p">{</code>
  <code class="nx">setFlavour</code> <code class="p">(</code><code class="nx">flavour</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">this</code><code class="p">.</code><code class="nx">flavour</code> <code class="o">=</code> <code class="nx">flavour</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">setLayers</code> <code class="p">(</code><code class="nx">layers</code><code class="p">)</code> <code class="p">{</code> 
    <code class="k">this</code><code class="p">.</code><code class="nx">layers</code> <code class="o">=</code> <code class="nx">layers</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">bake</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// do some baking</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setFlavour</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setFlavour</code><code class="p">);</code>
<code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setLayers</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setLayers</code><code class="p">);</code>
<code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">bake</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">Cake</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">bake</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or, we could write ourselves a slight variation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fluent</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodBody</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">methodBody</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">fluentClass</code> <code class="o">=</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">,</code> <code class="p">...</code><code class="nx">methodNames</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">methodName</code> <code class="k">of</code> <code class="nx">methodNames</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Now we can simply write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">fluentClass</code><code class="p">(</code><code class="nx">Cake</code><code class="p">,</code> <code class="s1">'setFlavour'</code><code class="p">,</code> <code class="s1">'setLayers'</code><code class="p">,</code> <code class="s1">'bake'</code><code class="p">);</code>
</pre></div>

</figure>

<h2 id="symmetry">Colourful Mugs: Symmetry, Colour, and Charm</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/pantone.jpg" alt="Pantone Coffee Mugs">
  <figcaption>Pantone Coffee Mugs</figcaption>
</figure>


<p>We’ve seen that functions are <em>first-class entities</em>. meaning, we can store them in data structures, pass them to other functions, and return them from functions. An amazing number of very strong programming techniques arise as a consequence of functions-as-first-class-entities.</p>

<p>We’ve also seen that we can use functions-as-first-class-entities to write decorators like <a href="https://leanpub.com/javascriptallongesix/read#maybe">maybe</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">arg</code> <code class="k">of</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">arg</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code> <code class="nx">arg</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>And <a href="https://leanpub.com/javascriptallongesix/read#combinators">combinators</a> like compose:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">x</code><code class="p">));</code>

<code class="nx">compose</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=&gt;</code> <code class="nx">y</code> <code class="o">*</code> <code class="nx">y</code><code class="p">)(</code><code class="mi">10</code><code class="p">)</code>
  <code class="c1">//=&gt; 101</code>
</pre></div>

</figure>

<p>The power arising from functions-as-first-class-entities is that we have a very flexible way to make functions out of functions, using functions. We are not “multiplying our entities unnecessarily.” On the surface, decorators and combinators are made possible by the fact that we can pass functions to functions, and return functions that invoke our original functions.</p>

<p>But there’s something else: The fact that all functions are called in the exact same way. We write <code>foo(bar)</code> and know that we will evaluate <code>bar</code>, and pass the resulting value to the function we get by evaluating <code>foo</code>. This allows us to write decorators and combinators that work with any function.</p>

<p>Or does it?</p>

<p>Imagine, if you will, that functions came in two colours: “blue,” and “yellow.” Now imagine that when we invoke a function in a variable, we type the name of the function in the proper colour. So if we write <code>const square = (x) =&gt; x * x</code> in blue code, we also have to write <code>square(5)</code> in blue code, so that <code>square</code> is always blue.</p>

<p>If we write <code>const square = (x) =&gt; x * x</code> in blue code, but elsewhere we write <code>square(5)</code> in yellow code, it won’t work because <code>square</code> is a blue function and <code>square(5)</code> would be a yellow invocation.</p>

<h4 id="leanpub-auto-blue-and-yellow-functions">blue and yellow functions</h4>

<p>If functions worked like that, decorators would be very messy. We’d have to make colour-coded decorators, like a blue <code>maybe</code> and a yellow <code>maybe</code>. We’d have to carefully track which functions have which colours, much as in gendered languages like French, you need to know the gender of all inanimate objects so that you can use the correct gendered grammar when talking about them.</p>

<p>This sounds bad, and for programming tools, it is.<sup id="fnref-french"><a href="https://leanpub.com/javascriptallongesix/read#fn-french" rel="footnote">1</a></sup> The general principle is: <em>Have fewer kinds of similar things, but allow the things you do have to combine in flexible ways</em>. You can’t just remove things, you have to also make it very easy to combine things. Functions as first-class-entities are a good example of this, because they allow you to combine functions in flexible ways.</p>

<p>Coloured functions would be an example of how not to do it, because you’d be making it harder to combine functions by balkanizing them.<sup id="fnref-colours"><a href="https://leanpub.com/javascriptallongesix/read#fn-colours" rel="footnote">2</a></sup></p>

<p>Functions don’t have colours in JavaScript. But there are things that have this kind of asymmetry that make things just as awkward. For example, methods in JavaScript are functions. But, when you invoke them, you have to get <code>this</code> set up correctly. You have to either:</p>

<ol class="numeric">
  <li>Invoke a method as a property of an object. e.g. <code>foo.bar(baz)</code> or <code>foo['bar'](baz)</code>.</li>
  <li>Bind an object to a method before invoking it, e.g. <code>bar.bind(foo)</code>.</li>
  <li>Invoke the method with with <code>.call</code> or <code>.apply</code>, e.g <code>bar.call(foo, baz)</code>.</li>
</ol>

<p>Thus, we can imagine that calling a function directly (e.g. <code>bar(baz)</code>) is blue, invoking a function and setting <code>this</code> (e.g. <code>bar.call(foo, baz)</code>) is yellow.</p>

<p>Or in other words, functions are blue, and methods are yellow.</p>

<h4 id="leanpub-auto-the-composability-problem">the composability problem</h4>

<p>We often write decorators in blue, a/k/a pure functional style. Here’s a decorator that makes a function throw an exception if its argument is not a finite number:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">requiresFinite</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nb">isFinite</code><code class="p">(</code><code class="nx">n</code><code class="p">)){</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">throw</code> <code class="s2">"Bad Wolf"</code><code class="p">;</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">plusOne</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>

<code class="nx">plus1</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">plus1</code><code class="p">([])</code>
  <code class="c1">//=&gt; 1 WTF!?</code>

<code class="kr">const</code> <code class="nx">safePlusOne</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">plusOne</code><code class="p">);</code>

<code class="nx">safePlusOne</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">safePlusOne</code><code class="p">([])</code>
  <code class="c1">//=&gt; throws "Bad Wolf"</code>
</pre></div>

</figure>

<p>But it won’t work on methods. Here’s a <code>Circle</code> class that has an unsafe <code>.scaleBy</code> method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Circle</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">radius</code> <code class="o">=</code> <code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">diameter</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">scaleBy</code> <code class="p">(</code><code class="nx">factor</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="nx">factor</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">two</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 37.69911184307752</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="kc">null</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 0 WTF!?</code>
</pre></div>

</figure>

<p>Let’s decorate the <code>scaleBy</code> method to check its argument:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">);</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="kc">null</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; throws "Bad Wolf"</code>
</pre></div>

</figure>

<p>Looks good, let’s put it into production:</p>
<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">);</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; undefined is not an object (evaluating 'this.radius')</code>
</pre></div>

</figure>

<p>Whoops, we forgot that method invocation is “yellow” code, so our “blue” <code>requiresFinite</code> decorator will not work on methods. This is the problem of “yellow” and “blue” code colliding.</p>

<h4 id="leanpub-auto-composing-functions-with-green-code">composing functions with “green” code</h4>

<p>Fortunately, we can write higher-order functions like decorators and combinators in a style that works for both “pure” functions and for methods. We have to use the <code>function</code> keyword so that <code>this</code> is bound, and then invoke our decorated function using <code>.call</code> so that we can pass <code>this</code> along.</p>

<p>Here’s <code>requiresFinite</code> written in this style, which we will call “green.” It works for decorating both methods <em>and</em> functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">requiresFinite</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nb">isFinite</code><code class="p">(</code><code class="nx">n</code><code class="p">)){</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">n</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">throw</code> <code class="s2">"Bad Wolf"</code><code class="p">;</code>
  <code class="p">}</code>

<code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">Circle</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">);</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 37.69911184307752</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">scaleBy</code><code class="p">(</code><code class="s2">"three"</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; throws "Bad Wolf"</code>

<code class="kr">const</code> <code class="nx">safePlusOne</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>

<code class="nx">safePlusOne</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="c1">//=&gt; 2</code>

<code class="nx">safePlusOne</code><code class="p">([])</code>
  <code class="c1">//=&gt; throws "Bad Wolf"</code>
</pre></div>

</figure>

<p>We can write all of our decorators and combinators in “green” style. For example, instead of writing <code>maybe</code> in functional (“blue”) style like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">arg</code> <code class="k">of</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">arg</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code> <code class="nx">arg</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>We can write it in both functional and method style (“green”) style like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">maybe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">arg</code> <code class="k">of</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">if</code> <code class="p">(</code><code class="nx">arg</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="k">return</code> <code class="nx">arg</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>And instead of writing our simple compose in functional (“blue”) style like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">(</code><code class="nx">x</code><code class="p">));</code>
</pre></div>

</figure>

<p>We can write it in both functional and method style (“green”) style like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">a</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">b</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">x</code><code class="p">));</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>What makes JavaScript tolerable is that green handling works for both  functional (“blue”) and method invocation (“yellow”) code. But when writing large code bases, we have to remain aware that some functions are blue and some are yellow, because if we write a mostly blue program, we could be lured into complacency with with blue decorators and combinators for years. But everything would break if a “yellow” method was introduced that didn’t play nicely with our blue combinators</p>

<p>The safe thing to do is to write all our higher-order functions in “green” style, so that they work for functions or methods. And that’s why we might talk about the simpler, “blue” form when introducing an idea, but we write out the more complete, “green” form when implementing it as a recipe.</p>

<h4 id="leanpub-auto-red-functions-vs-object-factories">red functions vs. object factories</h4>

<p>JavaScript classes (and the equivalent prototype-based patterns) rely on creating objects with the <code>new</code> keyword. As we saw in the example above:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Circle</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">radius</code> <code class="o">=</code> <code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">diameter</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">scaleBy</code> <code class="p">(</code><code class="nx">factor</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="nx">factor</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">round</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>

<code class="nx">round</code><code class="p">.</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 6.2831853</code>
</pre></div>

</figure>

<p>That <code>new</code> keyword introduces yet <em>another</em> colour of function, constructors are “red” functions. We can’t make circles using “blue” function calls:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">round2</code> <code class="o">=</code> <code class="nx">Circle</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
  <code class="c1">//=&gt; Cannot call a class as a function</code>

<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">Circle</code><code class="p">)</code>
  <code class="c1">//=&gt; Cannot call a class as a function</code>
</pre></div>

</figure>

<p>And we certainly can’t use a decorator on them:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">CircleRequiringFiniteRadius</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">Circle</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">round3</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">CircleRequiringFiniteRadius</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
  <code class="c1">//=&gt; Cannot call a class as a function</code>
</pre></div>

</figure>

<p>Some experienced developers dislike <code>new</code> because of this problem: It introduces one more kind of function that doesn’t compose neatly with other functions using our existing decorators and combinators.</p>

<p>We could eliminate “red” functions by using prototypes and <code>Object.create</code> instead of using the <code>class</code> and <code>new</code> keywords. A “factory function” is a function that makes new objects. So instead of writing a <code>Circle</code> class, we would write a <code>CirclePrototype</code> and a <code>CircleFactory</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">CirclePrototype</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">diameter</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">scaleBy</code> <code class="p">(</code><code class="nx">factor</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">CircleFactory</code><code class="p">(</code><code class="nx">factor</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">CircleFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">CirclePrototype</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">radius</code><code class="o">:</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">radius</code><code class="p">,</code> <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
  <code class="p">})</code>

<code class="nx">CircleFactory</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 37.69911184307752</code>
</pre></div>

</figure>

<p>Now we have a “blue” <code>CircleFactory</code> function, and we have the benefits of objects and methods, along with the benefits of decorating and composing factories like any other function. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">requiresFinite</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nb">isFinite</code><code class="p">(</code><code class="nx">n</code><code class="p">)){</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">n</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">throw</code> <code class="s2">"Bad Wolf"</code><code class="p">;</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">FiniteCircleFactory</code> <code class="o">=</code> <code class="nx">requiresFinite</code><code class="p">(</code><code class="nx">CircleFactory</code><code class="p">);</code>

<code class="nx">FiniteCircleFactory</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 37.69911184307752</code>

<code class="nx">FiniteCircleFactory</code><code class="p">(</code><code class="kc">null</code><code class="p">).</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; throws "Bad Wolf"</code>
</pre></div>

</figure>

<p>All that being said, programming with factory functions instead of with classes and <code>new</code> is not a cure-all. Besides losing some of the convenience and familiarity for other developers, we’d also have to use extreme discipline for fear that accidentally introducing some “red” classes would break our carefully crafted “blue in green” application.</p>

<p>In the end, there’s no avoiding the need to know which functions are functions, and which are actually classes. Tooling can help: Some linting applications can enforce a naming convention where classes start with an upper-case letter and functions start with a lower-case letter.</p>

<h4 id="leanpub-auto-charmed-functions">charmed functions</h4>

<p>Consider:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">likesToDrink</code> <code class="o">=</code> <code class="p">(</code><code class="nx">whom</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">whom</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">case</code> <code class="s1">'Bob'</code><code class="o">:</code>
      <code class="k">return</code> <code class="s1">'Ristretto'</code><code class="p">;</code>
    <code class="k">case</code> <code class="s1">'Carol'</code><code class="o">:</code>
      <code class="k">return</code> <code class="s1">'Cappuccino'</code><code class="p">;</code>
    <code class="k">case</code> <code class="s1">'Ted'</code><code class="o">:</code>
      <code class="k">return</code> <code class="s1">'Allongé'</code><code class="p">;</code>
    <code class="k">case</code> <code class="s1">'Alice'</code><code class="o">:</code>
      <code class="k">return</code> <code class="s1">'Cappuccino'</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">likesToDrink</code><code class="p">(</code><code class="s1">'Alice'</code><code class="p">)</code>
  <code class="c1">//=&gt; 'Cappuccino'</code>

<code class="nx">likesToDrink</code><code class="p">(</code><code class="s1">'Peter'</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined;</code>
</pre></div>

</figure>

<p>That’s a pretty straightforward function that implements a mapping from <code>Bob</code>, <code>Carol</code>, <code>Ted</code>, and <code>Alice</code> to the drinks ‘Ristretto’, ‘Cappuccino’, and ‘Allongé’. The mapping is encoded implicitly in the code’s <code>switch</code> statement.</p>

<p>We can use it in combination with other functions. For example, we can find out if the first letter of what someone likes is “c:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">startsWithC</code> <code class="o">=</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">something</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="sr">/^c/i</code><code class="p">)</code>

<code class="nx">startsWithC</code><code class="p">(</code><code class="nx">likesToDrink</code><code class="p">(</code><code class="s1">'Alice'</code><code class="p">))</code>
  <code class="c1">//=&gt; true</code>

<code class="kr">const</code> <code class="nx">likesSomethingStartingWithC</code> <code class="o">=</code>
  <code class="nx">compose</code><code class="p">(</code><code class="nx">startsWithC</code><code class="p">,</code> <code class="nx">likesToDrink</code><code class="p">);</code>

<code class="nx">likesSomethingStartingWithC</code><code class="p">(</code><code class="s1">'Ted'</code><code class="p">)</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>So far, that’s good, clean blue function work. But there’s yet another kind of “function call.” If you are a mathematician, this is a mapping too:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">personToDrink</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">Bob</code><code class="o">:</code> <code class="s1">'Ristretto'</code><code class="p">,</code>
  <code class="nx">Carol</code><code class="o">:</code> <code class="s1">'Cappuccino'</code><code class="p">,</code>
  <code class="nx">Ted</code><code class="o">:</code> <code class="s1">'Allongé'</code><code class="p">,</code>
  <code class="nx">Alice</code><code class="o">:</code> <code class="s1">'Cappuccino'</code>
<code class="p">}</code>

<code class="nx">personToDrink</code><code class="p">[</code><code class="s1">'Alice'</code><code class="p">]</code>
  <code class="c1">//=&gt; 'Cappuccino'</code>

<code class="nx">personToDrink</code><code class="p">[</code><code class="s1">'Ted'</code><code class="p">]</code>
  <code class="c1">//=&gt; 'Allongé'</code>
</pre></div>

</figure>

<p><code>personToDrink</code> also maps the names ‘Bob’, ‘Carol’, ‘Ted’, and ‘Alice’ to the drinks ‘Ristretto’, ‘Cappuccino’, and ‘Allongé’, just like <code>likesToDrink</code>. But even though it does the same thing as a function, we can’t use it as a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">personMapsToSomethingStartingWithC</code> <code class="o">=</code>
  <code class="nx">compose</code><code class="p">(</code><code class="nx">startsWithC</code><code class="p">,</code> <code class="nx">personToDrink</code><code class="p">);</code>

<code class="nx">personMapsToSomethingStartingWithC</code><code class="p">(</code><code class="s1">'Ted'</code><code class="p">)</code>
  <code class="c1">//=&gt; undefined is not a function (evaluating 'b.call(this, x)')</code>
</pre></div>

</figure>

<p>As you can see, <code>[</code> and <code>]</code> are a little like <code>(</code> and <code>)</code>, because we can pass <code>Alice</code> to <code>personToDrink</code> and get back <code>Cappuccino</code>. But they are just different enough, that we can’t write <code>personToDrink(...)</code>. Objects (as well as ECMAScript 2015 maps and sets) are “charmed functions.”</p>

<p>And you need a different piece of code to go with them. We’d need to write things like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">composeblueWithCharm</code> <code class="o">=</code>
  <code class="p">(</code><code class="nx">bluefunction</code><code class="p">,</code> <code class="nx">charmedfunction</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">bluefunction</code><code class="p">(</code><code class="nx">charmedfunction</code><code class="p">[</code><code class="nx">arg</code><code class="p">]);</code>

<code class="kr">const</code> <code class="nx">composeCharmWithblue</code> <code class="o">=</code>
  <code class="p">(</code><code class="nx">charmedfunction</code><code class="p">,</code> <code class="nx">bluefunction</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">arg</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="nx">charmedfunction</code><code class="p">[</code><code class="nx">bluefunction</code><code class="p">(</code><code class="nx">arg</code><code class="p">)]</code>

<code class="c1">// ...</code>
</pre></div>

</figure>

<p>That would get really old, really fast.</p>

<h4 id="leanpub-auto-adapting-to-handle-red-and-charmed-functions">adapting to handle red and charmed functions</h4>

<p>We can work our way around some of these cross-colour and charm issues by writing <em>adaptors</em>, wrappers that turn red and charmed functions into blue functions. As we saw above, a “factory function” is a function that is called in the normal way, and returns a freshly created object.</p>

<p>If we wanted to create a <code>CircleFactory</code>, we could use <code>Object.create</code> as we saw above. We could also wrap <code>new Circle(...)</code> in a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Circle</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">radius</code> <code class="o">=</code> <code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">diameter</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">scaleBy</code> <code class="p">(</code><code class="nx">factor</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="nx">factor</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">radius</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">CircleFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="k">new</code> <code class="nx">Circle</code><code class="p">(</code><code class="nx">radius</code><code class="p">);</code>

<code class="nx">CircleFactory</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">scaleBy</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 37.69911184307752</code>
</pre></div>

</figure>

<p>With some argument jiggery-pokery, we could abstract <code>Circle</code> from <code>CircleFactory</code> and make a factory for making factories, a <code>FactoryFactory</code>:</p>

<p>We would write a <code>CircleFactory</code> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">FactoryFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="k">new</code> <code class="nx">clazz</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">CircleFactory</code> <code class="o">=</code> <code class="nx">FactoryFactory</code><code class="p">(</code><code class="nx">Circle</code><code class="p">);</code>

<code class="nx">circleFactory</code><code class="p">(</code><code class="mi">5</code><code class="p">).</code><code class="nx">diameter</code><code class="p">()</code>
  <code class="c1">//=&gt; 31.4159265</code>
</pre></div>

</figure>

<p><code>FactoryFactory</code> turns any “red” class into a “blue” function. So we can use it any where we like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">FactoryFactory</code><code class="p">(</code><code class="nx">Circle</code><code class="p">))</code>
  <code class="c1">//=&gt;</code>
    <code class="p">[{</code><code class="s2">"radius"</code><code class="o">:</code><code class="mi">1</code><code class="p">},{</code><code class="s2">"radius"</code><code class="o">:</code><code class="mi">2</code><code class="p">},{</code><code class="s2">"radius"</code><code class="o">:</code><code class="mi">3</code><code class="p">},{</code><code class="s2">"radius"</code><code class="o">:</code><code class="mi">4</code><code class="p">},{</code><code class="s2">"radius"</code><code class="o">:</code><code class="mi">5</code><code class="p">}]</code>
</pre></div>

</figure>

<p>Sadly, we still have to remember that <code>Circle</code> is a class and be sure to wrap it in <code>FactoryFactory</code> when we need to use it as a function, but that does work.</p>

<p>We can do a similar thing with our “charmed” maps (and arrays, for that matter). Here’s <code>Dictionary</code>, a function that turns objects and arrays (our “charmed” functions) into ordinary (“blue”) functions:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Dictionary</code> <code class="o">=</code> <code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">data</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>

<code class="kr">const</code> <code class="nx">personToDrink</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">Bob</code><code class="o">:</code> <code class="s1">'Ristretto'</code><code class="p">,</code>
  <code class="nx">Carol</code><code class="o">:</code> <code class="s1">'Cappuccino'</code><code class="p">,</code>
  <code class="nx">Ted</code><code class="o">:</code> <code class="s1">'Allongé'</code><code class="p">,</code>
  <code class="nx">Alice</code><code class="o">:</code> <code class="s1">'Cappuccino'</code>
<code class="p">}</code>

<code class="p">[</code><code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'Ted'</code><code class="p">,</code> <code class="s1">'Carol'</code><code class="p">,</code> <code class="s1">'Alice'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">Dictionary</code><code class="p">(</code><code class="nx">personToDrink</code><code class="p">))</code>
  <code class="c1">//=&gt; ["Ristretto","Allongé","Cappuccino","Cappuccino"]</code>
</pre></div>

</figure>

<p><code>Dictionary</code> makes it easier for us to use all of the same tools for combining and manipulating functions on arrays and objects that we do with functions.</p>

<h4 id="leanpub-auto-dictionaries-as-proxies">dictionaries as proxies</h4>

<p>As <a href="http://swannodette.github.io/">David Nolen</a> has pointed out, languages like Clojure have maps that can be called as functions automatically. This is superior to wrapping a map in a plain function, because the underlying map is still available to be iterated over and otherwise treated as a map. Once we wrap a map in a function, it becomes opaque, useless for anything except calling as a function.</p>

<p>If we wish, we can create a dictionary function that is a partial proxy for the underlying collection object. For example, here is an <code>IterableDictionary</code> that turns a collection into a function that is also iterable if its underlying data object is iterable:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">IterableDictionary</code> <code class="o">=</code> <code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">data</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
  <code class="nx">proxy</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="o">*</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">yield</code> <code class="o">*</code> <code class="nx">data</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">](...</code><code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nx">proxy</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="nx">IterableDictionary</code><code class="p">([</code><code class="s1">'Bob'</code><code class="p">,</code> <code class="s1">'Ted'</code><code class="p">,</code> <code class="s1">'Carol'</code><code class="p">,</code> <code class="s1">'Alice'</code><code class="p">]);</code>
<code class="kr">const</code> <code class="nx">drinks</code> <code class="o">=</code> <code class="nx">IterableDictionary</code><code class="p">(</code><code class="nx">personToDrink</code><code class="p">);</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">name</code> <code class="k">of</code> <code class="nx">people</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> prefers to drink </code><code class="si">${</code><code class="nx">drinks</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">Bob</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Ristretto</code>
    <code class="nx">Ted</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Allongé</code>
    <code class="nx">Carol</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Cappuccino</code>
    <code class="nx">Alice</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Cappuccino</code>
</pre></div>

</figure>

<p>This technique has limitations. For example, objects in JavaScript are not iterable by default. So we can’t write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">drink</code><code class="p">]</code> <code class="k">of</code> <code class="nx">personToDrink</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> prefers to drink </code><code class="si">${</code><code class="nx">drink</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt; undefined is not a function (evaluating 'personToDrink[Symbol.iterator]()\</code>
<code class="err">'</code><code class="p">)</code>
</pre></div>

</figure>

<p>We could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">drink</code><code class="p">]</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">personToDrink</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb"> prefers to drink </code><code class="si">${</code><code class="nx">drink</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
<code class="p">}</code>
  <code class="c1">//=&gt;</code>
    <code class="nx">Bob</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Ristretto</code>
    <code class="nx">Carol</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Cappuccino</code>
    <code class="nx">Ted</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Allongé</code>
    <code class="nx">Alice</code> <code class="nx">prefers</code> <code class="nx">to</code> <code class="nx">drink</code> <code class="nx">Cappuccino</code>
</pre></div>

</figure>

<p>It would be an enormous hack to make <code>Object.entries(IterableDictionary(personToDrink))</code> work. While we’re at it, how would we make <code>.length</code> work? Functions implement <code>.length</code> as the number of arguments they accept. Arrays implement it as the number of entries they hold. If we wrap an array in a dictionary, what is its <code>.length</code>?</p>

<p>Proxying collections, meaning “creating an object that behaves like the collection,” works for specific and limited contexts, but it is enormously fragile to attempt to make a universal proxy that also acts as a function.</p>

<h4 id="leanpub-auto-summary-9">summary</h4>

<p>JavaScript’s elegance comes from having a simple thing, functions, that can be combined in many flexible ways. Exceptions to the ways functions combine, like the <code>new</code> keyword, handling <code>this</code>, and <code>[...]</code>, make combining awkward, but we can work around that by writing adaptors to convert these exceptions to regular function calls.</p>

<div class="footnotes">
  <ol>
    <li id="fn-french">Bad for programming languages, of course. French is a lovely human language.<a href="https://leanpub.com/javascriptallongesix/read#fnref-french" rel="rev-footnote">↩</a>
</li>
    <li id="fn-colours">See the aforelinked <a href="https://leanpub.com/2015/03/12/symmetry.html">The Symmetry of JavaScript Functions</a><a href="https://leanpub.com/javascriptallongesix/read#fnref-colours" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="class-mixins">Con Panna: Composing Class Behaviour</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/con-panna.jpg" alt="Espresso Con Panna mixes sweet whipping cream into the strong coffee">
  <figcaption>Espresso Con Panna mixes sweet whipping cream into the strong coffee</figcaption>
</figure>


<p>Because prototypes are just objects, and because “classes” actually use prototypes under the hood, we can use all of the techniques we’ve learned about working with objects, when working with prototypes.</p>

<h3 id="classes-and-mixins">Extending Classes with Mixins</h3>

<p>We’ve seen that a “class” is simply a constructor function that is associated with a prototype, and that the <code>class</code> keyword is a declarative way to write our own constructor functions and prototypes. When we use the <code>new</code> keyword, we are invoking a mechanism that creates a new object that delegates to a prototype, just like <code>Object.create</code>, and then the constructor function takes over and performs any initialization we desire.</p>

<p>Because “classes” use the exact same model of delegating behaviour to prototypes, all the things we learned about prototypes apply to classes. We saw that we can create “subclasses” by chaining prototypes.</p>

<p>We can also share behaviour between classes in a more flexible way by mixing functionality into classes. This is the exact same thing as mixing functionality into prototypes, of course.</p>

<p>Recall <code>Person</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">misterRogers</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'Fred'</code><code class="p">,</code> <code class="s1">'Rogers'</code><code class="p">);</code>
<code class="nx">misterRogers</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Fred Rogers</code>
</pre></div>

</figure>

<p>We might be building some enterprisey thing and need <code>Manager</code> and <code>Worker</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Manager</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code>
  <code class="p">}</code>
  <code class="nx">addReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">removeReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">reports</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Worker</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">setManager</code> <code class="p">(</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">removeManager</code><code class="p">();</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="nx">manager</code><code class="p">;</code>
    <code class="nx">manager</code><code class="p">.</code><code class="nx">addReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">removeManager</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">.</code><code class="nx">removeReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This works for our company, so well that we grow and develop the dreaded “Middle Manager,” who both manages people and has a manager of their own. We could subclass <code>Manager</code> with <code>MiddleManager</code>, but how do <code>Worker</code> and <code>MiddleManager</code> share the functionality for having a manager?</p>

<p>With a mixin, of course:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">HasManager</code> <code class="o">=</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">setManager</code> <code class="p">(</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">removeManager</code><code class="p">();</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="nx">manager</code><code class="p">;</code>
    <code class="nx">manager</code><code class="p">.</code><code class="nx">addReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="kd">function</code> <code class="nx">removeManager</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code><code class="p">.</code><code class="nx">removeReport</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">manager</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">class</code> <code class="nx">Manager</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code>
  <code class="p">}</code>
  <code class="nx">addReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="nx">add</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">removeReport</code> <code class="p">(</code><code class="nx">report</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">reports</code><code class="p">().</code><code class="k">delete</code><code class="p">(</code><code class="nx">report</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">reports</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_reports</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">());</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">MiddleManager</code> <code class="kr">extends</code> <code class="nx">Manager</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">MiddleManager</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">HasManager</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Worker</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Worker</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">HasManager</code><code class="p">);</code>
</pre></div>

</figure>

<p>We can mix functionality into the prototypes of “classes” just as easily as we can mix functionality directly into objects, because prototypes <em>are</em> objects, and JavaScript builds its “classes” out of prototypes.</p>

<p>Were classes “something else,” like they are in other languages, we would gain many advantages that we do not enjoy in JavaScript, but we would also give up the flexibility of being able to use the same tools and techniques on prototypes that we do on objects.</p>

<h3 id="functional-mixins">Functional Mixins</h3>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#classes-and-mixins">Extending Classes with Mixins</a>, we saw that you can emulate “mixins” using <code>Object.assign</code> on classes. We’ll revisit this subject now and spend more time looking at mixing functionality into classes.</p>

<p>First, a quick recap: In JavaScript, a “class” is implemented as a constructor function and its prototype, whether you write it directly, or use the <code>class</code> keyword. Instances of the class are created by calling the constructor with <code>new</code>. They “inherit” shared behaviour from the constructor’s <code>prototype</code> property.<sup id="fnref-delegate"><a href="https://leanpub.com/javascriptallongesix/read#fn-delegate" rel="footnote">1</a></sup></p>

<h4 id="leanpub-auto-the-object-mixin-pattern">the object mixin pattern</h4>

<p>One way to share behaviour scattered across multiple classes, or to untangle behaviour by factoring it out of an overweight prototype, is to extend a prototype with a <em>mixin</em>.</p>

<p>Here’s a class of todo items:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And a “mixin” that is responsible for colour-coding:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Mixing colour coding into our Todo prototype is straightforward:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">Coloured</code><code class="p">);</code>

<code class="k">new</code> <code class="nx">Todo</code><code class="p">(</code><code class="s1">'test'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">setColourRGB</code><code class="p">({</code><code class="nx">r</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">3</code><code class="p">})</code>
  <code class="c1">//=&gt; {"name":"test","done":false,"colourCode":{"r":1,"g":2,"b":3}}</code>
</pre></div>

</figure>

<p>So far, very easy and very simple. This is a <em>pattern</em>, a recipe for solving a certain problem using a particular organization of code.</p>

<h4 id="leanpub-auto-functional-mixins">functional mixins</h4>

<p>The object mixin we have above works properly, but our little recipe had two distinct steps: Define the mixin and then extend the class prototype. Angus Croll pointed out that it’s more elegant to define a mixin as a function rather than an object. He calls this a <a href="https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/" title="A fresh look at JavaScript Mixins">functional mixin</a>. Here’s <code>Coloured</code> again, recast in functional form:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">{</code>
    <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">});</code>

<code class="nx">Coloured</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
</pre></div>

</figure>

<p>We can make ourselves a <em>factory function</em> that also names the pattern:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">FunctionalMixin</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">target</code> <code class="o">=&gt;</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">behaviour</code><code class="p">);</code>
</pre></div>

</figure>

<p>This allows us to define functional mixins neatly:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-enumerability">enumerability</h4>

<p>If we look at the way <code>class</code> defines prototypes, we find that the methods defined are not enumerable by default. This works around a common error where programmers iterate over the keys of an instance and fail to test for <code>.hasOwnProperty</code>.</p>

<p>Our object mixin pattern does not work this way, the methods defined in a mixin <em>are</em> enumerable by default, and if we carefully defined them to be non-enumerable, <code>Object.assign</code> wouldn’t mix them into the target prototype, because <code>Object.assign</code> only assigns enumerable properties.</p>

<p>And thus:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Coloured</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">urgent</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Todo</code><code class="p">(</code><code class="s2">"finish blog post"</code><code class="p">);</code>
<code class="nx">urgent</code><code class="p">.</code><code class="nx">setColourRGB</code><code class="p">({</code><code class="nx">r</code><code class="o">:</code> <code class="mi">256</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">0</code><code class="p">});</code>

<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">urgent</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">property</code><code class="p">);</code>
  <code class="c1">// =&gt;</code>
    <code class="nx">name</code>
    <code class="nx">done</code>
    <code class="nx">colourCode</code>
    <code class="nx">setColourRGB</code>
    <code class="nx">getColourRGB</code>
</pre></div>

</figure>

<p>As we can see, the <code>setColourRGB</code> and <code>getColourRGB</code> methods are enumerated, although the <code>do</code> and <code>undo</code> methods are not. This can be a problem with naïve code: we can’t always rewrite all the <em>other</em> code to carefully use <code>.hasOwnProperty</code>.</p>

<p>One benefit of functional mixins is that we can solve this problem and transparently make mixins behave like <code>class</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">FunctionalMixin</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">))</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">target</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">})</code>
    <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>Writing this out as a pattern would be tedious and error-prone. Encapsulating the behaviour into a function is a small win.</p>

<h4 id="leanpub-auto-mixin-responsibilities">mixin responsibilities</h4>

<p>Like classes, mixins are metaobjects: They define behaviour for instances. In addition to defining behaviour in the form of methods, classes are also responsible for initializing instances. But sometimes, classes and metaobjects handle additional responsibilities.</p>

<p>For example, sometimes a particular concept is associated with some well-known constants. When using a class, can be handy to namespace such values in the class itself:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="nx">Todo</code><code class="p">.</code><code class="nx">DEFAULT_NAME</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="nx">Todo</code><code class="p">.</code><code class="nx">DEFAULT_NAME</code> <code class="o">=</code> <code class="s1">'Untitled'</code><code class="p">;</code>

<code class="c1">// If we are sticklers for read-only constants, we could write:</code>
<code class="c1">// Object.defineProperty(Todo, 'DEFAULT_NAME', {value: 'Untitled'});</code>
</pre></div>

</figure>

<p>We can’t really do the same thing with simple mixins, because all of the properties in a simple mixin end up being mixed into the prototype of instances we create by default. For example, let’s say we want to define <code>Coloured.RED</code>, <code>Coloured.GREEN</code>, and <code>Coloured.BLUE</code>. But we don’t want any specific coloured instance to define <code>RED</code>, <code>GREEN</code>, or <code>BLUE</code>.</p>

<p>Again, we can solve this problem by building a functional mixin. Our <code>FunctionalMixin</code> factory function will accept an optional dictionary of read-only mixin properties:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">FunctionalMixin</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="nx">sharedBehaviour</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">sharedKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">sharedBehaviour</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">mixin</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">target</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
    <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">sharedKeys</code><code class="p">)</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">value</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
      <code class="nx">enumerable</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code>
    <code class="p">});</code>
  <code class="k">return</code> <code class="nx">mixin</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And now we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">},</code> <code class="p">{</code>
  <code class="nx">RED</code><code class="o">:</code>   <code class="p">{</code> <code class="nx">r</code><code class="o">:</code> <code class="mi">255</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>   <code class="nx">b</code><code class="o">:</code> <code class="mi">0</code>   <code class="p">},</code>
  <code class="nx">GREEN</code><code class="o">:</code> <code class="p">{</code> <code class="nx">r</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>   <code class="nx">g</code><code class="o">:</code> <code class="mi">255</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">0</code>   <code class="p">},</code>
  <code class="nx">BLUE</code><code class="o">:</code>  <code class="p">{</code> <code class="nx">r</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>   <code class="nx">g</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>   <code class="nx">b</code><code class="o">:</code> <code class="mi">255</code> <code class="p">},</code>
<code class="p">});</code>

<code class="nx">Coloured</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">urgent</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Todo</code><code class="p">(</code><code class="s2">"finish blog post"</code><code class="p">);</code>
<code class="nx">urgent</code><code class="p">.</code><code class="nx">setColourRGB</code><code class="p">(</code><code class="nx">Coloured</code><code class="p">.</code><code class="nx">RED</code><code class="p">);</code>

<code class="nx">urgent</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">()</code>
  <code class="c1">//=&gt; {"r":255,"g":0,"b":0}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-mixin-methods">mixin methods</h4>

<p>Such properties need not be values. Sometimes, classes have methods. And likewise, sometimes it makes sense for a mixin to have its own methods. One example concerns <code>instanceof</code>.</p>

<p>In earlier versions of ECMAScript, <code>instanceof</code> is an operator that checks to see whether the prototype of an instance matches the prototype of a constructor function. It works just fine with “classes,” but it does not work “out of the box” with mixins:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">urgent</code> <code class="k">instanceof</code> <code class="nx">Todo</code>
  <code class="c1">//=&gt; true</code>

<code class="nx">urgent</code> <code class="k">instanceof</code> <code class="nx">Coloured</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>To handle this and some other issues where programmers are creating their own notion of dynamic types, or managing prototypes directly with <code>Object.create</code> and <code>Object.setPrototypeOf</code>, ECMAScript 2015 provides a way to override the built-in <code>instanceof</code> behaviour: An object can define a method associated with a well-known symbol, <code>Symbol.hasInstance</code>.</p>

<p>We can test this quickly:<sup id="fnref-but"><a href="https://leanpub.com/javascriptallongesix/read#fn-but" rel="footnote">2</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">Coloured</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">hasInstance</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kc">true</code>
<code class="nx">urgent</code> <code class="k">instanceof</code> <code class="nx">Coloured</code>
  <code class="c1">//=&gt; true</code>
<code class="p">{}</code> <code class="k">instanceof</code> <code class="nx">Coloured</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Of course, that is not semantically correct. But using this technique, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">FunctionalMixin</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="nx">sharedBehaviour</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">sharedKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">sharedBehaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">typeTag</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"isA"</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">mixin</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">target</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">})</code>
    <code class="nx">target</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">sharedKeys</code><code class="p">)</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">value</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
      <code class="nx">enumerable</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code>
    <code class="p">});</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">Symbol</code><code class="p">.</code><code class="nx">hasInstance</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">inst</code><code class="o">\</code>
<code class="nx">ance</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="p">});</code>
  <code class="k">return</code> <code class="nx">mixin</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">urgent</code> <code class="k">instanceof</code> <code class="nx">Coloured</code>
  <code class="c1">//=&gt; true</code>
<code class="p">{}</code> <code class="k">instanceof</code> <code class="nx">Coloured</code>
  <code class="c1">//=&gt; false</code>
</pre></div>

</figure>

<p>Do you need to implement <code>instanceof</code>? Quite possibly not. “Rolling your own polymorphism” is usually a last resort. But it can be handy for writing test cases, and a few daring framework developers might be working on multiple dispatch and pattern-matching for functions.</p>

<h4 id="leanpub-auto-summary-10">summary</h4>

<p>The charm of the object mixin pattern is its simplicity: It really does not need an abstraction wrapped around an object literal and <code>Object.assign</code>.</p>

<p>However, behaviour defined with the mixin pattern is <em>slightly</em> different than behaviour defined with the <code>class</code> keyword. Two examples of these differences are enumerability and mixin properties (such as constants and mixin methods like <code>[Symbol.hasInstance]</code>).</p>

<p>Functional mixins provide an opportunity to implement such functionality, at the cost of some complexity in the <code>FunctionalMixin</code> function that creates functional mixins.</p>

<p>As a general rule, it’s best to have things behave as similarly as possible in the domain code, and this sometimes does involve some extra complexity in the infrastructure code. But that is more of a guideline than a hard-and-fast rule, and for this reason there is a place for both the object mixin pattern <em>and</em> functional mixins in JavaScript.</p>

<h3 id="mi">Emulating Multiple Inheritance</h3>

<p>If you want to mix behaviour into a class, mixins do the job very nicely. But sometimes, people want more. They want <strong>multiple inheritance</strong>. Meaning, what they really want is to create a new class that inherits from both <code>Todo</code> <em>and</em> from <code>Coloured</code>.</p>

<p>If JavaScript had multiple inheritance, we could accomplish this by extending a class with more than one superclass:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// highly insecure</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Coloured</code> <code class="p">{</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">yellow</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">red</code>    <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">green</code>  <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">grey</code>   <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">};</code>

<code class="kd">let</code> <code class="nx">oneDayInMilliseconds</code> <code class="o">=</code> <code class="mi">1000</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">24</code><code class="p">;</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code><code class="p">,</code> <code class="nx">Coloured</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This hypothetical <code>TimeSensitiveTodo</code> extends both <code>Todo</code> and <code>Coloured</code>, and it overrides <code>toHTML</code> from <code>Todo</code> as well as overriding <code>getColourRGB</code> from <code>Coloured</code>.</p>

<h4 id="leanpub-auto-subclass-factories">subclass factories</h4>

<p>However, JavaScript does not have “true” multiple inheritance, and therefore this code does not work. But we can simulate multiple inheritance for cases like this. The way it works is to step back and ask ourselves, “What would we do if we didn’t have mixins or multiple inheritance?”</p>

<p>The answer is, we’d force a square multiple inheritance peg into a round single inheritance hole, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">ColouredTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">ColouredTodo</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>By making <code>ColouredTodo</code> extend <code>Todo</code>, <code>TimeSensitiveTodo</code> can extend <code>ColouredTodo</code> and override methods from both. This is exactly what most programmers do, and we know that it is an anti-pattern, as it leads to duplicated class behaviour and deep class hierarchies.</p>

<p>But.</p>

<p>What if, instead of manually creating this hierarchy, we use our simple mixins to do the work for us? We can take advantage of the fact that <a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">classes are expressions</a>, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">ColouredTodo</code> <code class="o">=</code> <code class="nx">Coloured</code><code class="p">(</code><code class="kr">class</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{});</code>
</pre></div>

</figure>

<p>Thus, we have a <code>ColouredTodo</code> that we can extend and override, but we also have our <code>Coloured</code> behaviour in a mixin we can use anywhere we like without duplicating its functionality in our code. The full solution looks like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// highly insecure</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">Coloured</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kd">let</code> <code class="nx">ColouredTodo</code> <code class="o">=</code> <code class="nx">Coloured</code><code class="p">(</code><code class="kr">class</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{});</code>

<code class="kd">let</code> <code class="nx">yellow</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">red</code>    <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">green</code>  <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">grey</code>   <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">};</code>

<code class="kd">let</code> <code class="nx">oneDayInMilliseconds</code> <code class="o">=</code> <code class="mi">1000</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">24</code><code class="p">;</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">ColouredTodo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">task</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">TimeSensitiveTodo</code><code class="p">(</code><code class="s1">'Finish JavaScript Allongé'</code><code class="p">,</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code> <code class="o">+</code> <code class="nx">oneDa</code><code class="o">\</code>
<code class="nx">yInMilliseconds</code><code class="p">);</code>

<code class="nx">task</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code>
  <code class="c1">//=&gt; &lt;span style="color: #FFFF00;"&gt;Finish JavaScript Allongé&lt;/span&gt;</code>
</pre></div>

</figure>

<p>The key snippet is <code>let ColouredTodo = Coloured(class extends Todo {});</code>, it turns behaviour into a subclass that can be extended and overridden.</p>

<h4 id="leanpub-auto-subclass-factories-1">subclass factories</h4>

<p>We can turn this pattern into a function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SubclassFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">mixBehaviourInto</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="p">(</code><code class="nx">superclazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">mixBehaviourInto</code><code class="p">(</code><code class="kr">class</code> <code class="kr">extends</code> <code class="nx">superclazz</code> <code class="p">{});</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Using <code>SubclassFactory</code>, we wrap the class we want to extend, instead of the class we are declaring. Like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SubclassFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">mixBehaviourInto</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="p">(</code><code class="nx">superclazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">mixBehaviourInto</code><code class="p">(</code><code class="kr">class</code> <code class="kr">extends</code> <code class="nx">superclazz</code> <code class="p">{});</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">ColouredAsWellAs</code> <code class="o">=</code> <code class="nx">SubclassFactory</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">ColouredAsWellAs</code><code class="p">(</code><code class="nx">ToDo</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The syntax of <code>class TimeSensitiveTodo extends ColouredAsWellAs(ToDo)</code> says exactly what we mean: We are extending our <code>Coloured</code> behaviour as well as extending <code>ToDo</code>.<sup id="fnref-fagnani"><a href="https://leanpub.com/javascriptallongesix/read#fn-fagnani" rel="footnote">3</a></sup></p>

<h3 id="leanpub-auto-preventing-property-conflicts">Preventing Property Conflicts</h3>

<p>When mixing behaviour onto classes, (and equally, when chaining prototypes, or extending classes in a hierarchy), we are engaging in <a href="https://en.wikipedia.org/wiki/Open_recursion#Open_recursion">open recursion</a>. The methods in each mixin (or prototype in a chain) all have the same context, and therefore refer to the same properties.</p>

<p>When chaining prototypes or extending classes, this does not typically result in two functions accidentally using the same property for two different purposes. For example, if we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">class</code> <code class="nx">Bibliophile</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And later we wanted to write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Author</code> <code class="kr">extends</code> <code class="nx">Bibliophile</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>It is very unlikely that we would attempt to use the same <code>._books</code> property to refer to both the books an author writes and the books a bibliophile collects. For some odd reason, our ontology has it that all authors are also bibliophiles, so it’s natural that we would inspect the <code>Bibliophile</code> superclass when designing <code>Author</code>, and all of our tests for <code>Author</code> would be performed on objects that are instances of <code>Bibliophile</code>, by definition.</p>

<p>However, this is not the case for mixins. If we wrote:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">IsBibliophile</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>And a colleague wrote:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">IsAuthor</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">addBook</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">books</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">books</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>This code could easily work for months or years. <code>IsAuthor</code> could be tested independently of <code>Bibliophile</code>, and both would appear to behave correctly. Until the fateful day someone wrote something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">BookLovingAuthor</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
<code class="p">}</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">BookLovingAuthor</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">IsBibliophile</code><code class="p">,</code> <code class="nx">IsAuthor</code><code class="p">);</code>

<code class="k">new</code> <code class="nx">BookLovingAuthor</code><code class="p">(</code><code class="s1">'Isaac'</code><code class="p">,</code> <code class="s1">'Asimov'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addBook</code><code class="p">(</code><code class="s1">'I Robot'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s1">'The Mysterious Affair at Styles'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">collection</code><code class="p">()</code>
    <code class="c1">//=&gt; ["I Robot","The Mysterious Affair at Styles"]</code>
</pre></div>

</figure>

<p>And bam! We have a property conflict: The books Isaac Asimov has written and collects have become intermingled, because the two mixins refer to the same property.</p>

<h4 id="leanpub-auto-decoupling-mixins-with-symbols">decoupling mixins with symbols</h4>

<p>The simplest way to avoid these property conflicts is to use symbols for property names:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">IsAuthor</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">books</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">addBook</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">books</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">books</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">})();</code>

<code class="kr">const</code> <code class="nx">IsBibliophile</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">books</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>

  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
    <code class="p">}</code>
  <code class="p">};</code>
<code class="p">})();</code>

<code class="kr">class</code> <code class="nx">BookLovingAuthor</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
<code class="p">}</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">BookLovingAuthor</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">IsBibliophile</code><code class="p">,</code> <code class="nx">IsAuthor</code><code class="p">);</code>

<code class="k">new</code> <code class="nx">BookLovingAuthor</code><code class="p">(</code><code class="s1">'Isaac'</code><code class="p">,</code> <code class="s1">'Asimov'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addBook</code><code class="p">(</code><code class="s1">'I Robot'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s1">'The Mysterious Affair at Styles'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">collection</code><code class="p">()</code>
    <code class="c1">//=&gt; ["The Mysterious Affair at Styles"]</code>
  <code class="p">.</code><code class="nx">books</code><code class="p">().</code>
    <code class="c1">//=&gt; ["I Robot"]</code>
</pre></div>

</figure>

<p>Using symbols for property keys eliminates property conflicts between mixins.</p>

<h3 id="leanpub-auto-reducing-coupling">Reducing Coupling</h3>

<p>When classes are built in a hierarchy, or mixins are distributed across a code base, coupling arises over time. Typically, as a code base evolves, each iteration of programmer uses whatever methods or properties have been made available by the accumulated efforts of previous iterations.</p>

<p>As time goes on, the number of methods and properties increases, and each new piece of behaviour touches more and more methods and properties. When it comes time to refactor the code base, it can be very difficult to tease behaviour apart, since so many pieces naturally end up depending on each other.</p>

<p>One way to resist this natural tendency toward coupling is by making sure that each metaobject exposes only the methods it confers upon its receivers. All other methods and properties should be kept private.</p>

<p>Note that making properties private is not an ideological issue: It’s not a question of “purity in OO theory.” It’s a practical issue: It’s a question of minimizing the surface area of the metaobject in order to minimize the ways in which it can become coupled to other objects.</p>

<h4 id="leanpub-auto-using-symbols-to-reduce-coupled-properties">using symbols to reduce coupled properties</h4>

<p>We have seen that using symbols as property keys prevents mixins from accidentally sharing the same property name for different purposes. They can also help prevent programmers from <em>deliberately</em> using the same property name for different purposes.</p>

<p>Here’s why we care about that. Consider:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Bibliophile</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="p">}</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">_books</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">hasInCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">bezos</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bibliophile</code><code class="p">(</code><code class="s1">'jeff'</code><code class="p">,</code> <code class="s1">'bezos'</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"The Everything Store: Jeff Bezos and the Age of Amazon"</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">hasInCollection</code><code class="p">(</code><code class="s2">"Matthew and the Wellington Boots"</code><code class="p">)</code>
    <code class="c1">//=&gt; false</code>
    
<code class="nx">bezos</code>
  <code class="p">.</code><code class="nx">hasInCollection</code><code class="p">(</code><code class="s2">"The Everything Store: Jeff Bezos and the Age of Amazon"</code><code class="p">)</code>
    <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>Note that <code>._books</code> is an array. Now consider:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">BookGlutten</code> <code class="kr">extends</code> <code class="nx">Bibliophile</code> <code class="p">{</code>
  <code class="nx">buyInBulk</code> <code class="p">(...</code><code class="nx">names</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">books</code><code class="p">().</code><code class="nx">push</code><code class="p">(...</code><code class="nx">names</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Book gluttons can buy books in bulk, ordinary bibliophiles cannot. So far, so good. But we have a very naïve implementation of book collections: an array is a linear data structure, the performance of <code>hasInCollection</code> is order <code>n</code>. The moment we have a bibliophile with a really large collection, the operation becomes excruciatingly slow.</p>

<p>Simplifying greatly, what if we refactor <code>Bibliophile</code> to use a <code>Set</code>?</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Bibliophile</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">_books</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">();</code>
  <code class="p">}</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">_books</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">hasInCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Much faster, but we just broke our <code>BookGlutten</code> subclass. This is a very small and contrived example, but the phenomenon is very real, and the larger the class hierarchy, the more it occurs. The author of our <code>BookGlutton</code> subclass coupled <code>BookGlutton</code> to an implementation detail of <code>Bibliophile</code>. That’s a “feature” of open recursion, but it is far wiser to prevent this from happening.</p>

<p>Naturally, we can use the same technique to prevent deliberate coupling of subclasses that we used to prevent accidental property conflicts: Symbols.</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Bibliophile</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">books</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"books"</code><code class="p">);</code>
  
  <code class="k">return</code> <code class="kr">class</code> <code class="nx">Bibliophile</code> <code class="kr">extends</code> <code class="nx">Person</code> <code class="p">{</code>
    <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">super</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">]</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="p">}</code>
    <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">hasInCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">books</code><code class="p">].</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})();</code>
</pre></div>

</figure>

<p>Now anyone subclassing <code>Bibliophile</code> is strongly discouraged from directly accessing the “books” property:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">BookGlutten</code> <code class="kr">extends</code> <code class="nx">Bibliophile</code> <code class="p">{</code>
  <code class="nx">buyInBulk</code> <code class="p">(...</code><code class="nx">names</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">name</code> <code class="k">of</code> <code class="nx">names</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Problem solved.</p>

<div class="footnotes">
  <ol>
    <li id="fn-delegate">A much better way to put it is that objects with a prototype <em>delegate</em> behaviour to their prototype (and that may in turn delegate behaviour to its prototype if it has one, and so on).<a href="https://leanpub.com/javascriptallongesix/read#fnref-delegate" rel="rev-footnote">↩</a>
</li>
    <li id="fn-but">This may <strong>not</strong> work with various transpilers and other incomplete ECMAScript 2015 implementations. Check the documentation. For example, you must enable the “high compliancy” mode in <a href="http://babeljs.io/">BabelJS</a>. This is off by default to provide the highest possible performance for code bases that do not need to use features like this.<a href="https://leanpub.com/javascriptallongesix/read#fnref-but" rel="rev-footnote">↩</a>
</li>
    <li id="fn-fagnani">Justin Fagnani named this pattern “subclass factory” in his essay <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">“Real” Mixins with JavaScript Classes</a>. It’s well worth a read, and his implementation touches on other matters such as optimizing performance on modern JavaScript engines.<a href="https://leanpub.com/javascriptallongesix/read#fnref-fagnani" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="redecorating">More Decorators</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/train_1200.jpg" alt="The delight of coffee is that it transports you to another world">
  <figcaption>The delight of coffee is that it transports you to another world</figcaption>
</figure>


<p>(<em>this bonus chapter is a work-in-progress</em>)</p>

<h3 id="stateful-method-decorators">Stateful Method Decorators</h3>

<p>As noted in <a href="https://leanpub.com/javascriptallongesix/read#method-decorators">Method Decorators</a>, and again in <a href="https://leanpub.com/javascriptallongesix/read#symmetry">Symmetry, Colour, and Charm</a>, simple function decorators work and work well for ordinary functions. But in JavaScript, functions can be invoked in different ways, and some of those ways are slightly incompatible with each other.</p>

<p>Of great interest to us are <em>methods</em> in JavaScript, functions that are used to define the behaviour of instances. When a function is invoked as a method, the name <code>this</code> is bound to the instance, and most methods rely on that binding to work properly.</p>

<p>Consider, for example the simple decorator <code>requireAll</code>, that raises an exception if a function is invoked without at least as many arguments as declared parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">requireAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'missing required arguments'</code><code class="p">);</code>
    <code class="k">else</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p><code>requireAll</code> works perfectly with ordinary functions, what we called “blue” invocations. But if we want to use <code>requireAll</code> with methods, we have to write it in such a way that it preserves <code>this</code> when it invokes the underlying function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">requireAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'missing required arguments'</code><code class="p">);</code>
    <code class="k">else</code>
      <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>It now works properly, including ignoring invocations that do not pass all the arguments. But you have to be very careful when writing higher-order functions to make sure they work as both function decorators and as method decorators.</p>

<p>We called this style of decorator a “green” decorator, because it handles blue (ordinary function) and yellow (method) invocations.</p>

<h4 id="leanpub-auto-the-problem-with-state">the problem with state</h4>

<p>Handling <code>this</code> properly is not the only way in which ordinary function decorators differ from method decorators. Some decorators are stateful, like <code>once</code>. Here’s a version that correctly sets <code>this</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">hasRun</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">hasRun</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
    <code class="nx">hasRun</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Imagining for a moment that we wish to only allow a person to have their name set once, we might write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">hasRun</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">hasRun</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
    <code class="nx">hasRun</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">once</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototyp</code><code class="o">\</code>
<code class="nx">e</code><code class="p">.</code><code class="nx">setName</code><code class="p">)</code> <code class="p">});</code>

<code class="kr">const</code> <code class="nx">logician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Raymond'</code><code class="p">,</code> <code class="s1">'Smullyan'</code><code class="p">)</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Haskell'</code><code class="p">,</code> <code class="s1">'Curry'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Raymond Smullyan</code>
</pre></div>

</figure>

<p>As we expect, only the first call to <code>.setName</code> has any effect, and it works on a method. But there is a subtle bug that could easily evade naïve attempts to write unit tests:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">logician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Raymond'</code><code class="p">,</code> <code class="s1">'Smullyan'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">musician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Miles'</code><code class="p">,</code> <code class="s1">'Davis'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Raymond Smullyan</code>

<code class="nx">musician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Raymond Smullyan</code>
</pre></div>

</figure>

<p>!?!?!?!</p>

<p>What has happened here is that when we write <code>Object.defineProperty(Person.prototype, 'setName', { value: once(Person.prototype.setName) });</code>, we wrapped a function bound to <code>Person.prototype</code>. That function is shared between all instances of <code>Person</code>. That’s deliberate, it’s the whole point of prototypical inheritance (and the “class-based inheritance” JavaScript builds with prototypes).</p>

<p>Since our <code>once</code> decorator returns a decorated function with private state (the <code>hasRun</code> variable), all the instances share the same private state, and thus the bug.</p>

<h4 id="leanpub-auto-writing-stateful-method-decorators">writing stateful method decorators</h4>

<p>If we don’t need to use the same decorator for functions and for methods, we can rewrite our decorator to use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a> to track whether a method has been invoked for an instance:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">invocations</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">();</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">invocations</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="k">this</code><code class="p">))</code> <code class="k">return</code><code class="p">;</code>
    <code class="nx">invocations</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">logician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Raymond'</code><code class="p">,</code> <code class="s1">'Smullyan'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Haskell'</code><code class="p">,</code> <code class="s1">'Curry'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">musician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Miles'</code><code class="p">,</code> <code class="s1">'Davis'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Raymond Smullyan</code>

<code class="nx">musician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Miles Davis</code>
</pre></div>

</figure>

<p>Now each instance stores whether <code>.setName</code> has been invoked on each instance a <code>WeakSet</code>, so <code>logician</code> and <code>musician</code> can share the method without sharing its state.</p>

<h4 id="leanpub-auto-incompatibility">incompatibility</h4>

<p>To handle methods, we have introduced “accidental complexity” to handle <code>this</code> and to handle state. Worse, our implementation of <code>once</code> for methods won’t work properly with ordinary functions in “strict” mode:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s2">"use strict"</code>

<code class="kr">const</code> <code class="nx">hello</code> <code class="o">=</code> <code class="nx">once</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="s1">'hello!'</code><code class="p">);</code>

<code class="nx">hello</code><code class="p">()</code>
  <code class="c1">//=&gt; undefined is not an object!</code>
</pre></div>

</figure>

<p>If you haven’t invoked it as a method, <code>this</code> is bound to <code>undefined</code> in strict mode, and <code>undefined</code> cannot be added to a <code>WeakSet</code>.</p>

<p>Correcting our decorator to deal with <code>undefined</code> is straightforward:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">invocations</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">(),</code>
      <code class="nx">undefinedContext</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'undefined-context'</code><code class="p">);</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">context</code> <code class="o">=</code> <code class="k">this</code> <code class="o">===</code> <code class="kc">undefined</code>
                    <code class="o">?</code> <code class="nx">undefinedContext</code>
                    <code class="o">:</code> <code class="k">this</code><code class="p">;</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">invocations</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">context</code><code class="p">))</code> <code class="k">return</code><code class="p">;</code>
    <code class="nx">invocations</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">context</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>However, we’re adding more accidental complexity to handle the fact that function invocation is &lt;span style=”color: blue;”&gt;blue&lt;/span&gt;, and method invocation is &lt;span style=”color: #999900;”&gt;khaki&lt;/span&gt;.<sup id="fnref-colours"><a href="https://leanpub.com/javascriptallongesix/read#fn-colours" rel="footnote">1</a></sup></p>

<p>In the end, we can either write specialized decorators designed specifically for methods, or tolerate the additional complexity of trying to handle method invocation and function invocation in the same decorator.</p>

<h3 id="es-later-class-decorators">Class Decorators beyond ES6/ECMAScript 2015</h3>

<p>In <a href="https://leanpub.com/javascriptallongesix/read#functional-mixins">Functional Mixins</a>, we discussed mixing functionality <em>into</em> JavaScript classes, changing the class. We observed that this has pitfalls when applied to a class that might already be in use elsewhere, but is perfectly cromulant when used as a technique to build a class from scratch. When used strictly to build a class, mixins help us decompose classes into smaller entities with focused responsibilities that can be shared between classes as necessary.</p>

<p>Let’s recall our helper for making a functional mixin:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">FunctionalMixin</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="nx">sharedBehaviour</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">sharedKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">sharedBehaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">typeTag</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"isA"</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">mixin</code> <code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">target</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">})</code>
    <code class="nx">target</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">sharedKeys</code><code class="p">)</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">value</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
      <code class="nx">enumerable</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code>
    <code class="p">});</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">Symbol</code><code class="p">.</code><code class="nx">hasInstance</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">inst</code><code class="o">\</code>
<code class="nx">ance</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="p">});</code>
  <code class="k">return</code> <code class="nx">mixin</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This creates a function that mixes behaviour into any target, be it a class prototype or a standalone object. There is a convenience capability of making “static” or “shared” properties of the the function, and it even adds some simple <code>hasInstance</code> handling so that the <code>instanceof</code> operator will work.</p>

<p>Here we are using it on a class’ prototype:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BookCollector</code> <code class="o">=</code> <code class="nx">FunctionalMixin</code><code class="p">({</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">BookCollector</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">)</code>

<code class="nx">president</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"JavaScript Allongé"</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"Kestrels, Quirky Birds, and Hopeless Egocentricity"</code><code class="p">);</code>

<code class="nx">president</code><code class="p">.</code><code class="nx">collection</code><code class="p">()</code>
  <code class="c1">//=&gt; ["JavaScript Allongé","Kestrels, Quirky Birds, and Hopeless Egocentricity\</code>
<code class="err">"</code><code class="p">]</code>
</pre></div>

</figure>

<h4 id="class-mixins">mixins that target classes</h4>

<p>It’s very nice that our mixins support any kind of target, but let’s make them class-specific:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">ClassMixin</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="nx">sharedBehaviour</code> <code class="o">=</code> <code class="p">{})</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">sharedKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">sharedBehaviour</code><code class="p">);</code>
  <code class="kr">const</code> <code class="nx">typeTag</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"isA"</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">mixin</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
    <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">sharedKeys</code><code class="p">)</code>
    <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
      <code class="nx">value</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
      <code class="nx">enumerable</code><code class="o">:</code> <code class="nx">sharedBehaviour</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code>
    <code class="p">});</code>
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">mixin</code><code class="p">,</code> <code class="nx">Symbol</code><code class="p">.</code><code class="nx">hasInstance</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">inst</code><code class="o">\</code>
<code class="nx">ance</code><code class="p">[</code><code class="nx">typeTag</code><code class="p">]</code> <code class="p">});</code>
  <code class="k">return</code> <code class="nx">mixin</code><code class="p">;</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This version’s <code>mixin</code> function mixes instance behaviour into a class’s prototype, so we gain convenience at the expense of flexibility:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BookCollector</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">BookCollector</code><code class="p">(</code><code class="nx">Person</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">)</code>

<code class="nx">president</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"JavaScript Allongé"</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"Kestrels, Quirky Birds, and Hopeless Egocentricity"</code><code class="p">);</code>

<code class="nx">president</code><code class="p">.</code><code class="nx">collection</code><code class="p">()</code>
  <code class="c1">//=&gt; ["JavaScript Allongé","Kestrels, Quirky Birds, and Hopeless Egocentricity\</code>
<code class="err">"</code><code class="p">]</code>
</pre></div>

</figure>

<p>So far, nice, but it feels a bit bolted-on-after-the-fact. Let’s take advantage of the fact that <a href="http://raganwald.com/2015/06/04/classes-are-expressions.html">Classes are Expressions</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BookCollector</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">BookCollector</code><code class="p">(</code><code class="kr">class</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p>This is structurally nicer, it binds the mixing in of behaviour with the class declaration in one expression, so we’re getting away from this idea of mixing things into classes after they’re created.</p>

<p>But (there’s always a but), our pattern has three different elements (the name being bound, the mixin, and the class being declared). And if we wanted to mix two or more behaviours in, we’d have to nest the functions like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Author</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">writeBook</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">books</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">books</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books_written</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_books_written</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">Author</code><code class="p">(</code><code class="nx">BookCollector</code><code class="p">(</code><code class="kr">class</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}));</code>
</pre></div>

</figure>

<p>Some people find this “clear as day,” arguing that this is a simple expression taking advantage of JavaScript’s simplicity. The code behind <code>mixin</code> is simple and easy to read, and if you understand prototypes, you understand everything in this expression.</p>

<p>But others want a language to give them “magic,” an abstraction that they learn on the outside. At the moment, JavaScript has no “magic” for mixing functionality into classes. But what if there were?</p>

<h4 id="leanpub-auto-class-decorators">class decorators</h4>

<p>There is a well-regarded <a href="https://github.com/wycats/javascript-decorators">proposal</a> to add Python-style class decorators to JavaScript in the future, nicknamed “ES.later.”<sup id="fnref-ESdotlater"><a href="https://leanpub.com/javascriptallongesix/read#fn-ESdotlater" rel="footnote">2</a></sup></p>

<p>A decorator is a function that operates on a class. Here’s a very simple example from the aforelinked implementation:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">annotation</code><code class="p">(</code><code class="nx">target</code><code class="p">)</code> <code class="p">{</code>
   <code class="c1">// Add a property on target</code>
   <code class="nx">target</code><code class="p">.</code><code class="nx">annotated</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="err">@</code><code class="nx">annotation</code>
<code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">MyClass</code><code class="p">.</code><code class="nx">annotated</code>
  <code class="c1">//=&gt; true</code>
</pre></div>

</figure>

<p>As you can see, <code>annotation</code> is a class decorator, and it takes a class as an argument. The function can do anything, including modifying the class or the class’s prototype. If the decorator function doesn’t return anything, the class’ name is bound to the modified class.<sup id="fnref-adv"><a href="https://leanpub.com/javascriptallongesix/read#fn-adv" rel="footnote">3</a></sup></p>

<p>A class is “decorated” with the function by preceding the definition with <code>@</code> and an expression evaluating to the decorator. in the simple example, we use a variable name.</p>

<p>Hmmm. A function that modifies a class, you say? Let’s try it:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BookCollector</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="err">@</code><code class="nx">BookCollector</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">)</code>

<code class="nx">president</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"JavaScript Allongé"</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">addToCollection</code><code class="p">(</code><code class="s2">"Kestrels, Quirky Birds, and Hopeless Egocentricity"</code><code class="p">);</code>

<code class="nx">president</code><code class="p">.</code><code class="nx">collection</code><code class="p">()</code>
  <code class="c1">//=&gt; ["JavaScript Allongé","Kestrels, Quirky Birds, and Hopeless Egocentricity\</code>
<code class="err">"</code><code class="p">]</code>
</pre></div>

</figure>

<p>You can also mix in multiple behaviours with decorators:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">BookCollector</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">addToCollection</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">collection</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">collection</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_collected_books</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">const</code> <code class="nx">Author</code> <code class="o">=</code> <code class="nx">ClassMixin</code><code class="p">({</code>
  <code class="nx">writeBook</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">books</code><code class="p">().</code><code class="nx">push</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>
  <code class="nx">books</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_books_written</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_books_written</code> <code class="o">=</code> <code class="p">[]);</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="err">@</code><code class="nx">BookCollector</code> <code class="err">@</code><code class="nx">Author</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Class decorators provide a compact, “magic” syntax that is closely tied to the construction of the class. They also require understanding one more kind of syntax. But some argue that having different syntax for different things aids understandability, and that having both <code>@foo</code> for decoration and <code>bar(...)</code> for function invocation is a win.</p>

<p>Decorators have not been formally approved, however there are various implementations available for transpiling decorator syntax to ES5 syntax. These examples were evaluated with <a href="http://babeljs.io/">Babel</a>.</p>

<h3 id="leanpub-auto-method-decorators-beyond-es6ecmascript-2015">Method Decorators beyond ES6/ECMAScript 2015</h3>

<p>Before ES6/ECMAScript 2015, we decorated a method in a simple and direct way. Given a method decorator like <code>fluent</code> (a/k/a <code>chain</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">fluent</code> <code class="o">=</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>We would wrap functions in our decorator and bind them to names to create methods, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">setName</code> <code class="o">=</code> <code class="nx">fluent</code><code class="p">(</code><code class="kd">function</code> <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
<code class="p">});</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>With the <code>class</code> keyword, we have a more elegant way to do everything in one step:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">}</code>
</pre></div>

</figure>

<p>Since the ECMAScript 2015 syntaxes for classes doesn’t give us any way to decorate a method where we are declaring it, we have to introduce this ugly “post-decoration” after we’ve declared <code>Person</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">fluent</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">protot</code><code class="o">\</code>
<code class="nx">ype</code><code class="p">.</code><code class="nx">setName</code><code class="p">)</code> <code class="p">});</code>
</pre></div>

</figure>

<p>This is weak for two reasons. First, it’s fugly and full of accidental complexity. Second, modifying the prototype after defining the class separates two things that conceptually ought to be together. The <code>class</code> keyword giveth, but it also taketh away.</p>

<h4 id="leanpub-auto-eslater-method-decorators">es.later method decorators</h4>

<p>To solve a problem created by ECMAScript 2015, <a href="https://github.com/wycats/javascript-decorators">method decorators</a> have been proposed for a future version of JavaScript (nicknamed “ES.later.”<sup id="fnref-ESdotlater"><a href="https://leanpub.com/javascriptallongesix/read#fn-ESdotlater" rel="footnote">4</a></sup> The syntax is similar to <a href="https://leanpub.com/javascriptallongesix/read#es-later-class-decorators">class decorators</a>, but where a class decorator takes a class as an argument and returns the same (or a different) class, a method decorator actually intercedes when a property is defined on the prototype.</p>

<p>An ES.later decorator version of <code>fluent</code> would look like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">fluent</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

  <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And we’d use it like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">fluent</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>That is much nicer: It lets us use the new class syntax, and it also lets us decompose functionality with method decorators. Best of all, when we write our classes in a “declarative” way, we also write our decorators in a declarative way.</p>

<p>Mind you, we are once again creating two kinds of decorators: One for functions, and one for methods, with different structures. We need a new <a href="https://leanpub.com/javascriptallongesix/read#symmetry">colour</a>!</p>

<p>But all elegance is not lost. Since decorators are expressions, we can alleviate the pain with an adaptor:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decorator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">decorator</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kd">function</code> <code class="nx">fluent</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">fluent</code><code class="p">)</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>Or if we prefer:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decorator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">decorator</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">returnsItself</code> <code class="o">=</code> <code class="nx">wrapWith</code><code class="p">(</code>
  <code class="kd">function</code> <code class="nx">fluent</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">);</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">returnsItself</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>(Although ES.later has not been approved, there is extensive support for ES.later method decorators in transpilation tools. The examples in this post were evaluated with <a href="http://babeljs.io/">Babel</a>.)</p>

<h3 id="traits">Lightweight Traits</h3>

<blockquote>
  <p>A <strong>trait</strong> is a concept used in object-oriented programming: a trait represents a collection of methods that can be used to extend the functionality of a class. Essentially a trait is similar to a class made only of concrete methods that is used to extend another class with a mechanism similar to multiple inheritance, but paying attention to name conflicts, hence with some support from the language for a name-conflict resolution policy to use when merging.—<a href="https://en.wikipedia.org/wiki/Trait_" title="computer_programming">Wikipedia</a></p>
</blockquote>

<p>A trait is like a <a href="https://leanpub.com/javascriptallongesix/read#classes-and-mixins">mixin</a>, however with a trait, we can not just define new behaviour, but also define ways to extend or override existing behaviour. Traits are a first-class feature languages like <a href="http://www.scala-lang.org/">Scala</a>. Traits are also available as a standard library in other languages, like <a href="http://docs.racket-lang.org/reference/trait.html">Racket</a>. Most interestingly, traits are a feature of the <a href="https://en.wikipedia.org/wiki/Self_(programming_language)#Traits">Self</a> programming language, one of the inspirations for JavaScript.</p>

<p>Traits are not a JavaScript feature as this essay is being written, but we can easily make lightweight traits out of the features JavaScript already has.</p>

<blockquote>
  <p>Our problem is that we want to be able to override or extend functionality from shared behaviour, whether that shared behaviour is defined as a class or as functionality to be mixed in.</p>
</blockquote>

<h4 id="leanpub-auto-our-toy-problem">our toy problem</h4>

<p>Here’s a toy problem we solved elsewhere with a <a href="https://leanpub.com/javascriptallongesix/read#mi">subclass factory</a> that in turn is made out of an extremely simple mixin.<sup id="fnref-extremely-simple"><a href="https://leanpub.com/javascriptallongesix/read#fn-extremely-simple" rel="footnote">5</a></sup></p>

<p>To recapitulate from the very beginning, we have a <code>Todo</code> class:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// highly insecure</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And we have the idea of “things that are coloured:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">toSixteen</code> <code class="o">=</code> <code class="p">(</code><code class="nx">c</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s1">'0123456789ABCDEF'</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">c</code><code class="p">),</code>
    <code class="nx">toTwoFiftyFive</code> <code class="o">=</code> <code class="p">(</code><code class="nx">cc</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">toSixteen</code><code class="p">(</code><code class="nx">cc</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code> <code class="o">*</code> <code class="mi">16</code> <code class="o">+</code> <code class="nx">toSixteen</code><code class="p">(</code><code class="nx">cc</code><code class="p">[</code><code class="mi">1</code><code class="p">]);</code>

<code class="kr">class</code> <code class="nx">Coloured</code> <code class="p">{</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">luminosity</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="mf">0.21</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.72</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">g</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.07</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>And we want to create a time-sensitive to-do that has colour according to whether it is overdue, close to its deadline, or has plenty of time left. If we had multiple inheritance, we would write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">let</code> <code class="nx">yellow</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">red</code>    <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">green</code>  <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'FF'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'00'</code><code class="p">},</code>
    <code class="nx">grey</code>   <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s1">'80'</code><code class="p">};</code>

<code class="kd">let</code> <code class="nx">oneDayInMilliseconds</code> <code class="o">=</code> <code class="mi">1000</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">24</code><code class="p">;</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code><code class="p">,</code> <code class="nx">Coloured</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>But we don’t have multiple inheritance. In languages where mixing in functionality is difficult, we can fake a solution by having <code>ColouredTodo</code> inherit from <code>Todo</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">ColouredTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">luminosity</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="mf">0.21</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.72</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">g</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.07</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">ColouredTodo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>The drawback of this approach is that we can no longer make other kinds of things “coloured” without making them also todos. For example, if we had coloured meetings in a time management application, we’d have to write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Meeting</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">ColouredMeeting</code> <code class="kr">extends</code> <code class="nx">Meeting</code> <code class="p">{</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">luminosity</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="mf">0.21</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.72</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">g</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.07</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This forces us to duplicate “coloured” functionality throughout our code base. But thanks to mixins, we can have our cake and eat it to: We can make <code>ColouredAsWellAs</code> a kind of mixin that makes a new subclass and then mixes into the subclass. We call this a “subclass factory:”</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">ClassMixin</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="nx">mixin</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
      <code class="p">});</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">SubclassFactory</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">superclazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ClassMixin</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">)(</code><code class="kr">class</code> <code class="kr">extends</code> <code class="nx">superclazz</code> <code class="p">{});</code>

<code class="kr">const</code> <code class="nx">ColouredAsWellAs</code> <code class="o">=</code> <code class="nx">SubclassFactory</code><code class="p">({</code>
  <code class="nx">setColourRGB</code> <code class="p">({</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">})</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">};</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">luminosity</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="mf">0.21</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.72</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">g</code><code class="p">)</code> <code class="o">+</code>
           <code class="mf">0.07</code> <code class="o">*</code> <code class="nx">toTwoFiftyFive</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>
  <code class="p">},</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">colourCode</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">ColouredAsWellAs</code><code class="p">(</code><code class="nx">Todo</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">toHTML</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="kr">super</code><code class="p">.</code><code class="nx">toHTML</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/s</code><code class="err">\</code><code class="sb"></code>
<code class="sb">pan&gt;`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This allows us to override both our <code>Todo</code> methods and the <code>ColourAsWellAs</code> methods. And elsewhere, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">ColouredMeeting</code> <code class="o">=</code> <code class="nx">ColouredAsWellAs</code><code class="p">(</code><code class="nx">Meeting</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or perhaps:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">TimeSensitiveMeeting</code> <code class="kr">extends</code> <code class="nx">ColouredAsWellAs</code><code class="p">(</code><code class="nx">Meeting</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>To summarize, our problem is that we want to be able to override or extend functionality from shared behaviour, whether that shared behaviour is defined as a class or as functionality to be mixed in. Subclass factories are one way to solve that problem.</p>

<p>Now we’ll solve the same problem with traits.</p>

<h4 id="leanpub-auto-defining-lightweight-traits">defining lightweight traits</h4>

<p>Let’s start with our <code>ClassMixin</code>. We’ll modify it slightly to insist that it never attempt to define a method that already exists, and we’ll use that to create <code>Coloured</code>, a function that defines two methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Define</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="nx">define</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code> <code class="p">{</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">],</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">throw</code> <code class="sb">`illegal attempt to override </code><code class="si">${</code><code class="nx">property</code><code class="si">}</code><code class="sb">, which already exists.</code>
<code class="sb">  }</code>
<code class="sb">}</code>

<code class="sb">const Coloured = Define({</code>
<code class="sb">  setColourRGB ({r, g, b}) {</code>
<code class="sb">    this.colourCode = {r, g, b};</code>
<code class="sb">    return this;</code>
<code class="sb">  },</code>

<code class="sb">  luminosity () {</code>
<code class="sb">    let {r, g, b} = this.getColourRGB();</code>

<code class="sb">    return 0.21 * toTwoFiftyFive(r) +</code>
<code class="sb">           0.72 * toTwoFiftyFive(g) +</code>
<code class="sb">           0.07 * toTwoFiftyFive(b);</code>
<code class="sb">  },</code>

<code class="sb">  getColourRGB () {</code>
<code class="sb">    return this.colourCode;</code>
<code class="sb">  }</code>
<code class="sb">});</code>
</pre></div>

</figure>

<p><code>Coloured</code> is now a function that modifies a class, adding two methods provided that they don’t already exist in the class.</p>

<p>But we need a variation that “overrides” <code>getColourRGB</code>. We can write a variation of <code>Define</code> that always overrides the target’s methods, and passes in the original method as the first parameter. This is similar to “around” [method advice][ma-mj]:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Override</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="nx">overrides</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">overriddenMethodFunction</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">];</code>

        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">].</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">overriddenMethodFunction</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="o">\</code>
<code class="k">this</code><code class="p">),</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>
          <code class="p">},</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">throw</code> <code class="sb">`attempt to override non-existant method </code><code class="si">${</code><code class="nx">property</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">DeadlineSensitive</code> <code class="o">=</code> <code class="nx">Override</code><code class="p">({</code>
  <code class="nx">getColourRGB</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">slack</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">grey</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="nx">red</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">slack</code> <code class="o">&lt;=</code> <code class="nx">oneDayInMilliseconds</code><code class="p">){</code>
      <code class="k">return</code> <code class="nx">yellow</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="k">return</code> <code class="nx">green</code><code class="p">;</code>
  <code class="p">},</code>

  <code class="nx">toHTML</code> <code class="p">(</code><code class="nx">original</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">rgb</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">getColourRGB</code><code class="p">();</code>

    <code class="k">return</code> <code class="sb">`&lt;span style="color: #</code><code class="si">${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">r</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">g</code><code class="si">}${</code><code class="nx">rgb</code><code class="p">.</code><code class="nx">b</code><code class="si">}</code><code class="sb">;"&gt;</code><code class="si">${</code><code class="nx">original</code><code class="p">()</code><code class="si">}</code><code class="sb">&lt;/span&gt;</code><code class="err">\</code><code class="sb"></code>
<code class="sb">`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<p><code>Define</code> and <code>Override</code> are <em>protocols</em>: They define whether methods may conflict, and if they do, how that conflict is resolved. <code>Define</code> prohibits conflicts, forcing us to pick another protocol. <code>Override</code> permits us to write a method that overrides an existing method and (optionally) call the original.</p>

<h4 id="leanpub-auto-composing-protocols">composing protocols</h4>

<p>We <em>could</em> now write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">TimeSensitiveTodo</code> <code class="o">=</code> <code class="nx">DeadlineSensitive</code><code class="p">(</code>
  <code class="nx">Coloured</code><code class="p">(</code>
    <code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{</code>
      <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">)</code>
<code class="p">);</code>
</pre></div>

</figure>

<p>Or:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="err">@</code><code class="nx">DeadlineSensitive</code>
<code class="err">@</code><code class="nx">Coloured</code>
<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>But if we want to use <code>DeadlineSensitive</code> and <code>Coloured</code> together more than once, we can make a lightweight trait with the <a href="https://leanpub.com/javascriptallongesix/read#pipeline"><code>pipeline</code></a> function:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">SensitizeTodos</code> <code class="o">=</code> <code class="nx">pipeline</code><code class="p">(</code><code class="nx">Coloured</code><code class="p">,</code> <code class="nx">DeadlineSensitive</code><code class="p">);</code>

<code class="err">@</code><code class="nx">SensitizeTodos</code>
<code class="kr">class</code> <code class="nx">TimeSensitiveTodo</code> <code class="kr">extends</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">deadline</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">super</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">deadline</code> <code class="o">=</code> <code class="nx">deadline</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Now <code>SensitizeTodos</code> combines defining methods with overriding existing methods: We’ve built a lightweight trait by composing protocols.</p>

<p>And that’s all a trait is: The composition of protocols. And we don’t need a bunch of new keywords or decorators (like @overrides) to do it, we just use the functional composition that is so easy and natural in JavaScript.</p>

<h4 id="leanpub-auto-other-protocols">other protocols</h4>

<p>We can incorporate other protocols. Two of the most common are prepending behaviour to an existing method, or appending behaviour to an existing method:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">function</code> <code class="nx">Prepends</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="nx">prepend</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">overriddenMethodFunction</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">];</code>

        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">prependValue</code> <code class="o">=</code> <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

            <code class="k">if</code> <code class="p">(</code><code class="nx">prependValue</code> <code class="o">===</code> <code class="kc">undefined</code> <code class="o">||</code> <code class="o">!!</code><code class="nx">prependValue</code><code class="p">)</code> <code class="p">{</code>
              <code class="k">return</code> <code class="nx">overriddenMethodFunction</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);;</code>
            <code class="p">}</code>
          <code class="p">},</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">throw</code> <code class="sb">`attempt to override non-existant method </code><code class="si">${</code><code class="nx">property</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">Append</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">instanceKeys</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">behaviour</code><code class="p">);</code>

  <code class="kd">function</code> <code class="nx">append</code> <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">of</code> <code class="nx">instanceKeys</code><code class="p">)</code>
      <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">])</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">overriddenMethodFunction</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">property</code><code class="p">];</code>

        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
          <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">returnValue</code> <code class="o">=</code> <code class="nx">overriddenMethodFunction</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

            <code class="nx">behaviour</code><code class="p">[</code><code class="nx">property</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">returnValue</code><code class="p">;</code>
          <code class="p">},</code>
          <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
      <code class="p">}</code>
      <code class="k">else</code> <code class="k">throw</code> <code class="sb">`attempt to override non-existant method </code><code class="si">${</code><code class="nx">property</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>We can compose a lightweight trait using any combination of <code>Define</code>, <code>Override</code>, <code>Prepend</code>, and <code>Append</code>, and the composition is handled by <code>pipeline</code>, a plain old function composition tool.</p>

<p>Lightweight traits are nothing more than protocols, composed in a simple and easy-to-understand way. And then applied to simple classes, in a direct and obvious manner.</p>

<div class="footnotes">
  <ol>
    <li id="fn-colours">See the aforelinked <a href="https://leanpub.com/2015/03/12/symmetry.html">The Symmetry of JavaScript Functions</a><a href="https://leanpub.com/javascriptallongesix/read#fnref-colours" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ESdotlater">By “ES.later,” we mean some future version of ECMAScript that is likely to be approved eventually, but for the moment exists only in transpilers like <a href="http://babeljs.io/">Babel</a>. Obviously, using any ES.later feature in production is a complex decision requiring many more considerations than can be enumerated in a book.<a href="https://leanpub.com/javascriptallongesix/read#fnref-ESdotlater" rel="rev-footnote">↩</a>
</li>
    <li id="fn-adv">Although this example doesn’t show it, if it returns a constructor function, that is what will be assigned to the class’ name. This allows the creation of purely functional mixins and other interesting techniques that are beyond the scope of this post.<a href="https://leanpub.com/javascriptallongesix/read#fnref-adv" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ESdotlater">By “ES.later,” we mean some future version of ECMAScript that is likely to be approved eventually, but for the moment exists only in transpilers like <a href="http://babeljs.io/">Babel</a>. Obviously, using any ES.later feature in production is a complex decision requiring many more considerations than can be enumerated in a book.<a href="https://leanpub.com/javascriptallongesix/read#fnref-ESdotlater" rel="rev-footnote">↩</a>
</li>
    <li id="fn-extremely-simple">The implementations given here are extremely simple in order to illustrate a larger principle of how the pieces fit together. A production library based on these principles would handle needs we’ve seen elsewhere, like defining “class” or “static” properties, making <code>instanceof</code> work, and appeasing the V8 compiler’s optimizations.<a href="https://leanpub.com/javascriptallongesix/read#fnref-extremely-simple" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-more-decorator-recipes">More Decorator Recipes</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/new-ideas.jpg" alt="For the love of coffee: a collection">
  <figcaption>For the love of coffee: a collection</figcaption>
</figure>


<blockquote>
  <p>“The entire history of Mankind’s relationship with coffee is a futile attempt to have the reality of its taste live up to the promise of its aroma.”</p>
</blockquote>

<h3 id="after">After Method Advice</h3>

<p>Consider the bare bones of this <code>Todo</code> class that we might use as part of a ViewModel in a front-end application. Many front-end libraries have special features that allow views or other models to persist changes to one or more actual models and/or data stores.</p>

<p>We’ll just hand-wave by pretending there is a <code>persist</code> method. It could be mixed in or inherited, we’ll sketch it in for illustration:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="p">}</code>

  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code> <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code> <code class="p">}</code>

  <code class="nx">setName</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code> <code class="p">}</code>

  <code class="nx">persist</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// presist changes to model(s) and/or</code>
    <code class="c1">// data stores...</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>Naturally, updating a todo should persist changes. So we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="p">}</code>

  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">persist</code><code class="p">();</code>
  <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">persist</code><code class="p">();</code>
  <code class="p">}</code>

  <code class="nx">setName</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">persist</code><code class="p">();</code>
  <code class="p">}</code>

  <code class="nx">persist</code> <code class="p">()</code> <code class="p">{</code>
    <code class="c1">// presist changes to model(s) and/or</code>
    <code class="c1">// data stores...</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p>This is very similar to making methods fluent. We’re obscuring the primary responsibility of the method with cross-cutting concerns. We can and should abstract persistence into an ES.later decorator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">persists</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

  <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

    <code class="k">this</code><code class="p">.</code><code class="nx">persist</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">persists</code>
  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">persists</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">persists</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">persist</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`persisting </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<h4 id="leanpub-auto-after-decorators">after decorators</h4>

<p>Combinators for functions come in an unlimited panoply of purposes and effects. So do method combinators, but whether from intrinsic utility or custom, certain themes have emerged. One of them that forms a core part of the original <a href="https://en.wikipedia.org/wiki/Flavors_" title="programming_language">Lisp Flavors</a> system and also the <a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-Oriented Programming</a> movement, is decorating a method with some functionality to be performed <em>after</em> the method’s body is evaluated.</p>

<p>What we see above is this pattern: We want to decorate a method with some functionality. Instead of writing a decorator from scratch each time, let’s abstract the wrapping into a combinator that makes an ES.later method decorator:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">after</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">fn</code> <code class="k">of</code> <code class="nx">fns</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>Now we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">persists</code> <code class="o">=</code> <code class="nx">after</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">persist</code><code class="p">();</code> <code class="p">});</code>
</pre></div>

</figure>

<p>Or we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">persists</code> <code class="o">=</code> <code class="nx">after</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">persist</code><code class="p">);</code>
</pre></div>

</figure>

<p>Or we could even write these things inline:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">persist</code><code class="p">)</code>
  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">persist</code><code class="p">)</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">Todo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">persist</code><code class="p">)</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">persist</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`persisting </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>Todo.prototype.persist</code> is a little clunky. We could special-case <code>after</code> to allow us to write <code>@after('persist')</code> as some libraries do, but the beauty of combinators is that they, well, <em>combine</em>. Recall <a href="https://leanpub.com/javascriptallongesix/read#send"><code>send</code></a>. It’s perfect for this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">send</code> <code class="o">=</code> <code class="p">(</code><code class="nx">methodName</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">instance</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">instance</code><code class="p">[</code><code class="nx">methodName</code><code class="p">].</code><code class="nx">apply</code><code class="p">(</code><code class="nx">instance</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Todo</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code> <code class="o">||</code> <code class="s1">'Untitled'</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">send</code><code class="p">(</code><code class="s1">'persist'</code><code class="p">))</code>
  <code class="k">do</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">send</code><code class="p">(</code><code class="s1">'persist'</code><code class="p">))</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">after</code><code class="p">(</code><code class="nx">send</code><code class="p">(</code><code class="s1">'persist'</code><code class="p">))</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">persist</code> <code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`persisting </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
</pre></div>

</figure>

<p><code>after</code> is a combinator that makes ES.later method decorators, and it’s handy for separating concerns.</p>

<h3 id="before">Before Method Advice</h3>

<p>Just as we often wish to decorate a method with <a href="https://leanpub.com/javascriptallongesix/read#after">after advice</a>, we also often wish to decorate methods with some behaviour that happens before a method is invoked. The canonical (and greatly overused) example is logging invocations. But let’s consider another example, a <code>Person</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'firstName'</code><code class="p">),</code>
      <code class="nx">lastName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'lastName'</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>What if we wish to make <code>rename</code> an undoable action? Let’s add a stack. For reasons known only to a secret cabal of enterprisey architects, we wish to make the undo stack something that is lazily initialized, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'firstName'</code><code class="p">),</code>
      <code class="nx">lastName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'lastName'</code><code class="p">),</code>
      <code class="nx">undoStack</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'undoStack'</code><code class="p">),</code>
      <code class="nx">redoStack</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'redoStack'</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">].</code><code class="nx">push</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">firstName</code><code class="p">]</code><code class="o">:</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">],</code>
      <code class="p">[</code><code class="nx">lastName</code><code class="p">]</code><code class="o">:</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code>
    <code class="p">});</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
    <code class="kd">let</code> <code class="nx">oldState</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">].</code><code class="nx">pop</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">oldState</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">oldState</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'barak'</code><code class="p">,</code> <code class="s1">'obama'</code><code class="p">);</code>

<code class="nx">b</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">);</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'Barak Obama'</code>

<code class="nx">b</code><code class="p">.</code><code class="nx">undo</code><code class="p">();</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; 'barak obama'</code>
</pre></div>

</figure>

<p>We can follow the same pattern as we did with <a href="https://leanpub.com/javascriptallongesix/read#after">after advice</a>: Extract the common functionality into a decorator. We’ll write the <code>before</code> combinator to help:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">before</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">fn</code> <code class="k">of</code> <code class="nx">fns</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'firstName'</code><code class="p">),</code>
      <code class="nx">lastName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'lastName'</code><code class="p">),</code>
      <code class="nx">undoStack</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'undoStack'</code><code class="p">),</code>
      <code class="nx">redoStack</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'redoStack'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">usingUndoStack</code> <code class="o">=</code> <code class="nx">before</code><code class="p">(</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">||</code> <code class="p">(</code><code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">]</code> <code class="o">=</code> <code class="p">[]);</code>
<code class="p">})</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">usingUndoStack</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">].</code><code class="nx">push</code><code class="p">({</code>
      <code class="p">[</code><code class="nx">firstName</code><code class="p">]</code><code class="o">:</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">],</code>
      <code class="p">[</code><code class="nx">lastName</code><code class="p">]</code><code class="o">:</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code>
    <code class="p">});</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">usingUndoStack</code>
  <code class="nx">undo</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">oldState</code> <code class="o">=</code> <code class="k">this</code><code class="p">[</code><code class="nx">undoStack</code><code class="p">].</code><code class="nx">pop</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="nx">oldState</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">oldState</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'barak'</code><code class="p">,</code> <code class="s1">'obama'</code><code class="p">)</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">)</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">())</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">undo</code><code class="p">()</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">())</code>
</pre></div>

</figure>

<p>We could, of course, also abstract functionality into a method that we invoke with <code>@after(send('usingUndoStack'))</code> just as we did with our <a href="https://leanpub.com/javascriptallongesix/read#after">after advice</a> examples.</p>

<h3 id="provided">Provided and Unless</h3>

<p>Neither the <a href="https://leanpub.com/javascriptallongesix/read#before">before</a> and <a href="https://leanpub.com/javascriptallongesix/read#after">after</a> ES.later method decorators actually terminate evaluation without throwing something. Normal execution always results in the base method being evaluated. The <code>provided</code> and <code>unless</code> recipes are combinators that produce method decorators that apply a precondition to evaluating the base method body.</p>

<p>The <code>provided</code> combinator turns a function into an ES.later method decorator. The function (or functions) is passed the method arguments before the base method, and it must evaluate to truthy for the base method to be evaluated. The <code>unless</code> combinator does the same thing, but the logic is reversed, the decorating function must not evaluate to truthy:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">provided</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">fn</code> <code class="k">of</code> <code class="nx">fns</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">result</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">unless</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>

    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">fn</code> <code class="k">of</code> <code class="nx">fns</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="nx">result</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
      <code class="p">}</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p><code>provided</code> can be used to check that non-empty strings are provided for names:<sup id="fnref-beware"><a href="https://leanpub.com/javascriptallongesix/read#fn-beware" rel="footnote">1</a></sup></p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'firstName'</code><code class="p">),</code>
      <code class="nx">lastName</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s1">'lastName'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">nonEmptyStrings</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">strs</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">strs</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">truth</code><code class="p">,</code> <code class="nx">str</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="nx">truth</code>
      <code class="o">&amp;&amp;</code> <code class="p">(</code><code class="nx">str</code> <code class="k">instanceof</code> <code class="nb">String</code> <code class="o">||</code> <code class="k">typeof</code> <code class="nx">str</code> <code class="o">===</code> <code class="s1">'string'</code><code class="p">)</code>
      <code class="o">&amp;&amp;</code> <code class="nx">str</code> <code class="o">!==</code> <code class="s1">''</code><code class="p">,</code>
  <code class="kc">true</code><code class="p">);</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">provided</code><code class="p">(</code><code class="nx">nonEmptyStrings</code><code class="p">)</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s1">'barak'</code><code class="p">,</code> <code class="s1">'obama'</code><code class="p">)</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="s1">'Barak'</code><code class="p">,</code> <code class="s1">'Obama'</code><code class="p">)</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">())</code>
<code class="nx">b</code><code class="p">.</code><code class="nx">undo</code><code class="p">()</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">fullName</code><code class="p">())</code>
</pre></div>

</figure>

<p>You may wonder why we didn’t decorate the <code>constructor</code>. Alas, we can’t use a method decorator on a constructor, because it isn’t a method. It just <em>looks like one</em>. It’s still a constructor function, and if we want to modify it, we have to either write a class decorator, or punt all the work of construction to a method, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">constructor</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">rename</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">];</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">provided</code><code class="p">(</code><code class="nx">nonEmptyStrings</code><code class="p">)</code>
  <code class="nx">rename</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">firstName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">[</code><code class="nx">lastName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>There are many variations on decorators that check preconditions for methods. For example, a decorator can be made that throws an exception if the preconditions fail rather than silently skipping the method invocation.</p>

<p>We can use these patterns in many ways. JavaScript is very flexible!</p>

<h3 id="method-advice">Method Advice</h3>

<p>We’ve <a href="https://leanpub.com/javascriptallongesix/read#stateful-method-decorators">previously</a> looked at method decorators like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">once</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">invocations</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WeakSet</code><code class="p">();</code>

  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">invocations</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="k">this</code><code class="p">))</code> <code class="k">return</code><code class="p">;</code>
    <code class="nx">invocations</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">logician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Raymond'</code><code class="p">,</code> <code class="s1">'Smullyan'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Haskell'</code><code class="p">,</code> <code class="s1">'Curry'</code><code class="p">);</code>

<code class="kr">const</code> <code class="nx">musician</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Person</code><code class="p">()</code>
                   <code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s1">'Miles'</code><code class="p">,</code> <code class="s1">'Davis'</code><code class="p">);</code>

<code class="nx">logician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Raymond Smullyan</code>

<code class="nx">musician</code><code class="p">.</code><code class="nx">fullName</code><code class="p">()</code>
  <code class="c1">//=&gt; Miles Davis</code>
</pre></div>

</figure>

<p>We also saw that if our tooling supports ES.later<sup id="fnref-ESdotlater"><a href="https://leanpub.com/javascriptallongesix/read#fn-ESdotlater" rel="footnote">2</a></sup> decorators, we can write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decorator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">decorator</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kd">function</code> <code class="nx">fluent</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">fluent</code><code class="p">)</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>The <code>wrapWith</code> function takes an ordinary method decorator and turns it into an ES.later method decorator.</p>

<h4 id="leanpub-auto-what-question-do-method-decorators-answer">what question do method decorators answer?</h4>

<p>ES.later method decorators put the decorations right next to the method body. This makes it easy to answer the question “What is the precise behaviour of this method?”</p>

<p>But sometimes, this is not what you want. Consider a responsibility like authentication. Let’s imagine that we validate permissions in our model classes. We might write something like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">wrapWith</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decorator</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">descriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">decorator</code><code class="p">(</code><code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">mustBeMe</code> <code class="o">=</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">&amp;&amp;</code> <code class="nx">currentUser</code><code class="p">().</code><code class="nx">person</code><code class="p">().</code><code class="nx">equals</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="k">else</code> <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be me!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">)</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">)</code>
  <code class="nx">setAge</code> <code class="p">(</code><code class="nx">age</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nx">age</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">)</code>
  <code class="nx">age</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">age</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>(Obviously real permissions systems involve roles and all sorts of other important things.)</p>

<p>Now we can look at <code>setName</code> and see that users can only set their own name, likewise if we look at <code>setAge</code>, we see that users can only set their own age.</p>

<p>In a tiny toy example the next question is easy to answer: <em>What methods can only be invoked by the person themselves?</em> We see at a glance that the answer is <code>setName</code>, <code>setAge</code>, and <code>age</code>.</p>

<p>But as classes grow, this becomes more difficult to answer. This especially becomes difficult if we decompose classes using mixins. For example, what if <code>setAge</code> and <code>age</code> come from a <a href="https://leanpub.com/javascriptallongesix/read#class-mixins">class mixin</a>:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">HasAge</code><code class="p">(</code><code class="kr">class</code> <code class="p">{</code>

  <code class="err">@</code><code class="nx">wrapWith</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">)</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">});</code>
</pre></div>

</figure>

<p>Are the methods provided by <code>HasAge</code> wrapped with <code>mustBeMe</code>? Quite possibly not, because the mixin is responsible for defining the behaviour. It’s up to the model class to decide the permissions required. But how would you know if they were?</p>

<p>Method decorators make it easy to answer the question “what is the behaviour of this method?” But they don’t make it easy to answer the question “what methods share this behaviour?”</p>

<p>That question matters, because when decomposing responsibilities, we often decide that a <em>cross-cutting</em> responsibility like permissions should be distinct from an implementation responsibility like storing a name.</p>

<h4 id="leanpub-auto-cross-cutting-method-decorators">cross-cutting method decorators</h4>

<p>There is another way to decorate methods: We can decorate multiple methods in a single declaration. This is called providing <em>method advice</em>.</p>

<p>In JavaScript, we can implement method advice by decorating the entire class. We already have a combinator for making class mixins, it’s a  function that takes a class as an argument and returns the same or different class. We can use the same technique to write a class decorator that decorates one or more methods of the class being passed in. (We’ll use ES.later syntax, but it works just as well with functional syntax):</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">aroundAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="p">...</code><code class="nx">methodNames</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">methodName</code> <code class="k">of</code> <code class="nx">methodNames</code><code class="p">)</code>
      <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="nx">behaviour</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">methodName</code><code class="p">]),</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
      <code class="p">});</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>

<code class="err">@</code><code class="nx">HasAge</code>
<code class="err">@</code><code class="nx">aroundAll</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="s1">'setAge'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">)</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>Now when you look at <code>setName</code>, you don’t see what permissions apply. However, when we look at <code>@aroundAll(mustBeMe, 'setName', 'setAge', 'age')</code>, we see that we’re wrapping <code>setName</code>, <code>setAge</code> and <code>age</code> with <code>mustBeMe</code>.</p>

<p>This focuses the responsibility for permissions in one place. Of course, we could make things simpler. For one thing, some actions are only performed <em>before</em> a method, and some only <em>after</em> a method. We can make class decorators that work just like our <a href="https://leanpub.com/javascriptallongesix/read#before">before</a> and <a href="https://leanpub.com/javascriptallongesix/read#after">after</a> method decorators:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">beforeAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="p">...</code><code class="nx">methodNames</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">methodName</code> <code class="k">of</code> <code class="nx">methodNames</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">methodName</code><code class="p">];</code>

      <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
          <code class="nx">behaviour</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
          <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
        <code class="p">},</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
      <code class="p">});</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">afterAll</code> <code class="o">=</code> <code class="p">(</code><code class="nx">behaviour</code><code class="p">,</code> <code class="p">...</code><code class="nx">methodNames</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">clazz</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">methodName</code> <code class="k">of</code> <code class="nx">methodNames</code><code class="p">)</code> <code class="p">{</code>
      <code class="kr">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">methodName</code><code class="p">];</code>

      <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">clazz</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
          <code class="kr">const</code> <code class="nx">returnValue</code> <code class="o">=</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>

          <code class="nx">behaviour</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
          <code class="k">return</code> <code class="nx">returnValue</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code>
      <code class="p">});</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="nx">clazz</code><code class="p">;</code>
  <code class="p">}</code>
</pre></div>

</figure>

<p>Precondition checks like <code>mustBeMe</code> are good candidates for <code>beforeAll</code>. Here’s <code>mustBeLoggedIn</code> and <code>mustBeMe</code> set up to use <code>beforeAll</code>. They’re far simpler since <code>beforeAll</code> handles the wrapping:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mustBeLoggedIn</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be logged in!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">mustBeMe</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code> <code class="o">||</code> <code class="o">!</code><code class="nx">currentUser</code><code class="p">().</code><code class="nx">person</code><code class="p">().</code><code class="nx">equals</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be me!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="err">@</code><code class="nx">HasAge</code>
<code class="err">@</code><code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="s1">'setAge'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">)</code>
<code class="err">@</code><code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeLoggedIn</code><code class="p">,</code> <code class="s1">'fullName'</code><code class="p">)</code>
<code class="kr">class</code> <code class="nx">Person</code> <code class="p">{</code>

  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>

<code class="p">};</code>
</pre></div>

</figure>

<p>This style of moving the responsibility for decorating methods to a single declaration will appear familiar to Ruby on Rails developers. As you can see, it does not require “deep magic” or complex libraries, it is a pattern that can be written out in just a few lines of code.</p>

<p>Mind you, there’s always room for polish and gold plate. We could enhance <code>beforeAll</code>, <code>afterAll</code>, and <code>aroundAll</code> to include conveniences like regular expressions to match method names, or special declarations like <code>except:</code> or <code>only:</code> if we so desired.</p>

<p>Although decorating methods in bulk has appeared in other languages and paradigms, it’s not something special and alien to JavaScript, it’s really the same pattern we see over and over again: Programming by composing small and single-responsibility entities, and using functions to transform and combine the entities into their final form.</p>

<h4 id="leanpub-auto-a-word-about-es6">a word about es6</h4>

<p>If we don’t want to use ES.later decorators, we can use the exact same decorators as <em>ordinary functions</em>, like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mustBeLoggedIn</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be logged in!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">mustBeMe</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code> <code class="o">||</code> <code class="o">!</code><code class="nx">currentUser</code><code class="p">().</code><code class="nx">person</code><code class="p">().</code><code class="nx">equals</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be me!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code>
  <code class="nx">HasAge</code><code class="p">(</code>
  <code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="s1">'setAge'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">)(</code>
  <code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeLoggedIn</code><code class="p">,</code> <code class="s1">'fullName'</code><code class="p">)(</code>
    <code class="kr">class</code> <code class="p">{</code>
      <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
      <code class="p">}</code>

      <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">)</code>
  <code class="p">)</code>
<code class="p">);</code>
</pre></div>

</figure>

<p>Composition could also help:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">mustBeLoggedIn</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be logged in!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">mustBeMe</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">currentUser</code><code class="p">()</code> <code class="o">==</code> <code class="kc">null</code> <code class="o">||</code> <code class="o">!</code><code class="nx">currentUser</code><code class="p">().</code><code class="nx">person</code><code class="p">().</code><code class="nx">equals</code><code class="p">(</code><code class="k">this</code><code class="p">))</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="nx">PermissionsException</code><code class="p">(</code><code class="s2">"Must be me!"</code><code class="p">);</code>
  <code class="p">}</code>

<code class="kr">const</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code>
  <code class="nx">HasAge</code><code class="p">,</code>
  <code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeMe</code><code class="p">,</code> <code class="s1">'setName'</code><code class="p">,</code> <code class="s1">'setAge'</code><code class="p">,</code> <code class="s1">'age'</code><code class="p">),</code>
  <code class="nx">beforeAll</code><code class="p">(</code><code class="nx">mustBeLoggedIn</code><code class="p">,</code> <code class="s1">'fullName'</code><code class="p">),</code>
<code class="p">)(</code><code class="kr">class</code> <code class="p">{</code>
  <code class="nx">setName</code> <code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">fullName</code> <code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">firstName</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">lastName</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">});</code>
</pre></div>

</figure>

<div class="footnotes">
  <ol>
    <li id="fn-beware">Beware, validating names is a stygian task. Read <a href="http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">falsehoods programmers believe about names</a> before proceeding with ideas like this in production. For example, many people do NOT have both a first and last name.<a href="https://leanpub.com/javascriptallongesix/read#fnref-beware" rel="rev-footnote">↩</a>
</li>
    <li id="fn-ESdotlater">By “ES.later,” we mean some future version of ECMAScript that is likely to be approved eventually, but for the moment exists only in transpilers like <a href="http://babeljs.io/">Babel</a>. Obviously, using any ES.later feature in production is a complex decision requiring many more considerations than can be enumerated in a book.<a href="https://leanpub.com/javascriptallongesix/read#fnref-ESdotlater" rel="rev-footnote">↩</a>
</li>
  </ol>
</div>


<h2 id="leanpub-auto-closing-time-at-the-coffeeshop-final-remarks">Closing Time at the Coffeeshop: Final Remarks</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/future-of-coffee.jpg" alt="The Future of Coffee is Black">
  <figcaption>The Future of Coffee is Black</figcaption>
</figure>


<p>We began this book with the most basic of basic ideas in programming: What is a value? What is a reference to a value? What is a function? What is applying or invoking a function with values?</p>

<p>We then looked at one of the “big ideas” that JavaScript shares with other powerful languages: The idea that functions are values, and thus that you can invoke a function with another function as an argument, and you can return a function from a function.</p>

<p>This led directly to exploring the idea of composing functions: Creating new functions by putting together functions that represent smaller pieces of behaviour. The idea of function decorators emerges naturally from this approach.</p>

<p>From there we went on to explore objects and methods, but underlying our exploration was the constant rediscovery that we can program with objects using the same approach: Composing behaviour out of smaller pieces of behaviour, such as composing object behaviour using delegation.</p>

<h4 id="leanpub-auto-javascript-beyond-es6ecmascript-2015">javascript beyond es6/ecmascript 2015</h4>

<p>When this edition was written, ECMAScript 2015 had been standardized, and almost all of its features were available via polyfills and transpilation tools like Babel. Some post-2015 features, like method and class decorators, had not yet been scheduled for inclusion in the language, but were available in transpilers.</p>

<p>Others, such as fully private properties, mixins, and traits, have been discussed and/or proposed. By the time you are reading this, they might be available experimentally, formally approved, or even widely available.</p>

<p>You may have noticed that as the book progressed, it delved into implementing programming language ideas like method decorators, mixins, and traits. Some books might implement a to-do list, or a content management system, or a MMRPG to provide an opportunity to write example code. This book chooses to explain JavaScript by implementing ideas that hopefully will become standard features by the time you read this.</p>

<p>Many other computer science textbooks do the same thing: They explain how to make a “toy” operating system, or a compiler, or how to make a Lisp in Lisp. And as you have learned, JavaScript is a language strong enough to implement many of its ideas in itself.</p>

<p>By implementing simple versions of features like decorators, mixins, and traits, we examined how to program in a lightweight fashion, and we also gained a deeper understanding of the semantics of functions, methods, classes, delegation, and behaviour.</p>

<p>That is valuable whether we use those features in production or not. And that is valuable whether those features are added to JavaScript, or not.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/espresso-empty.jpg" alt="Espresso, Empty">
  <figcaption>Espresso, Empty</figcaption>
</figure>


<h4 id="leanpub-auto-the-lightweight-way">the lightweight way</h4>

<p>When creating a new abstraction, (for example, <a href="https://leanpub.com/javascriptallongesix/read#traits">traits</a>), there are two ways to do it: The heavyweight way, and the lightweight way.</p>

<p>The lightweight way, as explained throughout this book, attempts to be as “JavaScript-y” as possible. For example, using functions for protocols and composing them. With the lightweight way, everything is still just a function, or just an object, or just a class with just a prototype. Lightweight code interoperates 100% with code from other libraries. Lightweight approaches can be incrementally added to an existing code base, refactoring a bit here and a bit there.</p>

<p>The heavyweight way would <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">greenspun</a> a special class hierarchy with support for traits baked in. The heavyweight way would produce “classes” that don’t easily interoperate with other libraries or code, so you can’t incrementally make changes: You have to “boil the ocean” and commit 100% to the new approach. Heavyweight approaches often demand new kinds of tooling in the build pipeline.</p>

<p>When we do things the lightweight way, we make very small bets on their benefits. It’s easy to change our mind and abandon the approach in favour of something else. because we make small bets along the way, we collect on the small benefits continuously: We don’t have to kick off a massive rewrite of our code base to start using lightweight traits, for example. We just start using them as little or as much as we like, and immediately start benefiting from them.</p>

<blockquote>
  <p>“A language that doesn’t affect the way you think about programming isn’t worth learning.”—Alan J. Perlis</p>
</blockquote>

<p>Every tool affects the way we think about programming. But heavyweight tools force us to think about the heavyweight tooling. That thinking isn’t always portable to another tool or another code base.</p>

<p>Whereas lightweight tools are simple things, composed together in simple ways. If we move to a different code base or tool, we can take our experience with the simple things along. With lightweight traits, for example, we are not teaching ourselves how to “program with traits,” we’re teaching ourselves how to “decompose behaviour,” how to “compose functions” and how to “write functions that decorate entities.”</p>

<p>These are all fundamental ideas that apply everywhere, even if we don’t end up applying them to build a feature like traits. Lightweight thinking is portable and future-proof.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/the-end.jpg" alt="The End">
  <figcaption>The End</figcaption>
</figure>



<h2 id="leanpub-auto-the-golden-crema-appendices-and-afterwords">The Golden Crema: Appendices and Afterwords</h2>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/la_marzocco.jpg" alt="La Marzocco">
  <figcaption>La Marzocco</figcaption>
</figure>


<h3 id="online">How to run the examples</h3>

<p>At the time this book was written, ECMAScript 2015 was not yet widely available. All of the examples in this book were tested using either <a href="https://github.com/google/traceur-compiler">Google Traceur Compiler</a>, <a href="http://babeljs.io/">Babel</a>, or both. Traceur and Babel are both <em>transpilers</em>, they work by parsing ECMAScript 2015 code, then emitting valid ECMAScript-5 code that produces the same semantics.</p>

<p>For example, this ECMAScript 2015 code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">before</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decoration</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="nx">decoration</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">)</code>
    <code class="p">};</code>
</pre></div>

</figure>

<p>Is translated into this ECMAScript-5 code:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="s2">"use strict"</code>

<code class="kd">var</code> <code class="nx">before</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">decoration</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="nx">decoration</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">};</code>
<code class="p">};</code>
</pre></div>

</figure>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/6to5.png" alt="The Babel &quot;try it out&quot; page">
  <figcaption>The Babel “try it out” page</figcaption>
</figure>


<p>If we make it even more idiomatic, we could write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kr">const</code> <code class="nx">before</code> <code class="o">=</code> <code class="p">(</code><code class="nx">decoration</code><code class="p">)</code> <code class="o">=&gt;</code>
    <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="o">=&gt;</code>
      <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">decoration</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>
      <code class="p">};</code>
</pre></div>

</figure>

<p>And it would be “transpiled” into:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="kd">var</code> <code class="nx">before</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">decoration</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">method</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">_len</code> <code class="o">=</code> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code> <code class="nx">args</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">(</code><code class="nx">_len</code><code class="p">),</code> <code class="nx">_key</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">_key</code> <code class="o">&lt;</code> <code class="nx">_le</code><code class="o">\</code>
<code class="nx">n</code><code class="p">;</code> <code class="nx">_key</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">args</code><code class="p">[</code><code class="nx">_key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">arguments</code><code class="p">[</code><code class="nx">_key</code><code class="p">];</code>
      <code class="p">}</code>

      <code class="nx">decoration</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
      <code class="k">return</code> <code class="nx">method</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">};</code>
<code class="p">};</code>
</pre></div>

</figure>

<p>Both tools offer an online area where you can type ECMAScript code into a web browser and see the ECMAScript-5 equivalent, and you can run the code as well. To see the result of your expressions, you may have to use the console in your web browser.</p>

<p>So instead of just writing:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)()</code>
</pre></div>

</figure>

<p>And having <code>4</code> displayed, you’d need to write:</p>

<figure class="code">
<div class="highlight"><pre><code></code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>
  <code class="p">(()</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">+</code> <code class="mi">2</code><code class="p">)()</code>
<code class="p">)</code>
</pre></div>

</figure>

<p>And <code>4</code> would appear in your browser’s development console.</p>

<p>You can also install the transpilers on your development system and use them with <a href="http://nodejs.org/">Node</a> on <a href="https://en.wikipedia.org/wiki/REPL" title="Read–eval–print loop">the command line</a>. The care and feeding of <code>node</code> and <code>npm</code> are beyond the scope of this book, but both tools offer clear instructions for those who have already installed <code>node</code>.</p>

<h3 id="leanpub-auto-thanks">Thanks!</h3>

<h4 id="leanpub-auto-daniel-friedman-and-matthias-felleisen">Daniel Friedman and Matthias Felleisen</h4>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/little-schemer.jpg" alt="The Little Schemer">
  <figcaption>The Little Schemer</figcaption>
</figure>


<p><em>JavaScript Allongé</em> was inspired by <a href="http://www.amzn.com/0262560992?tag=raganwald001-20">The Little Schemer</a> by Daniel Friedman and Matthias Felleisen. But where <em>The Little Schemer’s</em> primary focus is recursion, <em>JavaScript Allongé’s</em> primary focus is <strong>functions as first-class values</strong>.</p>

<div class="page-break"></div>
<h4 id="leanpub-auto-richard-feynman">Richard Feynman</h4>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/qed.jpg" alt="QED: The Strange Theory of Light and Matter">
  <figcaption>QED: The Strange Theory of Light and Matter</figcaption>
</figure>


<p>Richard Feynman’s <a href="http://www.amzn.com/0691125759?tag=raganwald001-20">QED</a> was another inspiration: A book that explains Quantum Electrodynamics and the “Sum of the Histories” methodology using the simple expedient of explaining how light reflects off a mirror, and showing how most of the things we think are happening–such as light travelling on a straight line,  the angle of reflection equalling the angle of refraction, or that a beam of light only interacts with a small portion of the mirror, or that it reflects off a plane–are all wrong. And everything is explained in simple, concise terms that build upon each other logically.</p>

<div class="page-break"></div>
<h3 id="leanpub-auto-reading-javascript-allong-on-kindle">Reading JavaScript Allongé on Kindle</h3>

<p>JavaScript Allongé has over 400 pages and many photographs. For this reason, the <code>.mobi</code> version of the book is too big to be sent to your Kindle via email, and that is the feature that LeanPub uses when you purchase the book.</p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/kindle.png" alt="Send to Kindle">
  <figcaption>Send to Kindle</figcaption>
</figure>


<p>So, if you wish to read JavaScript Allongé on your Kindle:</p>

<ul>
  <li>Download it to your Windows or OS X device (a/k/a “PC” or “Macintosh”).</li>
  <li>Use <a href="http://www.amazon.com/gp/sendtokindle/pc">Send to Kindle for PC</a> or <a href="http://www.amazon.com/gp/sendtokindle/mac">Send to Kindle for Mac</a> to send it to the Kindle.</li>
  <li>From time to time while editing, an uncompressed image sneaks into the manuscript. When this happens, the <code>.mobi</code> may exceed the 50MB limit for the Send to Kindle desktop application. If this happens, please attach your Kindle to your computer with a USB cable and synchronize directly.</li>
</ul>

<p>Thank you!</p>

<h3 id="leanpub-auto-copyright-notice">Copyright Notice</h3>

<p>The original words in this book are (c) 2012-2015, Reginald Braithwaite. All rights reserved.</p>

<h4 id="leanpub-auto-images">images</h4>

<ul>
  <li>The picture of the author is (c) 2008, <a href="http://www.flickr.com/photos/trumpetca/">Joseph Hurtado</a>, All Rights Reserved.</li>
  <li>
<a href="http://www.flickr.com/photos/avlxyz/4907262046">Cover image</a> (c) 2010, avlxyz. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/digitalcolony/5054568279/">Double ristretto menu</a> (c) 2010, Michael Allen Smith. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/everydaylifemodern/1353570874/">Short espresso shot in a white cup with blunt handle</a> (c) 2007, EVERYDAYLIFEMODERN. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/everydaylifemodern/434299813/">Espresso shot in a caffe molinari cup</a> (c) 2007, EVERYDAYLIFEMODERN. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/the_rev/2295096211/">Beans in a Bag</a> (c) 2008, Stirling Noyes. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some Rights Reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/thedigitelmyr/6199419022/">Free Samples</a> (c) 2011, Myrtle Bech Digitel. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some Rights Reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/sagamiono/4391542823/">Free Coffees</a> image (c) 2010, Michael Francis McCarthy. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some Rights Reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/digitalcolony/3924227011/">La Marzocco</a> (c) 2009, Michael Allen Smith. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/15481483@N06/6231443466/">Cafe Diplomatico</a> (c) 2011, Missi. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/tjgfernandes/2785677276/">Sugar Service</a> (c) 2008 Tiago Fernandes. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/kirstenloza/4805716699/">Biscotti on a Rack</a> (c) 2010 Kirsten Loza. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/jenny-pics/5053954146/">Coffee Spoons</a> (c) 2010 Jenny Downing. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/33388953@N04/4017985434/">Drawing a Doppio</a> (c) 2008 Osman Bas. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/tangysd/5953453156/">Cupping Coffees</a> (c) 2011 Dennis Tang. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/digitalcolony/4000837035/">Three Coffee Roasters</a> (c) 2009 Michael Allen Smith. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/digitalcolony/4309812256/">Blue Diedrich Roaster</a> (c) 2010 Michael Allen Smith. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/bike/3237859728/">Red Diedrich Roaster</a> (c) 2009 Richard Masoner. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/lacerabbit/2102801319/">Roaster with Tree Leaves</a> (c) 2007 ting. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/nalundgaard/4785922266/">Half Drunk</a> (c) 2010 Nicholas Lundgaard. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/paulmccoubrie/6828131856/">Anticipation</a> (c) 2012 Paul McCoubrie. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/mikecogh/7676649034/">Ooh!</a> (c) 2012 Michael Coghlan. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/yellowskyphotography/5641003165/">Intestines of an Espresso Machine</a> (c) 2011 Angie Chung. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/andynash/6204253236/">Bezzera Espresso Machine</a> (c) 2011 Andrew Nash. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.
*<a href="http://www.flickr.com/photos/28705377@N04/5306009552/">Beans Ripening on a Branch</a> (c) 2008 John Pavelka. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/shavejonathan/2343081208/">Cafe Macchiato on Gazotta Della Sport</a> (c) 2008 Jon Shave. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/ilovememphis/7103931235/">Jars of Coffee Beans</a> (c) 2012 Memphis CVB. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/mikecogh/7561440544/">Types of Coffee Drinks</a> (c) 2012 Michael Coghlan. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/dtownsend/6171015997/">Coffee Trees</a> (c) 2011 Dave Townsend. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/93425126@N00/313053257/">Cafe do Brasil</a> (c) 2003 Temporalata. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/digitalcolony/2833809436/">Brown Cups</a> (c) 2007 Michael Allen Smith. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/citizenhelder/5006498068/">Mirage</a> (c) 2010 Mira Helder. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/joncrel/237026246/">Coffee Van with Bullet Holes</a> (c) 2006 Jon Crel. <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/nalundgaard/3163852170/">Disassembled Elektra</a> (c) 2009 Nicholas Lundgaard. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/47000103@N05/6525288841/">Nederland Buffalo Bills Coffee Shop</a> (c) 2009 Charlie Stinchcomb. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/lotzman/978418891/">For the love of coffee</a> (c) 2007 Lotzman Katzman. <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="http://www.flickr.com/photos/kk/sets/72157626168201654/with/5484839102/">Saltspring Processing Facility Pictures</a> (c) 2011 Kris Krug. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/kellan/434503323">Coffee and Mathematics</a> (c) 2007 <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/whitneyinchicago/3835218626">Coffee and a Book</a> (c) 2009 <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/sankarshan/5165312159">Stacked Coffee Cups</a> (c) 2010 Sankarshan Sen. <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/candy-s/7619358284">Coffee Cow</a> (c) 2012 <a href="https://www.flickr.com/photos/candy-s/">Candy Schwartz</a> <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/lorentey/22193876">CERN Coffee</a> (c) 2005 <a href="https://www.flickr.com/photos/lorentey/">Karoly Lorentey</a> <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/kk/5484876862">Coffee Labels</a> (c) 2011 Kris Krüg <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/f_mafra/2956649121">banco do café</a> (c) 2008 Fernando Mafra <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/jforth/3360599750/">coffee pots</a> (c) 2009 Jonas Forth <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/dlytle/8720139854">5 Barrel Roaster</a> (c) 2013 David Lytle <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/joebehr/5504285781">Pantone mugs</a> (c) 2011 Joe Wolf <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/adders/8372085101">Coffee and Chess</a> (c) 2013 Adam Tinworth <a href="http://creativecommons.org/licenses/by-nd/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/digitalcolony/2843767532">Vac Pot Upper Chamber</a> (c) 2007 Michael Allen Smith <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/arisvrakas/4217869291">Decaf espresso</a> (c) 2009 Aris Vrakas <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/vscript/8708520929">Con Panna</a> (c) 2013 Vee Satayamas <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/peterme/1271652">Tiny’s Coffeehouse</a> (c) 2004 Peter Merholz <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/renaud-camus/6165559492">Thinking about programming</a> (c) 2011 Renaud Camus <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/cyclonebill/2606398721">Biscotti og kaffe</a> (c) 2008 <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/tillwe/8154272083">Espresso, Empty</a> (c) 2012 Till Westermayer <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/peddhapati/11671457605">The End</a> (c) 2013 peddhapati <a href="http://creativecommons.org/licenses/by/2.0/deed.en">Some rights reserved</a>.</li>
  <li>
<a href="https://www.flickr.com/photos/mjaysplanet/8416343475">The Future of Coffee is Black</a> (c)2013 mjaysplanet <a href="http://creativecommons.org/licenses/by-sa/2.0/deed.en">Some rights reserved</a>.</li>
</ul>

<h3 id="leanpub-auto-about-the-author">About The Author</h3>

<p>When he’s not shipping JavaScript, Ruby, CoffeeScript and Java applications scaling out to millions of users, Reg “Raganwald” Braithwaite has authored <a href="http://github.com/raganwald">libraries</a> for JavaScript, CoffeeScript, and Ruby programming such as Allong.es, Method Combinators, Katy, JQuery Combinators, YouAreDaChef, andand, and others.</p>

<p>He writes about programming on “<a href="http://raganwald/">Raganwald</a>,” as well as general-purpose ruminations on “<a href="http://braythwayt.com/">Braythwayt Dot Com</a>”.</p>

<h4 id="leanpub-auto-contact">contact</h4>

<p>Twitter: <a href="https://twitter.com/raganwald">@raganwald</a>
Email: <a href="mailto:reg@braythwayt.com">reg@braythwayt.com</a></p>


<figure class="image center">
  <img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/reg2.jpg" alt="Reg &quot;Raganwald&quot; Braithwaite ">
  <figcaption>Reg “Raganwald” Braithwaite </figcaption>
</figure>



</div>


</section>
</div>

</div>
<div id="react-modal"></div>

<footer class="footer">
<div class="container--medium">
<h1 class="footer-logo">
<a href="https://leanpub.com/"><img src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/logo-white-96-67-2x-59bc6e27ee93432fdf870def24412756.png" alt="Logo white 96 67 2x">
</a></h1>
<div class="footer-links">
<ul class="footer-list">
<li>
<h5 class="footer-list-title">About</h5>
</li>
<li><a href="http://blog.leanpub.com/">Blog</a></li>
<li><a href="https://leanpub.com/team">Team</a></li>
<li><a href="https://itunes.apple.com/ca/podcast/leanpub-podcast/id517117137" target="_blank">Podcast</a></li>
<li><a href="https://leanpub.com/contact">Contact</a></li>
<li><a href="https://leanpub.com/press">Press</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Authors</h5>
</li>
<li><a href="https://leanpub.com/authors">Why Leanpub</a></li>
<li><a href="https://leanpub.com/pricing">Pricing</a></li>
<li><a href="https://leanpub.com/manifesto">Manifesto</a></li>
<li><a href="https://leanpub.com/romance">Romance Authors</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Author Support</h5>
</li>
<li><a href="http://help.leanpub.com/author-help">Author Help</a></li>
<li><a href="https://leanpub.com/help">Getting Started</a></li>
<li><a href="https://leanpub.com/help/manual">Manual</a></li>
<li><a href="https://leanpub.com/help/api">API Docs</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">More</h5>
</li>
<li><a href="http://help.leanpub.com/reader-help">Reader Help</a></li>
<li><a href="https://leanpub.com/p">Publishers</a></li>
<li><a href="https://leanpub.com/causes">Causes</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Legal</h5>
</li>
<li><a href="https://leanpub.com/terms">Terms of Service</a></li>
<li><a href="https://leanpub.com/takedown">Copyright Policy</a></li>
<li><a href="https://leanpub.com/privacy">Privacy Policy</a></li>
</ul>
</div>
<p class="footer-copyright">
Leanpub is copyright © 2010-2017 <a href="http://ruboss.com/">Ruboss Technology Corp.</a> All rights reserved.
</p>
</div>
</footer>


<script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/application-2503d9d7a7c7eb7ddf13d8bf1cb4434c.js"></script>
<!-- Facebook Pixel Code -->
<script>
!function(f,b,e,v,n,t,s)
{if(f.fbq)return;n=f.fbq=function(){n.callMethod?
n.callMethod.apply(n,arguments):n.queue.push(arguments)};
if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
n.queue=[];t=b.createElement(e);t.async=!0;
t.src=v;s=b.getElementsByTagName(e)[0];
s.parentNode.insertBefore(t,s)}(window,document,'script',
'https://connect.facebook.net/en_US/fbevents.js');
 fbq('init', '210960779347704');
fbq('track', 'PageView');
</script>
<noscript>
 &lt;img height="1" width="1"
src="https://www.facebook.com/tr?id=210960779347704&amp;ev=PageView
&amp;noscript=1"/&gt;
</noscript>
<!-- End Facebook Pixel Code -->

<!-- Twitter universal website tag code -->
<script>
!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
// Insert Twitter Pixel ID and Standard Event data below
twq('init','nw0pa');
twq('track','PageView');
</script>
<!-- End Twitter universal website tag code -->

<script type="text/javascript">  var _gaq = _gaq || [];
  _gaq.push(['account2._setAccount', 'UA-27959034-9']);
  _gaq.push(['account2._setDomainName', 'leanpub.com']);
  _gaq.push(['account2._trackPageview']);
</script>


<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: STIXSizeOneSym, sans-serif;"></div></div><script src="./Read JavaScript Allongé, the _Six_ Edition _ Leanpub_files/adsct" type="text/javascript"></script><div id="SL_balloon_obj" alt="0" style="display: block;"><div id="SL_button" class="SL_ImTranslatorLogo" style="display: none; background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/imtranslator-s.png&quot;);"></div><div id="SL_shadow_translation_result2" style="display: none;"></div><div id="SL_shadow_translator" style="display: none;"><div id="SL_planshet" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/bg2.png&quot;) rgb(244, 245, 245);"><div id="SL_arrow_up" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/up.png&quot;);"></div><div id="SL_providers"><div class="SL_BL_LABLE_ON" title="Google" id="SL_P0">G</div><div class="SL_BL_LABLE_ON" title="Microsoft" id="SL_P1">M</div><div class="SL_BL_LABLE_ON" title="Translator" id="SL_P2">T</div></div><div id="SL_alert_bbl" style="display: none;"><div id="SLHKclose" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/delete.png&quot;);"></div><div id="SL_alert_cont"></div></div><div id="SL_TB"><div id="SL_bubblelogo" class="SL_ImTranslatorLogo" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/imtranslator-s.png&quot;);"></div><table id="SL_tables" cellspacing="1"><tr><td class="SL_td" width="10%" align="right"><input id="SL_locer" type="checkbox" title="鎖定語言"></td><td class="SL_td" width="20%" align="left"><select id="SL_lng_from"><option value="auto">檢測語言</option><option value="sq">阿尔巴尼亚语</option><option value="ar">阿拉伯语</option><option value="az">阿塞拜疆语</option><option value="ga">爱尔兰语</option><option value="et">爱沙尼亚语</option><option value="eu">巴斯克语</option><option value="be">白俄罗斯语</option><option value="bg">保加利亚语</option><option value="is">冰岛语</option><option value="pl">波兰语</option><option value="bs">波斯尼亚语</option><option value="fa">波斯语</option><option value="af">布尔语(南非荷兰语)</option><option value="da">丹麦语</option><option value="de">德语</option><option value="ru">俄语</option><option value="fr">法语</option><option value="tl">菲律宾语</option><option value="fi">芬兰语</option><option value="km">高棉语</option><option value="ka">格鲁吉亚语</option><option value="gu">古吉拉特语</option><option value="kk">哈萨克语</option><option value="ht">海地克里奥尔语</option><option value="ko">韩语</option><option value="ha">豪萨语</option><option value="nl">荷兰语</option><option value="gl">加利西亚语</option><option value="ca">加泰罗尼亚语</option><option value="cs">捷克语</option><option value="kn">卡纳达语</option><option value="hr">克罗地亚语</option><option value="la">拉丁语</option><option value="lv">拉脱维亚语</option><option value="lo">老挝语</option><option value="lt">立陶宛语</option><option value="ro">罗马尼亚语</option><option value="mg">马尔加什语</option><option value="mt">马耳他语</option><option value="mr">马拉地语</option><option value="ml">马拉雅拉姆语</option><option value="ms">马来语</option><option value="mk">马其顿语</option><option value="mi">毛利语</option><option value="mn">蒙古语</option><option value="bn">孟加拉语</option><option value="my">缅甸语</option><option value="hmn">苗语</option><option value="zu">南非祖鲁语</option><option value="ne">尼泊尔语</option><option value="no">挪威语</option><option value="pa">旁遮普语</option><option value="pt">葡萄牙语</option><option value="ny">齐切瓦语</option><option value="ja">日语</option><option value="sv">瑞典语</option><option value="sr">塞尔维亚语</option><option value="st">塞索托语</option><option value="si">僧伽罗语</option><option value="eo">世界语</option><option value="sk">斯洛伐克语</option><option value="sl">斯洛文尼亚语</option><option value="sw">斯瓦希里语</option><option value="ceb">宿务语</option><option value="so">索马里语</option><option value="tg">塔吉克语</option><option value="te">泰卢固语</option><option value="ta">泰米尔语</option><option value="th">泰语</option><option value="tr">土耳其语</option><option value="cy">威尔士语</option><option value="ur">乌尔都语</option><option value="uk">乌克兰语</option><option value="uz">乌兹别克语</option><option value="iw">希伯来语</option><option value="el">希腊语</option><option value="es">西班牙语</option><option value="hu">匈牙利语</option><option value="hy">亚美尼亚语</option><option value="ig">伊博语</option><option value="it">意大利语</option><option value="yi">意第绪语</option><option value="hi">印地语</option><option value="su">印尼巽他语</option><option value="id">印尼语</option><option value="jw">印尼爪哇语</option><option value="en">英语</option><option value="yo">约鲁巴语</option><option value="vi">越南语</option><option value="zh-CN">中文简体</option><option value="zh-TW">中文繁体</option></select></td><td class="SL_td" width="3" align="center"><div id="SL_switch_b" title="切換語言" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/switchb.png&quot;);"></div></td><td class="SL_td" width="20%" align="left"><select id="SL_lng_to"><option value="sq">阿尔巴尼亚语</option><option value="ar">阿拉伯语</option><option value="az">阿塞拜疆语</option><option value="ga">爱尔兰语</option><option value="et">爱沙尼亚语</option><option value="eu">巴斯克语</option><option value="be">白俄罗斯语</option><option value="bg">保加利亚语</option><option value="is">冰岛语</option><option value="pl">波兰语</option><option value="bs">波斯尼亚语</option><option value="fa">波斯语</option><option value="af">布尔语(南非荷兰语)</option><option value="da">丹麦语</option><option value="de">德语</option><option value="ru">俄语</option><option value="fr">法语</option><option value="tl">菲律宾语</option><option value="fi">芬兰语</option><option value="km">高棉语</option><option value="ka">格鲁吉亚语</option><option value="gu">古吉拉特语</option><option value="kk">哈萨克语</option><option value="ht">海地克里奥尔语</option><option value="ko">韩语</option><option value="ha">豪萨语</option><option value="nl">荷兰语</option><option value="gl">加利西亚语</option><option value="ca">加泰罗尼亚语</option><option value="cs">捷克语</option><option value="kn">卡纳达语</option><option value="hr">克罗地亚语</option><option value="la">拉丁语</option><option value="lv">拉脱维亚语</option><option value="lo">老挝语</option><option value="lt">立陶宛语</option><option value="ro">罗马尼亚语</option><option value="mg">马尔加什语</option><option value="mt">马耳他语</option><option value="mr">马拉地语</option><option value="ml">马拉雅拉姆语</option><option value="ms">马来语</option><option value="mk">马其顿语</option><option value="mi">毛利语</option><option value="mn">蒙古语</option><option value="bn">孟加拉语</option><option value="my">缅甸语</option><option value="hmn">苗语</option><option value="zu">南非祖鲁语</option><option value="ne">尼泊尔语</option><option value="no">挪威语</option><option value="pa">旁遮普语</option><option value="pt">葡萄牙语</option><option value="ny">齐切瓦语</option><option value="ja">日语</option><option value="sv">瑞典语</option><option value="sr">塞尔维亚语</option><option value="st">塞索托语</option><option value="si">僧伽罗语</option><option value="eo">世界语</option><option value="sk">斯洛伐克语</option><option value="sl">斯洛文尼亚语</option><option value="sw">斯瓦希里语</option><option value="ceb">宿务语</option><option value="so">索马里语</option><option value="tg">塔吉克语</option><option value="te">泰卢固语</option><option value="ta">泰米尔语</option><option value="th">泰语</option><option value="tr">土耳其语</option><option value="cy">威尔士语</option><option value="ur">乌尔都语</option><option value="uk">乌克兰语</option><option value="uz">乌兹别克语</option><option value="iw">希伯来语</option><option value="el">希腊语</option><option value="es">西班牙语</option><option value="hu">匈牙利语</option><option value="hy">亚美尼亚语</option><option value="ig">伊博语</option><option value="it">意大利语</option><option value="yi">意第绪语</option><option value="hi">印地语</option><option value="su">印尼巽他语</option><option value="id">印尼语</option><option value="jw">印尼爪哇语</option><option value="en">英语</option><option value="yo">约鲁巴语</option><option value="vi">越南语</option><option value="zh-CN">中文简体</option><option value="zh-TW">中文繁体</option></select></td><td class="SL_td" width="21%" align="center"> </td><td class="SL_td" width="6%" align="center"><div id="SL_TTS_voice" title="聆聽" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/tts-voice.png&quot;);"></div></td><td class="SL_td" width="6%" align="center"><div id="SL_copy" title="複製譯文" class="SL_copy" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/copy_hand.png&quot;);"></div></td><td class="SL_td" width="6%" align="center"><div id="SL_bbl_font_patch"></div><div id="SL_bbl_font" title="字體大小" class="SL_bbl_font" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/font-off.png&quot;);"></div></td><td class="SL_td" width="6%" align="center"><div id="SL_TH" title="翻譯歷史" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/history.png&quot;);"></div></td><td class="SL_td" width="10%"> </td><td class="SL_td" width="8%" align="right"><div id="SL_pin" title="固定彈出窗口" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/pin-on.png&quot;);"></div></td></tr></table></div></div><div id="SL_shadow_translation_result" style="visibility: visible;"></div><div id="SL_loading" class="SL_loading" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/loading.gif&quot;);"></div><div id="SL_player2"></div><div id="SL_alert100">語言功能限100個字符</div><div id="SL_Balloon_options" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/bg3.png&quot;) rgb(255, 255, 255);"><div id="SL_arrow_down" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/down.png&quot;);"></div><table width="100%"><tr><td width="18%" align="left" height="16"><div id="SL_bbl_donate" title="進行一點捐款" style="background: url(&quot;chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/img/util/donate2.png&quot;);"></div></td><td width="68%" align="center"><a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/html/options/options.html?bbl" target="_blank" class="SL_options" title="顯示選項">選項</a> : <a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/html/options/options.html?hist" target="_blank" class="SL_options" title="翻譯歷史">歷史</a> : <a href="http://about.imtranslator.net/tutorials/presentations/imtranslator-for-chrome/chrome-bubble-translator/" target="_blank" class="SL_options" title="幫助">幫助</a> : <a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/content/html/options/options.html?feed" target="_blank" class="SL_options" title="反饋">反饋</a></td><td width="15%" align="right"><span id="SL_Balloon_Close" title="關閉">關閉</span></td></tr></table></div></div></div></body></html>